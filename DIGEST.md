# Forge API Digest

Auto-generated from rustdoc JSON. Public API surface for all workspace crates.

## forge-types

```rust
/// Analyze a string for mixed-script content (MECHANISM per IFA-8).
pub fn detect_mixed_script(input: &str, field_name: &str) -> Option<HomoglyphWarning>; @ types/src/confusables.rs:77

/// Sanitize a filesystem path string for terminal display.
pub fn sanitize_path_display(input: &str) -> std::borrow::Cow<'_, str>; @ types/src/sanitize.rs:98

/// Sanitize text for safe terminal display.
pub fn sanitize_terminal_text(input: &str) -> std::borrow::Cow<'_, str>; @ types/src/sanitize.rs:56

/// Strip invisible Unicode characters used for steganographic prompt injection.
pub fn strip_steganographic_chars(input: &str) -> std::borrow::Cow<'_, str>; @ types/src/sanitize.rs:314

/// Truncate a string to a maximum length, adding `...` if needed.
pub fn truncate_with_ellipsis(raw: &str, max: usize) -> String; @ types/src/text.rs:9

/// API-reported token usage from provider responses.
pub struct ApiUsage { @ types/src/lib.rs:1382
    /// Total input tokens (includes cached tokens).
    pub input_tokens: u32,
    /// Input tokens read from cache (cache hits).
    pub cache_read_tokens: u32,
    /// Input tokens written to cache (cache misses that were cached).
    pub cache_creation_tokens: u32,
    /// Output tokens generated by the model.
    pub output_tokens: u32,
}

impl ApiUsage {
    /// Cache hit percentage (0-100).
    pub fn cache_hit_percentage(&self) -> f64; @ types/src/lib.rs:1422
    pub const fn has_data(&self) -> bool; @ types/src/lib.rs:1416
    /// Merge another usage into this one (for aggregation across multiple API calls).
    pub fn merge(&mut self, other: &ApiUsage); @ types/src/lib.rs:1404
    /// Input tokens that were not read from cache.
    pub const fn non_cached_input_tokens(&self) -> u32; @ types/src/lib.rs:1399
}

pub struct AssistantMessage { @ types/src/lib.rs:1592
}

impl AssistantMessage {
    pub fn content(&self) -> &str; @ types/src/lib.rs:1610
    pub fn model(&self) -> &ModelName; @ types/src/lib.rs:1620
    pub fn new(model: ModelName, content: NonEmptyString) -> Self; @ types/src/lib.rs:1601
    pub fn provider(&self) -> Provider; @ types/src/lib.rs:1615
}

/// Cache slot budget for a Claude API request.
pub struct CacheBudget { @ types/src/lib.rs:1065
}

impl CacheBudget {
    pub fn full() -> Self; @ types/src/lib.rs:1077
    /// Construct a budget, clamping to `MAX`.
    pub fn new(slots: u8) -> Self; @ types/src/lib.rs:1072
    pub fn remaining(self) -> u8; @ types/src/lib.rs:1082
    /// Consume one slot. Returns the decremented budget, or `None` if exhausted.
    pub fn take_one(self) -> Option<CacheBudget>; @ types/src/lib.rs:1088
}

/// A message with an associated cache hint for API serialization.
pub struct CacheableMessage { @ types/src/lib.rs:1808
    pub message: Message,
    pub cache_hint: CacheHint,
}

impl CacheableMessage {
    pub fn cached(message: Message) -> Self; @ types/src/lib.rs:1828
    pub fn new(message: Message, cache_hint: CacheHint) -> Self; @ types/src/lib.rs:1815
    pub fn plain(message: Message) -> Self; @ types/src/lib.rs:1823
}

pub struct EmptyStringError { @ types/src/lib.rs:90
}

pub struct EnumParseError { @ types/src/lib.rs:362
}

impl EnumParseError {
    pub const fn expected(&self) -> &'static [&'static str]; @ types/src/lib.rs:389
    pub const fn kind(&self) -> EnumKind; @ types/src/lib.rs:379
    pub fn new<impl Into<String>: Into<String>>(kind: EnumKind, raw: impl Into<String>, expected: &'static [&'static str]) -> Self; @ types/src/lib.rs:370
    pub fn raw(&self) -> &str; @ types/src/lib.rs:384
}

/// Proof that homoglyph analysis was performed and detected suspicious content.
pub struct HomoglyphWarning { @ types/src/confusables.rs:23
    /// The field name where mixed scripts were detected (e.g., "url", "command").
    pub field_name: String,
    /// A truncated snippet of the suspicious content for display.
    pub snippet: String,
    /// The scripts detected in the content.
    pub scripts: Vec<unicode_script::Script>,
}

impl HomoglyphWarning {
    /// Format scripts for human-readable display.
    pub fn scripts_display(&self) -> String; @ types/src/confusables.rs:37
}

pub struct ModelName { @ types/src/lib.rs:641
}

impl ModelName {
    pub fn as_str(&self) -> &str; @ types/src/lib.rs:688
    pub const fn from_predefined(model: PredefinedModel) -> Self; @ types/src/lib.rs:675
    pub fn parse(provider: Provider, raw: &str) -> Result<Self, ModelParseError>; @ types/src/lib.rs:648
    pub fn predefined(&self) -> PredefinedModel; @ types/src/lib.rs:693
    pub const fn provider(&self) -> Provider; @ types/src/lib.rs:683
}

impl Display for ModelName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

impl Deserialize<'de> for ModelName {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where D: serde::Deserializer<'de>;
}

/// **Note**: This only validates non-emptiness, not whitespace...
pub struct NonEmptyStaticStr { @ types/src/lib.rs:168
}

impl NonEmptyStaticStr {
    pub const fn as_str(self) -> &'static str; @ types/src/lib.rs:178
    pub const fn new(value: &'static str) -> Self; @ types/src/lib.rs:172
}

impl TryFrom<NonEmptyStaticStr> for NonEmptyStaticStr {
    fn try_from(value: NonEmptyStaticStr) -> Result<Self, Self::Error>;
}

/// This type enforces the invariant that the contained string is never empty
/// (or whitespace-only) after trimming. Validation occurs at construction time,
/// so all operations on an existing `NonEmptyStri...
pub struct NonEmptyString { @ types/src/lib.rs:86
}

impl NonEmptyString {
    pub fn append<impl AsRef<str>: AsRef<str>>(self, suffix: impl AsRef<str>) -> Self; @ types/src/lib.rs:114
    pub fn as_str(&self) -> &str; @ types/src/lib.rs:120
    pub fn into_inner(self) -> String; @ types/src/lib.rs:125
    pub fn new<impl Into<String>: Into<String>>(value: impl Into<String>) -> Result<Self, EmptyStringError>; @ types/src/lib.rs:93
    /// The `content` argument already satisfies the trim invariant...
    pub fn prefixed(prefix: NonEmptyStaticStr, separator: &str, content: &NonEmptyString) -> Self; @ types/src/lib.rs:104
}

impl TryFrom<String> for NonEmptyString {
    fn try_from(value: String) -> Result<Self, Self::Error>;
}

impl TryFrom<&str> for NonEmptyString {
    fn try_from(value: &str) -> Result<Self, Self::Error>;
}

impl From<NonEmptyString> for NonEmptyString {
    fn from(value: NonEmptyString) -> Self;
}

impl Deref for NonEmptyString {
    fn deref(&self) -> &Self::Target;
}

impl AsRef<str> for NonEmptyString {
    fn as_ref(&self) -> &str;
}

impl TryFrom<NonEmptyStaticStr> for NonEmptyString {
    fn try_from(value: NonEmptyStaticStr) -> Result<Self, Self::Error>;
}

/// An OpenAI reasoning output item captured for stateless replay.
pub struct OpenAIReasoningItem { @ types/src/lib.rs:1255
    pub id: String,
    pub encrypted_content: Option<String>,
}

pub struct OpenAIRequestOptions { @ types/src/lib.rs:986
}

impl OpenAIRequestOptions {
    pub fn new(reasoning_effort: OpenAIReasoningEffort, reasoning_summary: OpenAIReasoningSummary, verbosity: OpenAITextVerbosity, truncation: OpenAITruncation) -> Self; @ types/src/lib.rs:995
    pub fn reasoning_effort(self) -> OpenAIReasoningEffort; @ types/src/lib.rs:1010
    pub fn reasoning_summary(self) -> OpenAIReasoningSummary; @ types/src/lib.rs:1015
    pub fn truncation(self) -> OpenAITruncation; @ types/src/lib.rs:1025
    pub fn verbosity(self) -> OpenAITextVerbosity; @ types/src/lib.rs:1020
}

impl Default for OpenAIRequestOptions {
    fn default() -> Self;
}

/// This type enforces the invariant that standalone `\r` characters are
/// normalized to `\n`. The normalization occurs at construction time
/// (single Authority Boundary per IFA-7).
pub struct PersistableContent { @ types/src/lib.rs:220
}

impl PersistableContent {
    pub fn as_str(&self) -> &str; @ types/src/lib.rs:266
    pub fn into_inner(self) -> String; @ types/src/lib.rs:271
    pub fn is_empty(&self) -> bool; @ types/src/lib.rs:276
    pub fn len(&self) -> usize; @ types/src/lib.rs:281
    /// Create persistable content by normalizing line endings.
    pub fn new<impl Into<String>: Into<String>>(input: impl Into<String>) -> Self; @ types/src/lib.rs:228
}

impl AsRef<str> for PersistableContent {
    fn as_ref(&self) -> &str;
}

impl From<PersistableContent> for PersistableContent {
    fn from(value: PersistableContent) -> Self;
}

impl Deref for PersistableContent {
    fn deref(&self) -> &Self::Target;
}

impl Display for PersistableContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

/// Opaque wrapper for secret strings that prevents accidental disclosure.
pub struct SecretString { @ types/src/lib.rs:730
}

impl SecretString {
    /// Deliberately named accessor that makes secret exposure auditable.
    pub fn expose_secret(&self) -> &str; @ types/src/lib.rs:740
    pub fn new(value: String) -> Self; @ types/src/lib.rs:734
}

impl Debug for SecretString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

pub struct SystemMessage { @ types/src/lib.rs:1550
}

impl SystemMessage {
    pub fn content(&self) -> &str; @ types/src/lib.rs:1565
    pub fn new(content: NonEmptyString) -> Self; @ types/src/lib.rs:1557
}

/// Validated thinking budget for extended reasoning.
pub struct ThinkingBudget { @ types/src/lib.rs:1108
}

impl ThinkingBudget {
    pub const fn as_u32(self) -> u32; @ types/src/lib.rs:1121
    pub fn new(value: u32) -> Result<Self, OutputLimitsError>; @ types/src/lib.rs:1113
}

/// Provider reasoning/thinking content (Claude extended thinking, Gemini thinking, etc.).
pub struct ThinkingMessage { @ types/src/lib.rs:1631
}

impl ThinkingMessage {
    pub fn claude_signature(&self) -> Option<&ThoughtSignature>; @ types/src/lib.rs:1694
    pub fn content(&self) -> &str; @ types/src/lib.rs:1679
    pub fn model(&self) -> &ModelName; @ types/src/lib.rs:1707
    pub fn new(model: ModelName, content: NonEmptyString) -> Self; @ types/src/lib.rs:1643
    pub fn provider(&self) -> Provider; @ types/src/lib.rs:1702
    pub fn replay_state(&self) -> &ThinkingReplayState; @ types/src/lib.rs:1684
    pub fn requires_persistence(&self) -> bool; @ types/src/lib.rs:1689
    pub fn with_openai_reasoning(model: ModelName, content: NonEmptyString, items: Vec<OpenAIReasoningItem>) -> Self; @ types/src/lib.rs:1665
    pub fn with_signature(model: ModelName, content: NonEmptyString, signature: String) -> Self; @ types/src/lib.rs:1653
}

/// Opaque provider signature for thinking/tool-call replay.
pub struct ThoughtSignature { @ types/src/lib.rs:1209
}

impl ThoughtSignature {
    pub fn as_str(&self) -> &str; @ types/src/lib.rs:1218
    pub fn new<impl Into<String>: Into<String>>(raw: impl Into<String>) -> Self; @ types/src/lib.rs:1213
    pub fn push_str(&mut self, delta: &str); @ types/src/lib.rs:1222
}

impl From<String> for ThoughtSignature {
    fn from(value: String) -> Self;
}

impl From<&str> for ThoughtSignature {
    fn from(value: &str) -> Self;
}

pub struct ToolCall { @ types/src/lib.rs:1464
    /// Unique identifier for this tool call (used to match results).
    pub id: String,
    /// The name of the tool being called.
    pub name: String,
    /// The arguments to pass to the tool, as parsed JSON.
    pub arguments: serde_json::Value,
    /// Thought signature state for providers that require it (Gemini).
    pub thought_signature: ThoughtSignatureState,
}

impl ToolCall {
    pub fn new<impl Into<String>: Into<String>, impl Into<String>: Into<String>>(id: impl Into<String>, name: impl Into<String>, arguments: serde_json::Value) -> Self; @ types/src/lib.rs:1476
    pub fn new_signed<impl Into<String>: Into<String>, impl Into<String>: Into<String>>(id: impl Into<String>, name: impl Into<String>, arguments: serde_json::Value, thought_signature: ThoughtSignature) -> Self; @ types/src/lib.rs:1489
    pub const fn signature_state(&self) -> &ThoughtSignatureState; @ types/src/lib.rs:1504
}

pub struct ToolDefinition { @ types/src/lib.rs:1431
    /// The name of the tool (function name).
    pub name: String,
    /// A description of what the tool does.
    pub description: String,
    /// JSON Schema describing the tool's parameters.
    pub parameters: serde_json::Value,
    /// Whether this tool is hidden from UI rendering.
    /// Hidden tools execute normally but are invisible to the user.
    pub hidden: bool,
    /// If set, this tool is only included in the tool manifest for the specified provider.
    pub provider: Option<Provider>,
}

impl ToolDefinition {
    pub fn new<impl Into<String>: Into<String>, impl Into<String>: Into<String>>(name: impl Into<String>, description: impl Into<String>, parameters: serde_json::Value) -> Self; @ types/src/lib.rs:1448
}

pub struct ToolResult { @ types/src/lib.rs:1510
    /// The ID of the tool call this result is for.
    pub tool_call_id: String,
    /// The name of the tool that was called (needed for Gemini's functionResponse).
    pub tool_name: String,
    /// The result content (typically a string or JSON).
    pub content: String,
    /// Whether the tool execution resulted in an error.
    pub is_error: bool,
}

impl ToolResult {
    pub fn error<impl Into<String>: Into<String>, impl Into<String>: Into<String>, impl Into<String>: Into<String>>(tool_call_id: impl Into<String>, tool_name: impl Into<String>, error: impl Into<String>) -> Self; @ types/src/lib.rs:1535
    pub fn success<impl Into<String>: Into<String>, impl Into<String>: Into<String>, impl Into<String>: Into<String>>(tool_call_id: impl Into<String>, tool_name: impl Into<String>, content: impl Into<String>) -> Self; @ types/src/lib.rs:1522
}

pub struct UserMessage { @ types/src/lib.rs:1571
}

impl UserMessage {
    pub fn content(&self) -> &str; @ types/src/lib.rs:1586
    pub fn new(content: NonEmptyString) -> Self; @ types/src/lib.rs:1578
}

/// API key with provider tagging. Inner values are opaque [`SecretString`]s
/// to prevent credential disclosure in logs or error messages.
pub enum ApiKey { @ types/src/lib.rs:757
    Claude(SecretString),
    OpenAI(SecretString),
    Gemini(SecretString),
}

impl ApiKey {
    /// Construct a Claude API key.
    pub fn claude<impl Into<String>: Into<String>>(key: impl Into<String>) -> Self; @ types/src/lib.rs:776
    /// Access the raw key value. Named to make exposure auditable.
    pub fn expose_secret(&self) -> &str; @ types/src/lib.rs:803
    /// Construct a Gemini API key.
    pub fn gemini<impl Into<String>: Into<String>>(key: impl Into<String>) -> Self; @ types/src/lib.rs:788
    /// Construct an OpenAI API key.
    pub fn openai<impl Into<String>: Into<String>>(key: impl Into<String>) -> Self; @ types/src/lib.rs:782
    pub fn provider(&self) -> Provider; @ types/src/lib.rs:793
}

impl Debug for ApiKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

/// Hint for whether content should be cached by the provider.
pub enum CacheHint { @ types/src/lib.rs:1047
    /// No caching preference - provider uses default behavior.
    Default,
    /// Content is stable and should be cached if supported.
    Ephemeral,
}

pub enum EnumKind { @ types/src/lib.rs:331
    Provider,
    PredefinedModel,
    OpenAIReasoningEffort,
    OpenAIReasoningSummary,
    OpenAITextVerbosity,
    OpenAITruncation,
}

impl EnumKind {
    pub const fn as_str(self) -> &'static str; @ types/src/lib.rs:342
}

impl Display for EnumKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

/// A complete message.
pub enum Message { @ types/src/lib.rs:1716
    System(SystemMessage),
    User(UserMessage),
    Assistant(AssistantMessage),
    /// Provider reasoning/thinking content.
    Thinking(ThinkingMessage),
    /// A tool call requested by the assistant.
    ToolUse(ToolCall),
    /// The result of a tool call execution.
    ToolResult(ToolResult),
}

impl Message {
    pub fn assistant(model: ModelName, content: NonEmptyString) -> Self; @ types/src/lib.rs:1744
    pub fn content(&self) -> &str; @ types/src/lib.rs:1794
    pub fn role_str(&self) -> &'static str; @ types/src/lib.rs:1784
    pub fn system(content: NonEmptyString) -> Self; @ types/src/lib.rs:1730
    pub fn thinking(model: ModelName, content: NonEmptyString) -> Self; @ types/src/lib.rs:1749
    pub fn thinking_with_openai_reasoning(model: ModelName, content: NonEmptyString, items: Vec<OpenAIReasoningItem>) -> Self; @ types/src/lib.rs:1763
    pub fn thinking_with_signature(model: ModelName, content: NonEmptyString, signature: String) -> Self; @ types/src/lib.rs:1754
    pub fn tool_result(result: ToolResult) -> Self; @ types/src/lib.rs:1779
    pub fn tool_use(call: ToolCall) -> Self; @ types/src/lib.rs:1774
    pub fn try_user<impl Into<String>: Into<String>>(content: impl Into<String>) -> Result<Self, EmptyStringError>; @ types/src/lib.rs:1739
    pub fn user(content: NonEmptyString) -> Self; @ types/src/lib.rs:1735
}

pub enum ModelParseError { @ types/src/lib.rs:627
    Empty,
    ClaudePrefix(String),
    OpenAIMinimum(String),
    GeminiPrefix(String),
    UnknownModel(String),
}

pub enum OpenAIReasoningEffort { @ types/src/lib.rs:820
    Disabled,
    Low,
    Medium,
    High,
    XHigh,
}

impl OpenAIReasoningEffort {
    pub const fn as_str(self) -> &'static str; @ types/src/lib.rs:854
    pub fn parse(value: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:830
}

pub enum OpenAIReasoningSummary { @ types/src/lib.rs:866
    Disabled,
    Auto,
    Concise,
    Detailed,
}

impl OpenAIReasoningSummary {
    pub const fn as_str(self) -> &'static str; @ types/src/lib.rs:898
    pub fn parse(value: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:875
}

pub enum OpenAITextVerbosity { @ types/src/lib.rs:909
    Low,
    Medium,
    High,
}

impl OpenAITextVerbosity {
    pub const fn as_str(self) -> &'static str; @ types/src/lib.rs:939
    pub fn parse(value: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:917
}

pub enum OpenAITruncation { @ types/src/lib.rs:949
    Auto,
    Disabled,
}

impl OpenAITruncation {
    pub const fn as_str(self) -> &'static str; @ types/src/lib.rs:977
    pub fn parse(value: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:956
}

/// Validated output configuration that guarantees invariants.
pub enum OutputLimits { @ types/src/lib.rs:1144
    Standard {
        max_output_tokens: u32,
    },
    WithThinking {
        max_output_tokens: u32,
        thinking_budget: ThinkingBudget,
    },
}

impl OutputLimits {
    pub const fn has_thinking(&self) -> bool; @ types/src/lib.rs:1202
    pub const fn max_output_tokens(&self) -> u32; @ types/src/lib.rs:1182
    /// Create output limits without thinking.
    pub const fn new(max_output_tokens: u32) -> Self; @ types/src/lib.rs:1157
    pub const fn thinking(&self) -> ThinkingState; @ types/src/lib.rs:1192
    /// Create output limits with thinking enabled.
    pub fn with_thinking(max_output_tokens: u32, thinking_budget: u32) -> Result<Self, OutputLimitsError>; @ types/src/lib.rs:1164
}

/// Error when trying to construct invalid output limits.
pub enum OutputLimitsError { @ types/src/lib.rs:1099
    ThinkingBudgetTooLarge {
        budget: u32,
        max_output: u32,
    },
    ThinkingBudgetTooSmall,
}

pub enum PredefinedModel { @ types/src/lib.rs:481
    ClaudeOpus,
    ClaudeHaiku,
    Gpt52Pro,
    Gpt52,
    GeminiPro,
    GeminiFlash,
}

impl PredefinedModel {
    pub const fn all() -> &'static [PredefinedModel]; @ types/src/lib.rs:515
    pub const fn display_name(self) -> &'static str; @ types/src/lib.rs:527
    pub const fn firm_name(self) -> &'static str; @ types/src/lib.rs:551
    pub fn from_model_id(raw: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:585
    pub fn from_provider_and_id(provider: Provider, raw: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:601
    pub const fn model_id(self) -> &'static str; @ types/src/lib.rs:560
    pub const fn model_name(self) -> &'static str; @ types/src/lib.rs:539
    pub const fn provider(self) -> Provider; @ types/src/lib.rs:572
    pub fn to_model_name(self) -> ModelName; @ types/src/lib.rs:581
}

pub enum Provider { @ types/src/lib.rs:313
    Claude,
    OpenAI,
    Gemini,
}

impl Provider {
    /// Get all available providers.
    pub fn all() -> &'static [Provider]; @ types/src/lib.rs:475
    pub fn as_str(&self) -> &'static str; @ types/src/lib.rs:396
    /// All available models for this provider.
    pub fn available_models(&self) -> Vec<PredefinedModel>; @ types/src/lib.rs:433
    pub fn default_model(&self) -> ModelName; @ types/src/lib.rs:423
    pub fn display_name(&self) -> &'static str; @ types/src/lib.rs:405
    pub fn env_var(&self) -> &'static str; @ types/src/lib.rs:414
    /// Infer provider from model name prefix.
    pub fn from_model_name(model: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:469
    /// Parse provider from string.
    pub fn parse(s: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:447
    /// Parse a model name for this provider.
    pub fn parse_model(&self, raw: &str) -> Result<ModelName, ModelParseError>; @ types/src/lib.rs:442
}

pub enum StreamEvent { @ types/src/lib.rs:1342
    /// Text content delta.
    TextDelta(String),
    /// Provider reasoning content delta (Claude extended thinking or OpenAI reasoning summaries).
    ThinkingDelta(String),
    /// Encrypted thinking signature for API replay (Claude extended thinking).
    ThinkingSignature(String),
    /// Completed OpenAI reasoning output item for stateless replay.
    OpenAIReasoningDone {
        id: String,
        encrypted_content: Option<String>,
    },
    /// Tool call started - emitted when a `tool_use` content block begins.
    ToolCallStart {
        id: String,
        name: String,
        thought_signature: ThoughtSignatureState,
    },
    /// Tool call arguments delta - emitted as JSON arguments stream in.
    ToolCallDelta {
        id: String,
        arguments: String,
    },
    /// API-reported token usage (from `message_start` or `message_delta` events).
    Usage(ApiUsage),
    /// Stream completed.
    Done,
    /// Error occurred.
    Error(String),
}

/// Reason a stream finished.
pub enum StreamFinishReason { @ types/src/lib.rs:1372
    Done,
    Error(String),
}

/// Provider-specific replay state for thinking blocks.
pub enum ThinkingReplayState { @ types/src/lib.rs:1267
    Unsigned,
    ClaudeSigned {
        signature: ThoughtSignature,
    },
    OpenAIReasoning {
        items: Vec<OpenAIReasoningItem>,
    },
}

impl ThinkingReplayState {
    pub fn requires_persistence(&self) -> bool; @ types/src/lib.rs:1281
}

impl Deserialize<'de> for ThinkingReplayState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where D: serde::Deserializer<'de>;
}

pub enum ThinkingState { @ types/src/lib.rs:1127
    Disabled,
    Enabled(ThinkingBudget),
}

impl ThinkingState {
    pub const fn is_enabled(self) -> bool; @ types/src/lib.rs:1134
}

pub enum ThoughtSignatureState { @ types/src/lib.rs:1241
    Unsigned,
    Signed(ThoughtSignature),
}

impl ThoughtSignatureState {
    pub const fn is_signed(&self) -> bool; @ types/src/lib.rs:1248
}
```

## forge-providers

```rust
/// Add retry-related headers to a request.
pub fn add_retry_headers(builder: reqwest::RequestBuilder, retry_count: u32, idempotency_key: &str, timeout: Option<std::time::Duration>) -> reqwest::RequestBuilder; @ providers/src/retry.rs:140

/// Calculate retry delay with exponential backoff and jitter.
pub fn calculate_retry_delay(backoff_step: u32, config: &RetryConfig, headers: Option<&reqwest::header::HeaderMap>) -> std::time::Duration; @ providers/src/retry.rs:114

/// Create a cached content object with the system prompt and tools.
pub async fn create_cache(api_key: &str, model: &str, system_prompt: &str, tools: Option<&[forge_types::ToolDefinition]>, ttl_seconds: u32) -> anyhow::Result<GeminiCache>; @ providers/src/gemini.rs:102

pub fn generate_idempotency_key() -> String; @ providers/src/retry.rs:158

pub fn http_client() -> &'static reqwest::Client; @ providers/src/lib.rs:81

pub fn http_client_with_timeout(timeout_secs: u64) -> anyhow::Result<reqwest::Client, reqwest::Error>; @ providers/src/lib.rs:123

/// Parse `Retry-After` or `Retry-After-Ms` headers.
pub fn parse_retry_after(headers: &reqwest::header::HeaderMap) -> Option<std::time::Duration>; @ providers/src/retry.rs:59

pub async fn read_capped_error_body(response: reqwest::Response) -> String; @ providers/src/lib.rs:324

pub async fn send_message(config: &ApiConfig, messages: &[forge_types::CacheableMessage], limits: forge_types::OutputLimits, system_prompt: Option<&str>, tools: Option<&[forge_types::ToolDefinition]>, system_cache_hint: forge_types::CacheHint, cache_last_tool: bool, gemini_cache: Option<&gemini::GeminiCache>, tx: mpsc::Sender<forge_types::StreamEvent>) -> anyhow::Result<()>; @ providers/src/lib.rs:494

pub async fn send_message(config: &crate::ApiConfig, messages: &[forge_types::CacheableMessage], limits: forge_types::OutputLimits, system_prompt: Option<&str>, tools: Option<&[forge_types::ToolDefinition]>, system_cache_hint: forge_types::CacheHint, cache_last_tool: bool, tx: mpsc::Sender<forge_types::StreamEvent>) -> anyhow::Result<()>; @ providers/src/claude.rs:406

pub async fn send_message(config: &crate::ApiConfig, messages: &[forge_types::CacheableMessage], limits: forge_types::OutputLimits, system_prompt: Option<&str>, tools: Option<&[forge_types::ToolDefinition]>, cache: Option<&GeminiCache>, tx: mpsc::Sender<forge_types::StreamEvent>) -> anyhow::Result<()>; @ providers/src/gemini.rs:514

pub async fn send_message(config: &crate::ApiConfig, messages: &[forge_types::CacheableMessage], limits: forge_types::OutputLimits, system_prompt: Option<&str>, tools: Option<&[forge_types::ToolDefinition]>, tx: mpsc::Sender<forge_types::StreamEvent>) -> anyhow::Result<()>; @ providers/src/openai.rs:553

/// Send a request with automatic retries.
pub async fn send_with_retry<F>(build_request: F, timeout: Option<std::time::Duration>, config: &RetryConfig) -> RetryOutcome
    where F: Fn() -> reqwest::RequestBuilder; @ providers/src/retry.rs:226

/// Determine if a response status is retryable.
pub fn should_retry(status: reqwest::StatusCode, headers: &reqwest::header::HeaderMap) -> bool; @ providers/src/retry.rs:89

/// Provider + model configuration with provider-specific tuning knobs.
pub struct ApiConfig { @ providers/src/lib.rs:397
}

impl ApiConfig {
    pub const fn anthropic_thinking_effort(&self) -> &str; @ providers/src/lib.rs:488
    pub const fn anthropic_thinking_mode(&self) -> &str; @ providers/src/lib.rs:483
    pub fn api_key(&self) -> &str; @ providers/src/lib.rs:458
    pub fn api_key_owned(&self) -> ApiKey; @ providers/src/lib.rs:463
    pub const fn gemini_thinking_enabled(&self) -> bool; @ providers/src/lib.rs:478
    pub fn model(&self) -> &ModelName; @ providers/src/lib.rs:468
    pub fn new(api_key: ApiKey, model: ModelName) -> Result<Self, ApiConfigError>; @ providers/src/lib.rs:413
    pub fn openai_options(&self) -> OpenAIRequestOptions; @ providers/src/lib.rs:473
    pub fn provider(&self) -> Provider; @ providers/src/lib.rs:453
    pub fn with_anthropic_thinking(self, mode: &'static str, effort: &'static str) -> Self; @ providers/src/lib.rs:446
    pub fn with_gemini_thinking_enabled(self, enabled: bool) -> Self; @ providers/src/lib.rs:440
    pub fn with_openai_options(self, options: OpenAIRequestOptions) -> Self; @ providers/src/lib.rs:434
}

/// Active Gemini cache reference.
pub struct GeminiCache { @ providers/src/gemini.rs:25
    /// Cache name returned by API (e.g., "cachedContents/abc123")
    pub name: String,
    /// When this cache expires (UTC)
    pub expire_time: chrono::DateTime<chrono::Utc>,
    /// Hash of cached system prompt (for detecting changes)
    pub system_prompt_hash: u64,
    /// Hash of cached tool definitions (for detecting changes)
    pub tools_hash: u64,
}

impl GeminiCache {
    /// Check if this cache has expired.
    pub fn is_expired(&self) -> bool; @ providers/src/gemini.rs:39
    /// Check if this cache matches the given system prompt and tools.
    pub fn matches_config(&self, prompt: &str, tools: Option<&[ToolDefinition]>) -> bool; @ providers/src/gemini.rs:45
}

/// Configuration for Gemini caching.
pub struct GeminiCacheConfig { @ providers/src/gemini.rs:52
    /// Whether caching is enabled
    pub enabled: bool,
    /// TTL in seconds for cached content (default: 3600 = 1 hour)
    pub ttl_seconds: u32,
}

/// Retry configuration matching official SDK defaults.
pub struct RetryConfig { @ providers/src/retry.rs:32
    /// Maximum number of retries (not counting initial request).
    pub max_retries: u32,
    /// Initial backoff delay before first retry.
    pub initial_delay: std::time::Duration,
    /// Maximum backoff delay.
    pub max_delay: std::time::Duration,
    /// Jitter factor for down-jitter (0.25 = up to 25% reduction).
    pub jitter_factor: f64,
}

impl Default for RetryConfig {
    fn default() -> Self;
}

pub enum ApiConfigError { @ providers/src/lib.rs:407
    ProviderMismatch {
        key: forge_types::Provider,
        model: forge_types::Provider,
    },
}

/// Outcome of a retry operation.
pub enum RetryOutcome { @ providers/src/retry.rs:167
    /// Request succeeded (2xx status).
    Success(reqwest::Response),
    /// Request failed with an HTTP error after exhausting retries.
    /// The response is provided for error body inspection.
    HttpError(reqwest::Response),
    /// Request failed with a connection/transport error after exhausting retries.
    ConnectionError {
        attempts: u32,
        source: reqwest::Error,
    },
    /// Request failed with a non-retryable connection error on first attempt.
    NonRetryable(reqwest::Error),
}

impl RetryOutcome {
    /// Returns the successful response, or an error description.
    pub fn into_response(self) -> Result<Response, String>; @ providers/src/retry.rs:186
    /// Returns true if this is a successful response.
    pub const fn is_success(&self) -> bool; @ providers/src/retry.rs:199
}
```

## forge-context

```rust
pub fn atomic_write<impl AsRef<Path>: AsRef<std::path::Path>>(path: impl AsRef<std::path::Path>, bytes: &[u8]) -> std::io::Result<()>; @ context/src/atomic_write.rs:39

pub fn atomic_write_new_with_options<impl AsRef<Path>: AsRef<std::path::Path>>(path: impl AsRef<std::path::Path>, bytes: &[u8], options: AtomicWriteOptions) -> std::io::Result<()>; @ context/src/atomic_write.rs:44

pub fn atomic_write_with_options<impl AsRef<Path>: AsRef<std::path::Path>>(path: impl AsRef<std::path::Path>, bytes: &[u8], options: AtomicWriteOptions) -> std::io::Result<()>; @ context/src/atomic_write.rs:119

/// Get the distillation model name for a given provider.
pub fn distillation_model(provider: forge_types::Provider) -> &'static str; @ context/src/distillation.rs:481

/// Extract facts from a conversation exchange.
pub async fn extract_facts(api_key: &str, user_message: &str, assistant_message: &str) -> anyhow::Result<ExtractionResult>; @ context/src/librarian.rs:122

/// Format retrieved facts for injection into context.
pub fn format_facts_for_context(facts: &[Fact]) -> String; @ context/src/librarian.rs:259

/// Distill conversation messages into a compact Distillate using an LLM.
pub async fn generate_distillation(config: &forge_providers::ApiConfig, counter: &super::token_counter::TokenCounter, messages: &[(super::MessageId, forge_types::Message)], target_tokens: u32) -> anyhow::Result<String>; @ context/src/distillation.rs:182

/// Retrieve relevant facts for a user query.
pub async fn retrieve_relevant(api_key: &str, user_query: &str, available_facts: &[Fact]) -> anyhow::Result<RetrievalResult>; @ context/src/librarian.rs:158

/// Active streaming journal.
pub struct ActiveJournal { @ context/src/stream_journal.rs:239
}

impl ActiveJournal {
    /// Append a Done event (terminal - flushes buffer first).
    pub fn append_done(&mut self, journal: &mut StreamJournal) -> Result<()>; @ context/src/stream_journal.rs:320
    /// Append an Error event (terminal - flushes buffer first).
    pub fn append_error<impl Into<String>: Into<String>>(&mut self, journal: &mut StreamJournal, message: impl Into<String>) -> Result<()>; @ context/src/stream_journal.rs:326
    /// Buffer a text delta for later persistence.
    pub fn append_text<impl Into<String>: Into<String>>(&mut self, journal: &mut StreamJournal, content: impl Into<String>) -> Result<()>; @ context/src/stream_journal.rs:273
    pub fn discard(self, journal: &mut StreamJournal) -> Result<u64>; @ context/src/stream_journal.rs:340
    /// Flush buffered deltas to the database.
    pub fn flush(&mut self, journal: &mut StreamJournal) -> Result<()>; @ context/src/stream_journal.rs:307
    /// Get the model name associated with this streaming session.
    pub fn model_name(&self) -> &str; @ context/src/stream_journal.rs:262
    pub fn seal(self, journal: &mut StreamJournal) -> Result<String>; @ context/src/stream_journal.rs:335
    pub fn step_id(&self) -> StepId; @ context/src/stream_journal.rs:256
}

pub struct AtomicWriteOptions { @ context/src/atomic_write.rs:13
    /// When true, `sync_all()` is called on the temp file before persisting.
    pub sync_all: bool,
    /// When true, best-effort `sync_all()` is called on the parent directory after
    /// the file has been persisted (renamed).
    pub dir_sync: bool,
    /// When set (Unix only), apply this mode to the temp file before writing and to
    /// the final file after persist (e.g. `0o600`).
    pub unix_mode: Option<u32>,
}

impl Default for AtomicWriteOptions {
    fn default() -> Self;
}

pub struct ContextManager { @ context/src/manager.rs:185
}

impl ContextManager {
    pub fn complete_distillation(&mut self, scope: DistillationScope, content: NonEmptyString, generated_by: String) -> Result<DistillateId>; @ context/src/manager.rs:585
    pub fn current_limits(&self) -> ModelLimits; @ context/src/manager.rs:705
    pub fn current_limits_source(&self) -> ModelLimitsSource; @ context/src/manager.rs:710
    pub fn current_model(&self) -> &ModelName; @ context/src/manager.rs:700
    /// if history already contains an entry with this `step_id`, we should not recover it again.
    pub fn has_step_id(&self, step_id: StepId) -> bool; @ context/src/manager.rs:249
    pub fn history(&self) -> &FullHistory; @ context/src/manager.rs:695
    /// Load history from a JSON file.
    pub fn load<impl AsRef<Path>: AsRef<Path>>(path: impl AsRef<Path>, model: ModelName) -> Result<Self>; @ context/src/manager.rs:737
    pub fn new(initial_model: ModelName) -> Self; @ context/src/manager.rs:199
    pub fn prepare(&self, overhead: u32) -> Result<PreparedContext<'_>, ContextBuildError>; @ context/src/manager.rs:634
    pub fn prepare_distillation(&mut self, needed: &DistillationNeeded) -> std::result::Result<PendingDistillation, DistillationPlanError>; @ context/src/manager.rs:508
    /// Get the configured preserve_recent count.
    pub fn preserve_recent_count(&self) -> usize; @ context/src/manager.rs:661
    pub fn push_message(&mut self, message: Message) -> MessageId; @ context/src/manager.rs:232
    pub fn push_message_with_step_id(&mut self, message: Message, stream_step_id: StepId) -> MessageId; @ context/src/manager.rs:237
    /// Get only the N most recent messages, bypassing distillation.
    pub fn recent_messages_only(&self, count: usize) -> Vec<Message>; @ context/src/manager.rs:650
    /// This is used for transactional rollback when a stream fails...
    pub fn rollback_last_message(&mut self, id: MessageId) -> Option<Message>; @ context/src/manager.rs:254
    /// Save history to a JSON file.
    pub fn save<impl AsRef<Path>: AsRef<Path>>(&self, path: impl AsRef<Path>) -> Result<()>; @ context/src/manager.rs:721
    /// Update model limits without triggering distillation behavior.
    pub fn set_model_without_adaptation(&mut self, new_model: ModelName); @ context/src/manager.rs:286
    /// This allows more input context when users configure smaller output limits.
    pub fn set_output_limit(&mut self, limit: u32); @ context/src/manager.rs:218
    pub fn switch_model(&mut self, new_model: ModelName) -> ContextAdaptation; @ context/src/manager.rs:258
    /// This does not mutate history. If the current model's budget can fit original messages...
    pub fn try_restore_messages(&self) -> usize; @ context/src/manager.rs:617
    /// Get current usage statistics with explicit distillation status.
    pub fn usage_status(&self) -> ContextUsageStatus; @ context/src/manager.rs:667
}

/// Usage statistics for display in UI.
pub struct ContextUsage { @ context/src/working_context.rs:172
    /// Tokens currently used in working context.
    pub used_tokens: u32,
    /// Token budget for current model.
    pub budget_tokens: u32,
    /// Count of distillates in context.
    pub distilled_segments: usize,
}

impl ContextUsage {
    /// Format for status bar: "2.1k / 200k (1%)"
    pub fn format_compact(&self) -> String; @ context/src/working_context.rs:202
    pub fn from_context(ctx: &WorkingContext) -> Self; @ context/src/working_context.rs:183
    pub fn percentage(&self) -> f32; @ context/src/working_context.rs:192
    pub fn severity(&self) -> u8; @ context/src/working_context.rs:234
}

/// Information about corrupted tool call arguments during recovery.
pub struct CorruptedToolArgs { @ context/src/tool_journal.rs:62
    pub tool_call_id: String,
    pub raw_json: String,
    pub parse_error: String,
}

pub struct Distillate { @ context/src/history.rs:275
}

impl Distillate {
    pub fn content(&self) -> &str; @ context/src/history.rs:307
    pub fn content_non_empty(&self) -> &NonEmptyString; @ context/src/history.rs:312
    pub fn new(id: DistillateId, covers: Range<MessageId>, content: NonEmptyString, token_count: u32, original_tokens: u32, generated_by: String) -> Self; @ context/src/history.rs:287
    pub fn token_count(&self) -> u32; @ context/src/history.rs:317
}

pub struct DistillateId { @ context/src/history.rs:38
}

pub struct DistillationNeeded { @ context/src/manager.rs:56
    pub tokens_to_distill: u32,
    pub available_tokens: u32,
    pub excess_tokens: u32,
    pub messages_to_distill: Vec<super::history::MessageId>,
    pub suggestion: String,
}

/// Contiguous range of message IDs selected for distillation.
pub struct DistillationScope { @ context/src/manager.rs:95
}

/// Result of fact extraction from a conversation exchange.
pub struct ExtractionResult { @ context/src/librarian.rs:72
    /// Extracted facts.
    pub facts: Vec<Fact>,
}

/// A distilled fact extracted from conversation.
pub struct Fact { @ context/src/librarian.rs:61
    /// The type of fact.
    pub fact_type: FactType,
    /// The fact content.
    pub content: String,
    /// Searchable entities/keywords mentioned in this fact.
    pub entities: Vec<String>,
}

/// Persistent store for Librarian-extracted facts.
pub struct FactStore { @ context/src/fact_store.rs:59
}

impl FactStore {
    /// Add a pinned fact (user-explicitly marked as important).
    pub fn add_pinned_fact(&mut self, content: &str, entities: &[String], turn_number: u64) -> Result<FactId>; @ context/src/fact_store.rs:344
    /// Check staleness for a list of facts.
    pub fn check_staleness(&self, facts: &[StoredFact]) -> Result<Vec<FactWithStaleness>>; @ context/src/fact_store.rs:479
    /// Delete all facts (for testing/reset).
    pub fn clear(&mut self) -> Result<()>; @ context/src/fact_store.rs:336
    pub fn fact_count(&self) -> usize; @ context/src/fact_store.rs:315
    /// Get all stored facts.
    pub fn get_all_facts(&self) -> Result<Vec<StoredFact>>; @ context/src/fact_store.rs:190
    /// Get source files for a specific fact.
    pub fn get_sources_for_fact(&self, fact_id: FactId) -> Result<Vec<FactSource>>; @ context/src/fact_store.rs:449
    /// Link facts to their source files.
    pub fn link_facts_to_sources(&mut self, fact_ids: &[FactId], source_paths: &[String]) -> Result<()>; @ context/src/fact_store.rs:399
    /// Query the highest turn number stored in the facts table.
    /// Returns 0 if no facts exist.
    pub fn max_turn_number(&self) -> Result<u64>; @ context/src/fact_store.rs:323
    /// Open or create fact store database at the given path.
    pub fn open<impl AsRef<Path>: AsRef<Path>>(path: impl AsRef<Path>) -> Result<Self>; @ context/src/fact_store.rs:111
    /// Open an in-memory fact store (for testing).
    pub fn open_in_memory() -> Result<Self>; @ context/src/fact_store.rs:130
    /// Search facts by entity keyword.
    pub fn search_by_entity(&self, keyword: &str) -> Result<Vec<StoredFact>>; @ context/src/fact_store.rs:259
    /// Search facts by entity and return with staleness info.
    pub fn search_with_staleness(&self, keyword: &str) -> Result<Vec<FactWithStaleness>>; @ context/src/fact_store.rs:509
    /// Store facts extracted from a conversation turn.
    pub fn store_facts(&mut self, facts: &[Fact], turn_number: u64) -> Result<Vec<FactId>>; @ context/src/fact_store.rs:146
    /// Record or update a source file's SHA256 hash.
    pub fn upsert_source(&mut self, file_path: &str, sha256: &str) -> Result<i64>; @ context/src/fact_store.rs:362
}

/// A fact with staleness information.
pub struct FactWithStaleness { @ context/src/fact_store.rs:44
    pub fact: StoredFact,
    /// Source files that have changed since the fact was extracted.
    pub stale_sources: Vec<String>,
}

impl FactWithStaleness {
    /// Returns true if any source files have changed.
    pub fn is_stale(&self) -> bool; @ context/src/fact_store.rs:53
}

pub struct FullHistory { @ context/src/history.rs:340
}

impl FullHistory {
    /// Under normal operation, distillates should only cover previously-undistilled...
    pub fn add_distillate(&mut self, distillate: Distillate) -> Result<DistillateId>; @ context/src/history.rs:520
    pub fn distillate(&self, id: DistillateId) -> &Distillate; @ context/src/history.rs:607
    pub fn distillates_len(&self) -> usize; @ context/src/history.rs:591
    pub fn distilled_count(&self) -> usize; @ context/src/history.rs:645
    pub fn entries(&self) -> &[HistoryEntry]; @ context/src/history.rs:586
    pub fn get_entry(&self, id: MessageId) -> &HistoryEntry; @ context/src/history.rs:601
    pub fn has_step_id(&self, step_id: StepId) -> bool; @ context/src/history.rs:513
    pub fn is_empty(&self) -> bool; @ context/src/history.rs:622
    pub fn len(&self) -> usize; @ context/src/history.rs:617
    pub fn new() -> Self; @ context/src/history.rs:483
    pub fn next_distillate_id(&self) -> DistillateId; @ context/src/history.rs:596
    /// Find orphaned distillates (distillates with no messages referencing them).
    pub fn orphaned_distillates(&self) -> Vec<DistillateId>; @ context/src/history.rs:654
    /// This is used for transactional rollback when a stream fails...
    pub fn pop_if_last(&mut self, id: MessageId) -> Option<Message>; @ context/src/history.rs:627
    pub fn push(&mut self, message: Message, token_count: u32) -> MessageId; @ context/src/history.rs:487
    pub fn push_with_step_id(&mut self, message: Message, token_count: u32, stream_step_id: StepId) -> MessageId; @ context/src/history.rs:495
    /// Total tokens across all original messages.
    pub fn total_tokens(&self) -> u32; @ context/src/history.rs:612
}

impl Serialize for FullHistory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where S: serde::Serializer;
}

impl Deserialize<'de> for FullHistory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where D: serde::Deserializer<'de>;
}

pub struct JournalStats { @ context/src/stream_journal.rs:999
    /// Total number of entries
    pub total_entries: u64,
    /// Number of sealed entries
    pub sealed_entries: u64,
    /// Number of unsealed entries
    pub unsealed_entries: u64,
    /// Current (last allocated) step ID
    pub current_step_id: StepId,
}

/// The Librarian - manages fact extraction, storage, and retrieval.
pub struct Librarian { @ context/src/librarian.rs:288
}

impl Librarian {
    /// Get all stored facts (for debugging/inspection).
    pub fn all_facts(&self) -> Result<Vec<Fact>>; @ context/src/librarian.rs:415
    /// Get the API key for direct API calls.
    pub fn api_key(&self) -> &str; @ context/src/librarian.rs:330
    /// Clear all facts (for testing/reset).
    pub fn clear(&mut self) -> Result<()>; @ context/src/librarian.rs:438
    /// Post-turn: Extract and store facts from a conversation exchange.
    pub async fn extract_and_store(&mut self, user_message: &str, assistant_message: &str) -> Result<ExtractionResult>; @ context/src/librarian.rs:387
    pub fn fact_count(&self) -> usize; @ context/src/librarian.rs:321
    /// Increment the turn counter.
    pub fn increment_turn(&mut self); @ context/src/librarian.rs:337
    pub fn open<impl AsRef<Path>: AsRef<Path>>(path: impl AsRef<Path>, api_key: SecretString) -> Result<Self>; @ context/src/librarian.rs:295
    pub fn open_in_memory(api_key: SecretString) -> Result<Self>; @ context/src/librarian.rs:305
    /// Add a user-pinned fact.
    pub fn pin_fact(&mut self, content: &str, entities: &[String]) -> Result<()>; @ context/src/librarian.rs:408
    /// Pre-flight: Retrieve relevant facts for a user query.
    pub async fn retrieve_context(&self, user_query: &str) -> Result<RetrievalResult>; @ context/src/librarian.rs:374
    /// Search facts by keyword.
    pub fn search(&self, keyword: &str) -> Result<Vec<Fact>>; @ context/src/librarian.rs:421
    /// Search facts by keyword with staleness information.
    pub fn search_with_staleness(&self, keyword: &str) -> Result<Vec<super::fact_store::FactWithStaleness>>; @ context/src/librarian.rs:430
    /// Store extracted facts (sync operation).
    pub fn store_facts(&mut self, facts: &[Fact]) -> Result<()>; @ context/src/librarian.rs:344
    /// Store extracted facts and link them to source files.
    pub fn store_facts_with_sources(&mut self, facts: &[Fact], source_paths: &[String]) -> Result<()>; @ context/src/librarian.rs:355
    pub fn turn_counter(&self) -> u64; @ context/src/librarian.rs:316
}

impl Debug for Librarian {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

pub struct MessageId { @ context/src/history.rs:16
}

impl MessageId {
    pub fn as_u64(&self) -> u64; @ context/src/history.rs:33
}

/// The effective input budget accounts for output reservation and a safety margin.
pub struct ModelLimits { @ context/src/model_limits.rs:23
}

impl ModelLimits {
    pub const fn context_window(&self) -> u32; @ context/src/model_limits.rs:62
    /// This is the maximum number of tokens available for input messages,
    /// calculated as: `context_window - max_output - 5% safety margin`.
    pub fn effective_input_budget(&self) -> u32; @ context/src/model_limits.rs:47
    /// The reserved amount is clamped to the model's `max_output`.
    pub fn effective_input_budget_with_reserved(&self, reserved_output: u32) -> u32; @ context/src/model_limits.rs:53
    pub const fn max_output(&self) -> u32; @ context/src/model_limits.rs:67
    pub const fn new(context_window: u32, max_output: u32) -> Self; @ context/src/model_limits.rs:30
}

/// 1. First, check custom overrides set via `set_override` (test-only)
/// 2. If no override exists, use the canonical model catalog
pub struct ModelRegistry { @ context/src/model_limits.rs:131
}

impl ModelRegistry {
    pub fn get(&self, model: &ModelName) -> ResolvedModelLimits; @ context/src/model_limits.rs:145
    pub fn new() -> Self; @ context/src/model_limits.rs:138
}

impl Default for ModelRegistry {
    fn default() -> Self;
}

/// Request for async distillation, created by [`ContextManager::prepare_distillation`].
pub struct PendingDistillation { @ context/src/manager.rs:124
    /// The scope defining which messages to distill.
    pub scope: DistillationScope,
    /// The actual messages to distill, in order.
    pub messages: Vec<(super::history::MessageId, forge_types::Message)>,
    /// Total tokens in the original messages.
    pub original_tokens: u32,
    /// Target token count for the generated distillation.
    pub target_tokens: u32,
}

/// Proof that working context was successfully built within the token budget.
pub struct PreparedContext<'a> { @ context/src/manager.rs:141
}

impl PreparedContext<'a> {
    pub fn api_messages(&self) -> Vec<Message>; @ context/src/manager.rs:148
    pub fn usage(&self) -> ContextUsage; @ context/src/manager.rs:153
}

/// Recovered tool batch data after a crash.
pub struct RecoveredToolBatch { @ context/src/tool_journal.rs:70
    pub batch_id: ToolBatchId,
    pub stream_step_id: Option<crate::StepId>,
    pub model_name: String,
    pub assistant_text: String,
    pub calls: Vec<forge_types::ToolCall>,
    pub results: Vec<forge_types::ToolResult>,
    /// Tool calls whose arguments failed to parse (substituted with {})
    pub corrupted_args: Vec<CorruptedToolArgs>,
    /// Best-effort execution metadata keyed by tool_call_id.
    pub call_execution: std::collections::HashMap<String, RecoveredToolCallExecution>,
    /// Thinking replay state recovered from the journal.
    /// `Unsigned` when the column was NULL or unparseable (IFA ยง11.2: no optionality in core).
    pub thinking_replay: forge_types::ThinkingReplayState,
}

/// Per-tool-call execution metadata captured for crash recovery.
pub struct RecoveredToolCallExecution { @ context/src/tool_journal.rs:49
    /// When Forge began executing the tool call (Unix epoch milliseconds).
    pub started_at_unix_ms: Option<i64>,
    /// OS process id for subprocess-backed tools (e.g., `Run`) when available.
    pub process_id: Option<i64>,
    /// Process creation timestamp (Unix epoch milliseconds) when available.
    pub process_started_at_unix_ms: Option<i64>,
}

pub struct ResolvedModelLimits { @ context/src/model_limits.rs:79
}

impl ResolvedModelLimits {
    pub const fn limits(self) -> ModelLimits; @ context/src/model_limits.rs:91
    pub const fn new(limits: ModelLimits, source: ModelLimitsSource) -> Self; @ context/src/model_limits.rs:86
    pub const fn source(self) -> ModelLimitsSource; @ context/src/model_limits.rs:96
}

/// Result of relevance retrieval for a user query.
pub struct RetrievalResult { @ context/src/librarian.rs:79
    /// Facts deemed relevant to the query, ordered by relevance.
    pub relevant_facts: Vec<Fact>,
    /// Total token estimate for the retrieved facts.
    pub token_estimate: u32,
}

/// Unique identifier for a streaming step/session.
pub struct StepId { @ context/src/stream_journal.rs:47
}

impl StepId {
    pub const fn new(value: i64) -> Self; @ context/src/stream_journal.rs:51
    pub const fn value(self) -> i64; @ context/src/stream_journal.rs:56
}

impl Display for StepId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

impl From<i64> for StepId {
    fn from(value: i64) -> Self;
}

impl From<StepId> for StepId {
    fn from(value: StepId) -> Self;
}

impl ToSql for StepId {
    fn to_sql(&self) -> rusqlite::Result<ToSqlOutput<'_>>;
}

impl FromSql for StepId {
    fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self>;
}

/// A stored fact with its metadata.
pub struct StoredFact { @ context/src/fact_store.rs:26
    pub id: FactId,
    pub fact: super::librarian::Fact,
    pub turn_number: u64,
    pub created_at: String,
}

/// Stream journal for durable streaming with crash recovery
pub struct StreamJournal { @ context/src/stream_journal.rs:393
}

impl StreamJournal {
    /// Begin a new journal session for streaming.
    pub fn begin_session<impl Into<String>: Into<String>>(&mut self, model_name: impl Into<String>) -> std::result::Result<ActiveJournal, BeginSessionError>; @ context/src/stream_journal.rs:486
    /// Atomically commit and prune a step.
    pub fn commit_and_prune_step(&mut self, step_id: StepId) -> Result<u64>; @ context/src/stream_journal.rs:567
    /// Discard a step that was never committed (error/cancel path).
    pub fn discard_step(&mut self, step_id: StepId) -> Result<u64>; @ context/src/stream_journal.rs:605
    /// Delete all unsealed entries for a step (discard recovery data).
    pub fn discard_unsealed(&mut self, step_id: StepId) -> Result<u64>; @ context/src/stream_journal.rs:647
    /// Allocate the next step ID
    pub fn next_step_id(&mut self) -> Result<StepId>; @ context/src/stream_journal.rs:660
    /// Open or create journal database at the given path
    pub fn open<impl AsRef<Path>: AsRef<Path>>(path: impl AsRef<Path>) -> Result<Self>; @ context/src/stream_journal.rs:432
    /// Open an in-memory journal (for testing)
    pub fn open_in_memory() -> Result<Self>; @ context/src/stream_journal.rs:454
    /// Check for and recover incomplete streams after a crash
    pub fn recover(&self) -> Result<Option<RecoveredStream>>; @ context/src/stream_journal.rs:776
    /// Seal unsealed entries for a step (used for crash recovery).
    pub fn seal_unsealed(&mut self, step_id: StepId) -> Result<String>; @ context/src/stream_journal.rs:550
    /// Get statistics about the journal.
    pub fn stats(&self) -> Result<JournalStats>; @ context/src/stream_journal.rs:653
}

/// Thread-safe approximate token counter using tiktoken's `o200k_base` encoding.
pub struct TokenCounter { @ context/src/token_counter.rs:61
}

impl TokenCounter {
    /// Counts tokens for a single message, including role overhead.
    pub fn count_message(&self, msg: &Message) -> u32; @ context/src/token_counter.rs:125
    /// Counts the number of tokens in a string.
    pub fn count_str(&self, text: &str) -> u32; @ context/src/token_counter.rs:99
    /// Initializes a counter using the shared singleton encoder.
    pub fn new() -> Self; @ context/src/token_counter.rs:76
}

impl Debug for TokenCounter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

impl Default for TokenCounter {
    fn default() -> Self;
}

/// Tool journal for durable tool batch tracking.
pub struct ToolJournal { @ context/src/tool_journal.rs:90
}

impl ToolJournal {
    /// Append a text delta to the assistant text for a streaming batch.
    pub fn append_assistant_delta(&mut self, batch_id: ToolBatchId, delta: &str) -> Result<()>; @ context/src/tool_journal.rs:462
    /// Append streamed JSON arguments for a tool call.
    pub fn append_call_args(&mut self, batch_id: ToolBatchId, tool_call_id: &str, delta: &str) -> Result<()>; @ context/src/tool_journal.rs:293
    /// Append streamed JSON argument deltas for multiple tool calls in a single transaction.
    pub fn append_call_args_batch(&mut self, batch_id: ToolBatchId, deltas: Vec<(String, String)>) -> Result<()>; @ context/src/tool_journal.rs:319
    /// Begin a new tool batch and persist its tool calls.
    pub fn begin_batch(&mut self, stream_step_id: StepId, model_name: &str, assistant_text: &str, calls: &[ToolCall], thinking_replay: &ThinkingReplayState) -> Result<ToolBatchId>; @ context/src/tool_journal.rs:179
    /// Begin a new tool batch during streaming (before tool arguments are complete).
    pub fn begin_streaming_batch(&mut self, stream_step_id: StepId, model_name: &str) -> Result<ToolBatchId>; @ context/src/tool_journal.rs:240
    /// Commit and prune a completed batch.
    pub fn commit_batch(&mut self, batch_id: ToolBatchId) -> Result<()>; @ context/src/tool_journal.rs:559
    /// Discard an incomplete batch (used on cancel or user discard).
    pub fn discard_batch(&mut self, batch_id: ToolBatchId) -> Result<()>; @ context/src/tool_journal.rs:594
    /// Mark a tool call as started (durable "journal-before-execute" metadata).
    pub fn mark_call_started(&mut self, batch_id: ToolBatchId, tool_call_id: &str, started_at_unix_ms: i64) -> Result<()>; @ context/src/tool_journal.rs:356
    /// Open or create tool journal database at the given path.
    pub fn open<impl AsRef<Path>: AsRef<Path>>(path: impl AsRef<Path>) -> Result<Self>; @ context/src/tool_journal.rs:139
    /// Open an in-memory journal (for testing).
    pub fn open_in_memory() -> Result<Self>; @ context/src/tool_journal.rs:158
    /// Record subprocess metadata for a tool call (e.g., `Run` PID and creation time).
    pub fn record_call_process(&mut self, batch_id: ToolBatchId, tool_call_id: &str, process_id: i64, process_started_at_unix_ms: Option<i64>) -> Result<()>; @ context/src/tool_journal.rs:381
    /// Record the start of a tool call in a streaming batch.
    pub fn record_call_start(&mut self, batch_id: ToolBatchId, seq: usize, tool_call_id: &str, tool_name: &str, thought_signature: &ThoughtSignatureState) -> Result<()>; @ context/src/tool_journal.rs:270
    /// Record a tool result for a batch.
    pub fn record_result(&mut self, batch_id: ToolBatchId, result: &ToolResult) -> Result<()>; @ context/src/tool_journal.rs:502
    /// Recover the most recent incomplete tool batch, if any.
    pub fn recover(&self) -> Result<Option<RecoveredToolBatch>>; @ context/src/tool_journal.rs:623
    /// Update assistant text for a streaming batch (full replacement).
    pub fn update_assistant_text(&mut self, batch_id: ToolBatchId, assistant_text: &str) -> Result<()>; @ context/src/tool_journal.rs:440
    /// Store thinking replay state for a batch (typically after streaming completes).
    pub fn update_thinking_replay(&mut self, batch_id: ToolBatchId, replay: &ThinkingReplayState) -> Result<()>; @ context/src/tool_journal.rs:479
}

/// The working context: a plan for what to send to the API.
pub struct WorkingContext { @ context/src/working_context.rs:71
}

impl WorkingContext {
    pub fn distillate_count(&self) -> usize; @ context/src/working_context.rs:135
    /// Materialize into actual messages for API call.
    pub fn materialize(&self, history: &FullHistory) -> Vec<Message>; @ context/src/working_context.rs:144
    pub fn new(token_budget: u32) -> Self; @ context/src/working_context.rs:80
    /// Add a Distillate segment.
    pub fn push_distillate(&mut self, distillate_id: DistillateId, replaces: Vec<MessageId>, tokens: u32); @ context/src/working_context.rs:92
    pub fn push_original(&mut self, id: MessageId, tokens: u32); @ context/src/working_context.rs:87
    pub fn segments(&self) -> &[ContextSegment]; @ context/src/working_context.rs:103
    pub fn token_budget(&self) -> u32; @ context/src/working_context.rs:112
    pub fn total_tokens(&self) -> u32; @ context/src/working_context.rs:107
}

/// Typed error for `StreamJournal::begin_session`.
pub enum BeginSessionError { @ context/src/stream_journal.rs:96
    /// A previous stream is still active in this process.
    AlreadyStreaming(StepId),
    /// An unsealed or uncommitted step exists and must be recovered first.
    RecoverableStepExists(StepId),
    /// Database or I/O error during the begin operation.
    Db(anyhow::Error),
}

impl Display for BeginSessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

impl Error for BeginSessionError {
    fn source(&self) -> Option<&dyn std::error::Error + 'static>;
}

pub enum ContextAdaptation { @ context/src/manager.rs:101
    /// No change in effective budget.
    NoChange,
    /// Switched to a model with smaller context.
    Shrinking {
        old_budget: u32,
        new_budget: u32,
        needs_distillation: bool,
    },
    /// Switched to a model with larger context.
    Expanding {
        old_budget: u32,
        new_budget: u32,
        /// Number of messages that could potentially be restored.
        can_restore: usize,
    },
}

pub enum ContextBuildError { @ context/src/manager.rs:43
    /// Older messages need distillation to fit within budget.
    DistillationNeeded(DistillationNeeded),
    /// The most recent N messages alone exceed the budget.
    /// This is unrecoverable - user must reduce input or switch to larger model.
    RecentMessagesTooLarge {
        required_tokens: u32,
        budget_tokens: u32,
        message_count: usize,
    },
}

/// Represents a segment of the working context.
pub enum ContextSegment { @ context/src/working_context.rs:20
    Original {
        id: super::history::MessageId,
        tokens: u32,
    },
    Distilled {
        distillate_id: super::history::DistillateId,
        /// Original message IDs that this replaces.
        replaces: Vec<super::history::MessageId>,
        tokens: u32,
    },
}

impl ContextSegment {
    pub fn distilled(distillate_id: DistillateId, replaces: Vec<MessageId>, tokens: u32) -> Self; @ context/src/working_context.rs:40
    pub fn is_distilled(&self) -> bool; @ context/src/working_context.rs:55
    pub fn original(id: MessageId, tokens: u32) -> Self; @ context/src/working_context.rs:35
    pub fn tokens(&self) -> u32; @ context/src/working_context.rs:60
}

/// Current context usage state with explicit distillation status.
pub enum ContextUsageStatus { @ context/src/manager.rs:163
    /// Context fits within budget and is ready for use.
    Ready(super::working_context::ContextUsage),
    /// Context exceeds budget; distillation is needed before API call.
    NeedsDistillation {
        /// Current usage statistics.
        usage: super::working_context::ContextUsage,
        /// Details about what needs distillation.
        needed: DistillationNeeded,
    },
    /// Recent messages alone exceed budget; unrecoverable without user action.
    RecentMessagesTooLarge {
        /// Current usage statistics.
        usage: super::working_context::ContextUsage,
        /// Tokens required by recent messages.
        required_tokens: u32,
        /// Available budget tokens.
        budget_tokens: u32,
    },
}

pub enum DistillationPlanError { @ context/src/manager.rs:65
    EmptyScope,
    BudgetTooTight {
        available_tokens: u32,
        required_tokens: u32,
    },
}

impl Display for DistillationPlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

/// Types of facts the Librarian can extract.
pub enum FactType { @ context/src/librarian.rs:33
    /// Entities: files, functions, variables, paths, URLs, etc.
    Entity,
    /// Decisions: "we chose X because Y"
    Decision,
    /// Constraints: "must stay compatible with Z", "don't modify X"
    Constraint,
    /// Code state: what was created, modified, deleted
    CodeState,
    /// User-pinned facts (explicitly marked important)
    Pinned,
}

impl FactType {
    pub fn as_str(&self) -> &'static str; @ context/src/librarian.rs:48
}

pub enum HistoryEntry { @ context/src/history.rs:52
    Original {
        id: MessageId,
        message: forge_types::Message,
        token_count: u32,
        created_at: std::time::SystemTime,
        /// Stream journal step ID for crash recovery linkage (assistant messages only)
        stream_step_id: Option<crate::StepId>,
    },
    Distilled {
        id: MessageId,
        message: forge_types::Message,
        token_count: u32,
        distillate_id: DistillateId,
        created_at: std::time::SystemTime,
        stream_step_id: Option<crate::StepId>,
    },
}

impl HistoryEntry {
    pub fn distillate_id(&self) -> Option<DistillateId>; @ context/src/history.rs:224
    pub fn id(&self) -> MessageId; @ context/src/history.rs:200
    pub fn is_distilled(&self) -> bool; @ context/src/history.rs:240
    pub fn mark_distilled(&mut self, distillate_id: DistillateId); @ context/src/history.rs:244
    pub fn message(&self) -> &Message; @ context/src/history.rs:207
    pub fn new(id: MessageId, message: Message, token_count: u32) -> Self; @ context/src/history.rs:171
    /// Used for assistant messages from streaming responses to enable
    /// idempotent crash recovery.
    pub fn new_with_step_id(id: MessageId, message: Message, token_count: u32, stream_step_id: StepId) -> Self; @ context/src/history.rs:184
    pub fn stream_step_id(&self) -> Option<StepId>; @ context/src/history.rs:232
    pub fn token_count(&self) -> u32; @ context/src/history.rs:216
}

impl Serialize for HistoryEntry {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where S: serde::Serializer;
}

impl Deserialize<'de> for HistoryEntry {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where D: serde::Deserializer<'de>;
}

pub enum ModelLimitsSource { @ context/src/model_limits.rs:73
    Override,
    Catalog(forge_types::PredefinedModel),
}

/// Recovered stream data after a crash.
pub enum RecoveredStream { @ context/src/stream_journal.rs:349
    /// The stream ended cleanly but was not sealed.
    Complete {
        /// The step ID that was interrupted
        step_id: StepId,
        /// Accumulated text from `text_delta` events
        partial_text: String,
        /// Last sequence number seen
        last_seq: u64,
        /// Model name from the original stream (for accurate attribution)
        model_name: Option<String>,
    },
    /// The stream ended with an error but was not sealed.
    Errored {
        /// The step ID that was interrupted
        step_id: StepId,
        /// Accumulated text from `text_delta` events
        partial_text: String,
        /// Last sequence number seen
        last_seq: u64,
        /// Error message captured from the stream
        error: String,
        /// Model name from the original stream (for accurate attribution)
        model_name: Option<String>,
    },
    /// The stream ended mid-flight.
    Incomplete {
        /// The step ID that was interrupted
        step_id: StepId,
        /// Accumulated text from `text_delta` events
        partial_text: String,
        /// Last sequence number seen
        last_seq: u64,
        /// Model name from the original stream (for accurate attribution)
        model_name: Option<String>,
    },
}
```

## forge-engine

```rust
pub fn command_specs() -> &'static [CommandSpec]; @ engine/src/commands.rs:82

/// Find match positions for highlighting in the UI.
pub fn find_match_positions(path: &str, filter: &str) -> Vec<usize>; @ engine/src/ui/file_picker.rs:224

/// Single global instance (IFA-7 compliant).
pub fn sanitize_display_text(input: &str) -> String; @ engine/src/security.rs:259

pub struct App { @ engine/src/lib.rs:430
}

impl App {
    pub fn cancel_active_operation(&mut self) -> bool; @ engine/src/commands.rs:255
    /// Check for and recover from a crashed streaming session.
    pub fn check_crash_recovery(&mut self) -> Option<RecoveredStream>; @ engine/src/persistence.rs:304
    pub fn clear_files_panel_effect(&mut self); @ engine/src/lib.rs:624
    pub fn clear_modal_effect(&mut self); @ engine/src/lib.rs:1252
    /// Close the files panel (no-op if already hidden).
    pub fn close_files_panel(&mut self); @ engine/src/lib.rs:598
    pub fn command_cursor(&self) -> Option<usize>; @ engine/src/lib.rs:1605
    pub fn command_cursor_byte_index(&self) -> Option<usize>; @ engine/src/lib.rs:1609
    /// Get command mode wrapper (requires proof token).
    pub fn command_mode(&mut self, _token: CommandToken) -> CommandMode<'_>; @ engine/src/input_modes.rs:59
    pub fn command_text(&self) -> Option<&str>; @ engine/src/lib.rs:1601
    /// Get proof token if currently in Command mode.
    pub fn command_token(&self) -> Option<CommandToken>; @ engine/src/input_modes.rs:49
    /// Get context usage statistics for the UI.
    /// Uses cached value when available to avoid recomputing every frame.
    pub fn context_usage_status(&mut self) -> ContextUsageStatus; @ engine/src/lib.rs:1018
    /// Get the current API key for the selected provider.
    pub fn current_api_key(&self) -> Option<&SecretString>; @ engine/src/lib.rs:979
    pub fn display_items(&self) -> &[DisplayItem]; @ engine/src/lib.rs:960
    /// Version counter for display changes - used for render caching.
    pub fn display_version(&self) -> usize; @ engine/src/lib.rs:970
    pub fn draft_cursor(&self) -> usize; @ engine/src/lib.rs:1593
    pub fn draft_cursor_byte_index(&self) -> usize; @ engine/src/lib.rs:1597
    pub fn draft_text(&self) -> &str; @ engine/src/lib.rs:1589
    pub fn enter_command_mode(&mut self); @ engine/src/lib.rs:1279
    /// Enter file select mode, scanning files from the current directory.
    pub fn enter_file_select_mode(&mut self); @ engine/src/lib.rs:1356
    pub fn enter_insert_mode(&mut self); @ engine/src/lib.rs:1275
    pub fn enter_insert_mode_at_end(&mut self); @ engine/src/lib.rs:1260
    pub fn enter_insert_mode_with_clear(&mut self); @ engine/src/lib.rs:1265
    pub fn enter_model_select_mode(&mut self); @ engine/src/lib.rs:1283
    pub fn enter_normal_mode(&mut self); @ engine/src/lib.rs:1270
    /// Get the file picker state for rendering.
    pub fn file_picker(&self) -> &ui::FilePickerState; @ engine/src/lib.rs:1386
    /// Delete a character from the file select filter (backspace).
    pub fn file_select_backspace(&mut self); @ engine/src/lib.rs:1428
    /// Cancel file selection and return to insert mode.
    pub fn file_select_cancel(&mut self); @ engine/src/lib.rs:1452
    /// Confirm file selection - insert the selected file path into the draft.
    pub fn file_select_confirm(&mut self); @ engine/src/lib.rs:1436
    /// Get filtered files for display.
    pub fn file_select_files(&self) -> Vec<&ui::FileEntry>; @ engine/src/lib.rs:1381
    /// Get the current file select filter text.
    pub fn file_select_filter(&self) -> Option<&str>; @ engine/src/lib.rs:1371
    /// Get the current file select index.
    pub fn file_select_index(&self) -> Option<usize>; @ engine/src/lib.rs:1376
    /// Move file selection down.
    pub fn file_select_move_down(&mut self); @ engine/src/lib.rs:1400
    /// Move file selection up.
    pub fn file_select_move_up(&mut self); @ engine/src/lib.rs:1391
    /// Push a character to the file select filter.
    pub fn file_select_push_char(&mut self, c: char); @ engine/src/lib.rs:1420
    /// Update the file select filter and refresh filtered results.
    pub fn file_select_update_filter(&mut self); @ engine/src/lib.rs:1410
    /// Collapse the expanded diff.
    pub fn files_panel_collapse(&mut self); @ engine/src/lib.rs:715
    pub fn files_panel_diff(&self) -> Option<FileDiff>; @ engine/src/lib.rs:753
    /// Get mutable reference to files panel effect for UI processing.
    pub fn files_panel_effect_mut(&mut self) -> Option<&mut PanelEffect>; @ engine/src/lib.rs:620
    pub fn files_panel_expanded(&self) -> bool; @ engine/src/lib.rs:706
    /// Cycle to the next file in the panel (wrapping).
    pub fn files_panel_next(&mut self); @ engine/src/lib.rs:667
    /// Cycle to the previous file in the panel (wrapping).
    pub fn files_panel_prev(&mut self); @ engine/src/lib.rs:685
    /// Scroll the diff view down.
    pub fn files_panel_scroll_diff_down(&mut self); @ engine/src/lib.rs:745
    pub fn files_panel_scroll_diff_up(&mut self); @ engine/src/lib.rs:749
    pub fn files_panel_state(&self) -> &FilesPanelState; @ engine/src/lib.rs:710
    pub fn files_panel_sync_selection(&mut self); @ engine/src/lib.rs:720
    pub fn files_panel_visible(&self) -> bool; @ engine/src/lib.rs:615
    pub fn finish_files_panel_effect(&mut self); @ engine/src/lib.rs:628
    /// Get elapsed time since last frame and update timing.
    pub fn frame_elapsed(&mut self) -> Duration; @ engine/src/lib.rs:1240
    pub fn has_api_key(&self, provider: Provider) -> bool; @ engine/src/lib.rs:974
    pub fn history(&self) -> &forge_context::FullHistory; @ engine/src/lib.rs:825
    pub fn input_mode(&self) -> InputMode; @ engine/src/lib.rs:1256
    /// Get insert mode wrapper (requires proof token).
    pub fn insert_mode(&mut self, _token: InsertToken) -> InsertMode<'_>; @ engine/src/input_modes.rs:54
    /// Get proof token if currently in Insert mode.
    pub fn insert_token(&self) -> Option<InsertToken>; @ engine/src/input_modes.rs:44
    pub fn is_empty(&self) -> bool; @ engine/src/lib.rs:944
    /// Whether we're currently streaming a response.
    pub fn is_loading(&self) -> bool; @ engine/src/lib.rs:984
    /// Whether the named tool should be hidden from UI rendering.
    pub fn is_tool_hidden(&self, name: &str) -> bool; @ engine/src/lib.rs:965
    /// API usage from the last completed turn (for status bar display).
    pub fn last_turn_usage(&self) -> Option<&TurnUsage>; @ engine/src/lib.rs:1046
    /// Whether the LSP subsystem is active and has running servers.
    pub fn lsp_active(&self) -> bool; @ engine/src/lsp_integration.rs:153
    /// Get the current diagnostics snapshot for UI display.
    pub fn lsp_snapshot(&self) -> &forge_lsp::DiagnosticsSnapshot; @ engine/src/lsp_integration.rs:147
    pub fn memory_enabled(&self) -> bool; @ engine/src/lib.rs:1033
    /// Get mutable reference to modal effect for UI processing.
    pub fn modal_effect_mut(&mut self) -> Option<&mut ModalEffect>; @ engine/src/lib.rs:1248
    pub fn model(&self) -> &str; @ engine/src/lib.rs:793
    /// Select the current model and return to normal mode.
    pub fn model_select_confirm(&mut self); @ engine/src/lib.rs:1338
    pub fn model_select_index(&self) -> Option<usize>; @ engine/src/lib.rs:1297
    pub fn model_select_move_down(&mut self); @ engine/src/lib.rs:1321
    pub fn model_select_move_up(&mut self); @ engine/src/lib.rs:1313
    pub fn model_select_set_index(&mut self, index: usize); @ engine/src/lib.rs:1330
    /// Navigate to next (newer) command in Command mode.
    pub fn navigate_command_history_down(&mut self); @ engine/src/lib.rs:1646
    /// Navigate to previous (older) command in Command mode.
    pub fn navigate_command_history_up(&mut self); @ engine/src/lib.rs:1637
    /// Navigate to next (newer) prompt in Insert mode.
    pub fn navigate_history_down(&mut self); @ engine/src/lib.rs:1628
    /// Navigate to previous (older) prompt in Insert mode.
    pub fn navigate_history_up(&mut self); @ engine/src/lib.rs:1617
    pub fn new(system_prompts: SystemPrompts) -> anyhow::Result<Self>; @ engine/src/init.rs:62
    /// Get ordered list of changed files: modified first (alphabetical), then created.
    /// Filters out files that no longer exist on disk.
    pub fn ordered_files(&self) -> Vec<(std::path::PathBuf, ChangeKind)>; @ engine/src/lib.rs:646
    /// Poll for completed distillation task and apply the result.
    pub fn poll_distillation(&mut self); @ engine/src/distillation.rs:148
    pub fn process_command(&mut self, command: EnteredCommand); @ engine/src/commands.rs:327
    /// Process any pending stream events.
    pub fn process_stream_events(&mut self); @ engine/src/streaming.rs:431
    pub fn provider(&self) -> Provider; @ engine/src/lib.rs:789
    /// Queue a system notification to be injected into the next API request.
    pub fn queue_notification(&mut self, notification: notifications::SystemNotification); @ engine/src/lib.rs:1041
    /// Human-readable reason for a recovery block (if recovery is blocked).
    pub fn recovery_blocked_reason(&self) -> Option<String>; @ engine/src/lib.rs:994
    pub fn request_quit(&mut self); @ engine/src/lib.rs:554
    pub fn save_history(&self) -> anyhow::Result<()>; @ engine/src/persistence.rs:35
    /// Save session state (draft input + input history) to disk.
    pub fn save_session(&self) -> anyhow::Result<()>; @ engine/src/persistence.rs:140
    pub fn scroll_down(&mut self); @ engine/src/lib.rs:1707
    pub fn scroll_offset_from_top(&self) -> u16; @ engine/src/lib.rs:1676
    /// Scroll down by a page.
    pub fn scroll_page_down(&mut self); @ engine/src/lib.rs:1723
    /// Scroll up by a page.
    pub fn scroll_page_up(&mut self); @ engine/src/lib.rs:1695
    pub fn scroll_to_bottom(&mut self); @ engine/src/lib.rs:1743
    pub fn scroll_to_top(&mut self); @ engine/src/lib.rs:1739
    pub fn scroll_up(&mut self); @ engine/src/lib.rs:1683
    /// Scroll up by 20% of total scrollable content.
    pub fn scroll_up_chunk(&mut self); @ engine/src/lib.rs:1748
    pub fn session_changes(&self) -> &SessionChangeLog; @ engine/src/lib.rs:640
    /// Set a specific model (called from :model command).
    pub fn set_model(&mut self, model: ModelName); @ engine/src/lib.rs:1154
    pub fn should_quit(&self) -> bool; @ engine/src/lib.rs:550
    /// Gracefully shut down all LSP servers.
    pub async fn shutdown_lsp(&mut self); @ engine/src/lsp_integration.rs:166
    /// Trigger distillation of older messages when context is near capacity.
    pub fn start_distillation(&mut self); @ engine/src/distillation.rs:17
    pub fn start_streaming(&mut self, queued: QueuedUserMessage); @ engine/src/streaming.rs:209
    pub fn streaming(&self) -> Option<&StreamingMessage>; @ engine/src/lib.rs:829
    /// Check if a transcript clear was requested and clear the flag.
    pub fn take_clear_transcript(&mut self) -> bool; @ engine/src/lib.rs:559
    /// Poll background tasks and update wall-clock based timers.
    pub fn tick(&mut self); @ engine/src/lib.rs:1218
    pub fn tick_count(&self) -> usize; @ engine/src/lib.rs:821
    /// Toggle visibility of the files panel.
    pub fn toggle_files_panel(&mut self); @ engine/src/lib.rs:573
    /// Toggle visibility of thinking/reasoning content in the UI.
    pub fn toggle_thinking(&mut self); @ engine/src/lib.rs:568
    /// Handle Enter key on approval prompt - action depends on cursor position:
    /// - On tool item: toggle selection
    /// - On Submit button: confirm selected
    /// - On Deny All button: deny all
    pub fn tool_approval_activate(&mut self); @ engine/src/lib.rs:1523
    pub fn tool_approval_approve_all(&mut self); @ engine/src/lib.rs:1511
    pub fn tool_approval_confirm_selected(&mut self); @ engine/src/lib.rs:1538
    pub fn tool_approval_cursor(&self) -> Option<usize>; @ engine/src/lib.rs:917
    pub fn tool_approval_deny_all(&mut self); @ engine/src/lib.rs:1515
    pub fn tool_approval_deny_confirm(&self) -> bool; @ engine/src/lib.rs:925
    pub fn tool_approval_expanded(&self) -> Option<usize>; @ engine/src/lib.rs:921
    pub fn tool_approval_move_down(&mut self); @ engine/src/lib.rs:1469
    pub fn tool_approval_move_up(&mut self); @ engine/src/lib.rs:1456
    pub fn tool_approval_request_deny_all(&mut self); @ engine/src/lib.rs:1559
    pub fn tool_approval_requests(&self) -> Option<&[tools::ConfirmationRequest]>; @ engine/src/lib.rs:909
    pub fn tool_approval_selected(&self) -> Option<&[bool]>; @ engine/src/lib.rs:913
    pub fn tool_approval_toggle(&mut self); @ engine/src/lib.rs:1483
    pub fn tool_approval_toggle_details(&mut self); @ engine/src/lib.rs:1495
    /// If present, tools are disabled for safety due to a tool journal error.
    pub fn tool_journal_disabled_reason(&self) -> Option<&str>; @ engine/src/lib.rs:989
    pub fn tool_loop_calls(&self) -> Option<&[ToolCall]>; @ engine/src/lib.rs:880
    pub fn tool_loop_current_call_id(&self) -> Option<&str>; @ engine/src/lib.rs:892
    pub fn tool_loop_execute_calls(&self) -> Option<&[ToolCall]>; @ engine/src/lib.rs:884
    pub fn tool_loop_output_lines(&self) -> Option<&[String]>; @ engine/src/lib.rs:896
    pub fn tool_loop_output_lines_for(&self, tool_call_id: &str) -> Option<&[String]>; @ engine/src/lib.rs:902
    pub fn tool_loop_results(&self) -> Option<&[ToolResult]>; @ engine/src/lib.rs:888
    pub fn tool_recovery_calls(&self) -> Option<&[ToolCall]>; @ engine/src/lib.rs:930
    pub fn tool_recovery_discard(&mut self); @ engine/src/lib.rs:1585
    pub fn tool_recovery_results(&self) -> Option<&[ToolResult]>; @ engine/src/lib.rs:937
    pub fn tool_recovery_resume(&mut self); @ engine/src/lib.rs:1581
    pub fn ui_options(&self) -> UiOptions; @ engine/src/lib.rs:563
    pub fn update_scroll_max(&mut self, max: u16); @ engine/src/lib.rs:1666
}

pub struct AppConfig { @ engine/src/config.rs:44
    pub model: Option<String>,
    pub tui: Option<String>,
    /// Use ASCII-only glyphs for icons and spinners.
    pub ascii_only: bool,
    /// Enable a high-contrast color palette.
    pub high_contrast: bool,
    /// Disable modal animations and motion effects.
    pub reduced_motion: bool,
    /// Render provider thinking/reasoning deltas in the UI (if available).
    pub show_thinking: bool,
}

/// Mode wrapper for safe command operations.
pub struct CommandMode<'a> { @ engine/src/input_modes.rs:38
}

impl CommandMode<'a> {
    pub fn backspace(&mut self); @ engine/src/input_modes.rs:256
    pub fn clear_line(&mut self); @ engine/src/input_modes.rs:270
    pub fn delete_word_backwards(&mut self); @ engine/src/input_modes.rs:263
    pub fn move_cursor_end(&mut self); @ engine/src/input_modes.rs:242
    pub fn move_cursor_left(&mut self); @ engine/src/input_modes.rs:221
    pub fn move_cursor_right(&mut self); @ engine/src/input_modes.rs:228
    pub fn push_char(&mut self, c: char); @ engine/src/input_modes.rs:249
    pub fn reset_cursor(&mut self); @ engine/src/input_modes.rs:235
    /// Perform shell-style tab completion on the command line.
    pub fn tab_complete(&mut self); @ engine/src/input_modes.rs:286
    pub fn take_command(self) -> Option<EnteredCommand>; @ engine/src/input_modes.rs:310
}

pub struct CommandSpec { @ engine/src/commands.rs:12
    pub palette_label: &'static str,
    pub help_label: &'static str,
    pub description: &'static str,
}

/// Proof token for Command mode operations.
pub struct CommandToken { @ engine/src/input_modes.rs:30
}

pub struct DistillationTask { @ engine/src/state.rs:286
}

/// Draft input buffer with cursor tracking.
pub struct DraftInput { @ engine/src/ui/input.rs:21
}

impl DraftInput {
    pub fn byte_index(&self) -> usize; @ engine/src/ui/input.rs:144
    pub fn clear(&mut self); @ engine/src/ui/input.rs:101
    pub fn cursor(&self) -> usize; @ engine/src/ui/input.rs:33
    pub fn delete_char(&mut self); @ engine/src/ui/input.rs:71
    pub fn delete_char_forward(&mut self); @ engine/src/ui/input.rs:82
    pub fn delete_word_backwards(&mut self); @ engine/src/ui/input.rs:112
    pub fn enter_char(&mut self, new_char: char); @ engine/src/ui/input.rs:51
    pub fn enter_newline(&mut self); @ engine/src/ui/input.rs:57
    pub fn enter_text(&mut self, text: &str); @ engine/src/ui/input.rs:61
    pub fn grapheme_count(&self) -> usize; @ engine/src/ui/input.rs:132
    pub fn move_cursor_end(&mut self); @ engine/src/ui/input.rs:97
    pub fn move_cursor_left(&mut self); @ engine/src/ui/input.rs:42
    pub fn move_cursor_right(&mut self); @ engine/src/ui/input.rs:46
    pub fn reset_cursor(&mut self); @ engine/src/ui/input.rs:93
    /// Set the draft text and move cursor to end.
    pub fn set_text(&mut self, text: String); @ engine/src/ui/input.rs:107
    pub fn take_text(&mut self) -> String; @ engine/src/ui/input.rs:37
    pub fn text(&self) -> &str; @ engine/src/ui/input.rs:28
}

/// Proof that a command line was entered in Command mode.
pub struct EnteredCommand { @ engine/src/input_modes.rs:20
}

/// Scanned file entry with display path and full path.
pub struct FileEntry { @ engine/src/ui/file_picker.rs:16
    /// Display path (relative to root, using forward slashes).
    pub display: String,
    /// Full absolute path.
    pub path: std::path::PathBuf,
}

/// File picker state for the "@" reference feature.
pub struct FilePickerState { @ engine/src/ui/file_picker.rs:25
}

impl FilePickerState {
    pub fn filtered_count(&self) -> usize; @ engine/src/ui/file_picker.rs:147
    /// Get filtered file entries for display.
    pub fn filtered_files(&self) -> Vec<&FileEntry>; @ engine/src/ui/file_picker.rs:132
    pub fn get_selected(&self, selected: usize) -> Option<&FileEntry>; @ engine/src/ui/file_picker.rs:140
    /// Check if files have been scanned.
    pub fn is_scanned(&self) -> bool; @ engine/src/ui/file_picker.rs:153
    pub fn new() -> Self; @ engine/src/ui/file_picker.rs:36
    /// Scan files from the given root directory, respecting .gitignore.
    pub fn scan_files(&mut self, root: &Path); @ engine/src/ui/file_picker.rs:41
    /// Get total file count (before filtering).
    pub fn total_count(&self) -> usize; @ engine/src/ui/file_picker.rs:159
    /// Update filtered results based on filter text.
    pub fn update_filter(&mut self, filter: &str); @ engine/src/ui/file_picker.rs:93
}

/// Interactive state for the files panel.
pub struct FilesPanelState { @ engine/src/ui/view_state.rs:22
    /// Whether the panel is visible.
    pub visible: bool,
    /// Index into the flattened file list (modified first, then created).
    pub selected: usize,
    /// Which file's diff is currently expanded (None = collapsed).
    pub expanded: Option<std::path::PathBuf>,
    /// Scroll offset within the diff view.
    pub diff_scroll: usize,
}

pub struct ForgeConfig { @ engine/src/config.rs:8
    pub app: Option<AppConfig>,
    pub api_keys: Option<ApiKeys>,
    pub context: Option<ContextConfig>,
    pub cache: Option<CacheConfig>,
    pub thinking: Option<ThinkingConfig>,
    pub anthropic: Option<AnthropicConfig>,
    pub openai: Option<OpenAIConfig>,
    pub google: Option<GeminiConfig>,
    /// Tool configurations for function calling.
    pub tools: Option<ToolsConfig>,
    /// LSP client configuration for language server diagnostics.
    pub lsp: Option<forge_lsp::LspConfig>,
}

impl ForgeConfig {
    pub fn load() -> Result<Option<Self>, ConfigError>; @ engine/src/config.rs:453
    pub fn path() -> Option<PathBuf>; @ engine/src/config.rs:480
    /// Persist the model to the config file.
    pub fn persist_model(model: &str) -> std::io::Result<()>; @ engine/src/config.rs:488
}

/// Input history for prompt and command recall.
pub struct InputHistory { @ engine/src/ui/history.rs:32
}

impl InputHistory {
    /// Navigate to the next (newer) command.
    pub fn navigate_command_down(&mut self) -> Option<&str>; @ engine/src/ui/history.rs:159
    /// Navigate to the previous (older) command.
    pub fn navigate_command_up(&mut self, current: &str) -> Option<&str>; @ engine/src/ui/history.rs:136
    /// Navigate to the next (newer) prompt.
    pub fn navigate_prompt_down(&mut self) -> Option<&str>; @ engine/src/ui/history.rs:116
    /// Navigate to the previous (older) prompt.
    pub fn navigate_prompt_up(&mut self, current: &str) -> Option<&str>; @ engine/src/ui/history.rs:93
    /// Add a command to history.
    pub fn push_command(&mut self, text: String); @ engine/src/ui/history.rs:75
    /// Add a prompt to history.
    pub fn push_prompt(&mut self, text: String); @ engine/src/ui/history.rs:58
    /// Reset navigation state.
    pub fn reset_navigation(&mut self); @ engine/src/ui/history.rs:178
}

/// Mode wrapper for safe insert operations.
pub struct InsertMode<'a> { @ engine/src/input_modes.rs:33
}

impl InsertMode<'a> {
    pub fn clear_line(&mut self); @ engine/src/input_modes.rs:109
    pub fn delete_char(&mut self); @ engine/src/input_modes.rs:89
    pub fn delete_char_forward(&mut self); @ engine/src/input_modes.rs:93
    pub fn delete_word_backwards(&mut self); @ engine/src/input_modes.rs:97
    pub fn enter_char(&mut self, new_char: char); @ engine/src/input_modes.rs:77
    pub fn enter_newline(&mut self); @ engine/src/input_modes.rs:81
    pub fn enter_text(&mut self, text: &str); @ engine/src/input_modes.rs:85
    pub fn move_cursor_end(&mut self); @ engine/src/input_modes.rs:105
    pub fn move_cursor_left(&mut self); @ engine/src/input_modes.rs:69
    pub fn move_cursor_right(&mut self); @ engine/src/input_modes.rs:73
    /// Queue the current draft as a user message.
    pub fn queue_message(self) -> Option<QueuedUserMessage>; @ engine/src/input_modes.rs:118
    pub fn reset_cursor(&mut self); @ engine/src/input_modes.rs:101
}

/// Proof token for Insert mode operations.
pub struct InsertToken { @ engine/src/input_modes.rs:26
}

/// Modal animation effect state.
pub struct ModalEffect { @ engine/src/ui/modal.rs:15
}

impl ModalEffect {
    /// Advance the animation by the given delta time.
    pub fn advance(&mut self, delta: Duration); @ engine/src/ui/modal.rs:50
    /// Check if the animation is finished.
    pub fn is_finished(&self) -> bool; @ engine/src/ui/modal.rs:67
    pub fn kind(&self) -> ModalEffectKind; @ engine/src/ui/modal.rs:72
    pub fn pop_scale(duration: Duration) -> Self; @ engine/src/ui/modal.rs:23
    /// Get the animation progress (0.0 to 1.0).
    pub fn progress(&self) -> f32; @ engine/src/ui/modal.rs:56
    pub fn shake(duration: Duration) -> Self; @ engine/src/ui/modal.rs:41
    pub fn slide_up(duration: Duration) -> Self; @ engine/src/ui/modal.rs:32
}

/// Animation state for the files panel.
pub struct PanelEffect { @ engine/src/ui/panel.rs:14
}

impl PanelEffect {
    /// Advance the animation by the given delta time.
    pub fn advance(&mut self, delta: Duration); @ engine/src/ui/panel.rs:40
    /// Check if the animation is finished.
    pub fn is_finished(&self) -> bool; @ engine/src/ui/panel.rs:57
    pub fn kind(&self) -> PanelEffectKind; @ engine/src/ui/panel.rs:62
    /// Get the animation progress (0.0 to 1.0).
    pub fn progress(&self) -> f32; @ engine/src/ui/panel.rs:46
    pub fn slide_in_right(duration: Duration) -> Self; @ engine/src/ui/panel.rs:22
    pub fn slide_out_right(duration: Duration) -> Self; @ engine/src/ui/panel.rs:31
}

/// Proof that a user message was validated and queued for sending.
pub struct QueuedUserMessage { @ engine/src/input_modes.rs:13
}

/// Tracks files created and modified during a session.
pub struct SessionChangeLog { @ engine/src/session_state.rs:20
    /// Files created during the session.
    pub created: std::collections::BTreeSet<std::path::PathBuf>,
    /// Files modified (but not created) during the session.
    pub modified: std::collections::BTreeSet<std::path::PathBuf>,
}

impl SessionChangeLog {
    /// Returns true if no files have been created or modified.
    pub fn is_empty(&self) -> bool; @ engine/src/session_state.rs:47
    /// Merge a turn's changes into the session-wide log.
    pub fn merge_turn(&mut self, created: &BTreeSet<PathBuf>, modified: &BTreeSet<PathBuf>); @ engine/src/session_state.rs:33
}

/// An in-flight streaming response from an LLM.
pub struct StreamingMessage { @ engine/src/lib.rs:172
}

impl StreamingMessage {
    pub fn apply_event(&mut self, event: StreamEvent) -> Option<StreamFinishReason>; @ engine/src/lib.rs:240
    pub fn content(&self) -> &str; @ engine/src/lib.rs:216
    pub fn has_tool_calls(&self) -> bool; @ engine/src/lib.rs:319
    pub fn into_message(self) -> Result<Message, forge_types::EmptyStringError>; @ engine/src/lib.rs:399
    pub fn model_name(&self) -> &ModelName; @ engine/src/lib.rs:211
    pub fn new(model: ModelName, receiver: mpsc::Receiver<StreamEvent>, max_tool_args_bytes: usize) -> Self; @ engine/src/lib.rs:188
    pub fn provider(&self) -> Provider; @ engine/src/lib.rs:206
    pub fn thinking(&self) -> &str; @ engine/src/lib.rs:221
    pub fn thinking_replay_state(&self) -> &ThinkingReplayState; @ engine/src/lib.rs:226
    pub fn try_recv_event(&mut self) -> Result<StreamEvent, mpsc::error::TryRecvError>; @ engine/src/lib.rs:236
    /// API-reported token usage accumulated during streaming.
    pub fn usage(&self) -> ApiUsage; @ engine/src/lib.rs:232
}

pub struct SystemPrompts { @ engine/src/lib.rs:410
    /// Claude-specific prompt.
    pub claude: &'static str,
    /// OpenAI-specific prompt.
    pub openai: &'static str,
    /// Gemini-specific prompt.
    pub gemini: &'static str,
}

impl SystemPrompts {
    pub fn get(&self, provider: Provider) -> &'static str; @ engine/src/lib.rs:421
}

/// Aggregated API usage for a user turn (may include multiple API calls).
pub struct TurnUsage { @ engine/src/lib.rs:119
    /// Number of API calls made during this turn.
    pub api_calls: u32,
    /// Total usage aggregated across all API calls.
    pub total: ApiUsage,
    /// Usage from the most recent API call (for display).
    pub last_call: ApiUsage,
}

impl TurnUsage {
    pub fn record_call(&mut self, usage: ApiUsage); @ engine/src/lib.rs:129
}

/// UI configuration options derived from config/environment.
pub struct UiOptions { @ engine/src/ui/view_state.rs:35
    pub ascii_only: bool,
    pub high_contrast: bool,
    pub reduced_motion: bool,
    /// Whether to render provider thinking/reasoning deltas (if available).
    pub show_thinking: bool,
}

/// State related to rendering and UI display.
pub struct ViewState { @ engine/src/ui/view_state.rs:49
    /// Scroll position for the message view.
    pub scroll: super::ScrollState,
    /// Maximum scroll offset (content length - viewport).
    pub scroll_max: u16,
    /// Request to clear the visible transcript (handled by the UI).
    pub clear_transcript: bool,
    /// Active modal animation effect.
    pub modal_effect: Option<super::ModalEffect>,
    /// Active files panel animation effect.
    pub files_panel_effect: Option<super::PanelEffect>,
    /// UI options (theme, motion, glyphs).
    pub ui_options: UiOptions,
    /// Timestamp of last frame (for animation timing).
    pub last_frame: std::time::Instant,
    /// Interactive state for the files panel.
    pub files_panel: FilesPanelState,
}

impl ViewState {
    pub fn new() -> Self; @ engine/src/ui/view_state.rs:85
}

impl Default for ViewState {
    fn default() -> Self;
}

/// Classification of file changes for display.
pub enum ChangeKind { @ engine/src/ui/view_state.rs:13
    /// File existed before and was modified.
    Modified,
    /// File was created during this session.
    Created,
}

/// An item to display in the message view.
pub enum DisplayItem { @ engine/src/ui/display.rs:11
    /// A message from persisted history, referenced by ID.
    History(forge_context::MessageId),
    /// A local message not yet in history (e.g., error messages, system notices).
    Local(forge_types::Message),
}

/// Result of diff generation for panel display.
pub enum FileDiff { @ engine/src/lib.rs:104
    /// Unified diff between baseline and current.
    Diff(String),
    /// File was created (no baseline) - show full content as additions.
    Created(String),
    /// File no longer exists on disk.
    Deleted,
    /// Binary file - show size only.
    Binary(usize),
    /// Error reading file.
    Error(String),
}

/// Input mode for the application.
pub enum InputMode { @ engine/src/ui/input.rs:8
    Normal,
    Insert,
    Command,
    ModelSelect,
    FileSelect,
}

/// The kind of modal animation effect.
pub enum ModalEffectKind { @ engine/src/ui/modal.rs:7
    PopScale,
    SlideUp,
    Shake,
}

/// The kind of panel animation effect.
pub enum PanelEffectKind { @ engine/src/ui/panel.rs:7
    SlideInRight,
    SlideOutRight,
}

/// Scroll position for the message view.
pub enum ScrollState { @ engine/src/ui/scroll.rs:5
    /// Always keep the newest content visible.
    AutoBottom,
    /// Manual scroll offset from the top of the rendered message buffer.
    Manual {
        offset_from_top: u16,
    },
}

/// A system notification that Forge can inject into the conversation.
pub enum SystemNotification { @ engine/src/notifications.rs:24
    /// User approved tool calls.
    ToolsApproved {
        /// Number of tools approved.
        count: u8,
    },
    /// User denied tool calls.
    ToolsDenied {
        /// Number of tools denied.
        count: u8,
    },
    /// Compiler/linter diagnostics found in recently edited files.
    DiagnosticsFound {
        /// Pre-formatted summary (e.g. "src/main.rs:42: error: expected `;`").
        summary: String,
    },
}

impl SystemNotification {
    /// Format the notification as a human-readable string.
    pub fn format(&self) -> String; @ engine/src/notifications.rs:48
}
```

## forge-tui

```rust
/// Apply a modal effect to transform the base rectangle.
pub fn apply_modal_effect(effect: &forge_engine::ModalEffect, base: ratatui::layout::Rect, viewport: ratatui::layout::Rect) -> ratatui::layout::Rect; @ tui/src/effects.rs:9

/// Clear the render cache. Call when switching themes or on memory pressure.
pub fn clear_render_cache(); @ tui/src/markdown.rs:108

pub fn draw(frame: &mut ratatui::Frame<'_>, app: &mut forge_engine::App); @ tui/src/lib.rs:102

pub fn draw_model_selector(frame: &mut ratatui::Frame<'_>, app: &mut forge_engine::App, palette: &Palette, glyphs: &Glyphs, elapsed: std::time::Duration); @ tui/src/lib.rs:1577

pub fn glyphs(options: forge_engine::UiOptions) -> Glyphs; @ tui/src/theme.rs:176

pub fn handle_events(app: &mut forge_engine::App, input: &mut InputPump) -> anyhow::Result<bool>; @ tui/src/input.rs:237

pub fn palette(options: forge_engine::UiOptions) -> Palette; @ tui/src/theme.rs:136

/// Render markdown content to ratatui Lines.
pub fn render_markdown(content: &str, base_style: ratatui::style::Style, palette: &crate::theme::Palette, max_width: u16) -> Vec<ratatui::text::Line<'static>>; @ tui/src/markdown.rs:119

/// Get spinner frame based on tick count and UI options.
pub fn spinner_frame(tick: usize, options: forge_engine::UiOptions) -> &'static str; @ tui/src/theme.rs:236

/// ASCII/Unicode glyphs for icons and spinners.
pub struct Glyphs { @ tui/src/theme.rs:146
    pub system: &'static str,
    pub user: &'static str,
    pub assistant: &'static str,
    pub thinking: &'static str,
    pub tool: &'static str,
    pub tool_result_ok: &'static str,
    pub tool_result_err: &'static str,
    pub tree_connector: &'static str,
    pub status_ready: &'static str,
    pub status_missing: &'static str,
    pub pending: &'static str,
    pub denied: &'static str,
    pub paused: &'static str,
    pub running: &'static str,
    pub bullet: &'static str,
    pub arrow_up: &'static str,
    pub arrow_down: &'static str,
    pub track: &'static str,
    pub thumb: &'static str,
    pub selected: &'static str,
    pub spinner_frames: &'static [&'static str],
    pub add: &'static str,
    pub modified: &'static str,
}

pub struct InputPump { @ tui/src/input.rs:115
}

impl InputPump {
    pub fn new() -> Self; @ tui/src/input.rs:125
    pub async fn shutdown(&mut self); @ tui/src/input.rs:141
}

impl Default for InputPump {
    fn default() -> Self;
}

impl Drop for InputPump {
    fn drop(&mut self);
}

pub struct MessageLinesCache { @ tui/src/lib.rs:50
}

/// Resolved theme palette used by the UI.
pub struct Palette { @ tui/src/theme.rs:52
    pub bg_dark: ratatui::style::Color,
    pub bg_panel: ratatui::style::Color,
    pub bg_highlight: ratatui::style::Color,
    pub bg_popup: ratatui::style::Color,
    pub bg_border: ratatui::style::Color,
    pub text_primary: ratatui::style::Color,
    pub text_secondary: ratatui::style::Color,
    pub text_muted: ratatui::style::Color,
    pub text_disabled: ratatui::style::Color,
    pub primary: ratatui::style::Color,
    pub primary_dim: ratatui::style::Color,
    pub accent: ratatui::style::Color,
    pub success: ratatui::style::Color,
    pub warning: ratatui::style::Color,
    pub error: ratatui::style::Color,
    pub peach: ratatui::style::Color,
    pub green: ratatui::style::Color,
    pub yellow: ratatui::style::Color,
    pub red: ratatui::style::Color,
    pub provider_claude: ratatui::style::Color,
    pub provider_openai: ratatui::style::Color,
    pub provider_gemini: ratatui::style::Color,
}

impl Palette {
    pub fn high_contrast() -> Self; @ tui/src/theme.rs:107
    pub fn standard() -> Self; @ tui/src/theme.rs:79
}
```

## forge-lsp

```rust
pub struct DiagnosticsSnapshot { @ lsp/src/types.rs:244
}

impl DiagnosticsSnapshot {
    /// Number of error-level diagnostics.
    pub fn error_count(&self) -> usize; @ lsp/src/types.rs:277
    /// Per-file diagnostics, sorted with error-containing files first.
    pub fn files(&self) -> &[(PathBuf, Vec<ForgeDiagnostic>)]; @ lsp/src/types.rs:257
    /// Number of hint-level diagnostics.
    pub fn hint_count(&self) -> usize; @ lsp/src/types.rs:295
    /// Number of info-level diagnostics.
    pub fn info_count(&self) -> usize; @ lsp/src/types.rs:289
    /// Whether there are any diagnostics.
    pub fn is_empty(&self) -> bool; @ lsp/src/types.rs:263
    /// Format a compact status string like "E:3 W:5".
    pub fn status_string(&self) -> String; @ lsp/src/types.rs:307
    /// Total diagnostic count across all files.
    pub fn total_count(&self) -> usize; @ lsp/src/types.rs:301
    /// Number of warning-level diagnostics.
    pub fn warning_count(&self) -> usize; @ lsp/src/types.rs:283
}

pub struct ForgeDiagnostic { @ lsp/src/types.rs:142
}

impl ForgeDiagnostic {
    /// 0-indexed column.
    pub fn col(&self) -> u32; @ lsp/src/types.rs:190
    /// Format as `path:line:col: severity: message` (1-indexed for display).
    pub fn display_with_path(&self, path: &std::path::Path) -> String; @ lsp/src/types.rs:205
    /// 0-indexed line number.
    pub fn line(&self) -> u32; @ lsp/src/types.rs:184
    pub fn message(&self) -> &str; @ lsp/src/types.rs:178
    pub fn new(severity: DiagnosticSeverity, message: String, line: u32, col: u32, source: String) -> Self; @ lsp/src/types.rs:156
    pub fn severity(&self) -> DiagnosticSeverity; @ lsp/src/types.rs:173
    /// Source of the diagnostic (e.g. "rustc", "clippy").
    pub fn source(&self) -> &str; @ lsp/src/types.rs:196
}

pub struct FrameReader<R> { @ lsp/src/codec.rs:8
}

impl FrameReader<R> {
    pub fn new(reader: R) -> Self; @ lsp/src/codec.rs:13
    pub async fn read_frame(&mut self) -> Result<Option<serde_json::Value>>; @ lsp/src/codec.rs:19
}

pub struct FrameWriter<W> { @ lsp/src/codec.rs:88
}

impl FrameWriter<W> {
    pub fn new(writer: W) -> Self; @ lsp/src/codec.rs:93
    pub async fn write_frame(&mut self, msg: &serde_json::Value) -> Result<()>; @ lsp/src/codec.rs:97
}

pub struct LspConfig { @ lsp/src/types.rs:28
}

impl LspConfig {
    pub fn enabled(&self) -> bool; @ lsp/src/types.rs:37
    pub fn servers(&self) -> &HashMap<String, ServerConfig>; @ lsp/src/types.rs:42
}

pub struct LspManager { @ lsp/src/manager.rs:34
}

impl LspManager {
    /// Get only errors for specific files.
    pub fn errors_for_files(&self, paths: &[PathBuf]) -> Vec<(PathBuf, Vec<ForgeDiagnostic>)>; @ lsp/src/manager.rs:167
    pub fn has_running_servers(&self) -> bool; @ lsp/src/manager.rs:172
    pub async fn on_file_changed(&mut self, path: &Path, text: &str); @ lsp/src/manager.rs:81
    pub fn poll_events(&mut self, budget: usize) -> usize; @ lsp/src/manager.rs:113
    pub async fn shutdown(&mut self); @ lsp/src/manager.rs:176
    pub fn snapshot(&self) -> DiagnosticsSnapshot; @ lsp/src/manager.rs:161
    pub async fn start(config: LspConfig, workspace_root: &Path) -> Self; @ lsp/src/manager.rs:44
}

pub struct ServerConfig { @ lsp/src/types.rs:49
}

impl ServerConfig {
    pub fn args(&self) -> &[String]; @ lsp/src/types.rs:84
    pub fn command(&self) -> &str; @ lsp/src/types.rs:79
    pub fn file_extensions(&self) -> &[String]; @ lsp/src/types.rs:94
    pub fn language_id(&self) -> &str; @ lsp/src/types.rs:89
    pub fn root_markers(&self) -> &[String]; @ lsp/src/types.rs:99
}

/// Severity level for a diagnostic.
pub enum DiagnosticSeverity { @ lsp/src/types.rs:106
    Error,
    Warning,
    Information,
    Hint,
}

impl DiagnosticSeverity {
    pub fn from_lsp(value: u64) -> Option<Self>; @ lsp/src/types.rs:115
    pub fn is_error(self) -> bool; @ lsp/src/types.rs:126
    pub fn label(self) -> &'static str; @ lsp/src/types.rs:131
}

pub enum LspEvent { @ lsp/src/types.rs:230
    /// Server stopped running. Manager removes it from the active map.
    ServerStopped {
        server: String,
        reason: ServerStopReason,
    },
    /// Diagnostics updated for a file.
    Diagnostics {
        path: std::path::PathBuf,
        items: Vec<ForgeDiagnostic>,
    },
}

pub enum ServerConfigError { @ lsp/src/types.rs:8
    EmptyCommand,
    EmptyLanguageId,
}

/// Reason a language server stopped running.
pub enum ServerStopReason { @ lsp/src/types.rs:222
    /// Clean shutdown (EOF on stdout).
    Exited,
    /// Crashed or encountered an I/O error.
    Failed(String),
}
```

## forge

```rust
/// Eagerly initializes all system prompts.
pub fn init(); @ cli/src/assets.rs:40

/// Returns provider-specific system prompts for LLM initialization.
pub fn system_prompts() -> forge_engine::SystemPrompts; @ cli/src/assets.rs:50
```

## forge-tools

```rust
/// Analyze tool arguments for homoglyphs (BOUNDARY per IFA-11).
pub fn analyze_tool_arguments(tool_name: &str, args: &serde_json::Value) -> Vec<forge_types::HomoglyphWarning>; @ tools/src/lib.rs:113

pub fn apply_ops(content: &mut FileContent, ops: &[Op]) -> Result<(), PatchError>; @ tools/src/lp1.rs:362

/// Compute diff stats (additions and deletions) between old and new content.
pub fn compute_diff_stats(old_bytes: &[u8], new_bytes: &[u8]) -> (u32, u32); @ tools/src/builtins.rs:265

/// Serde helper for fields that default to `true`.
pub const fn default_true() -> bool; @ tools/src/config.rs:10

/// Detect the best available shell based on config and platform.
pub fn detect_shell(config: Option<&crate::config::ShellConfig>) -> DetectedShell; @ tools/src/shell.rs:30

pub fn emit_file(content: &FileContent) -> Vec<u8>; @ tools/src/lp1.rs:343

pub async fn fetch(input: WebFetchInput, config: &WebFetchConfig) -> Result<WebFetchOutput, WebFetchError>; @ tools/src/webfetch/mod.rs:38

/// Format a unified diff between old and new file content.
pub fn format_unified_diff(path: &str, old_bytes: &[u8], new_bytes: &[u8], existed: bool) -> String; @ tools/src/builtins.rs:152

/// Like `format_unified_diff`, but accepts a minimum line-number column width.
pub fn format_unified_diff_width(_path: &str, old_bytes: &[u8], new_bytes: &[u8], _existed: bool, min_line_num_width: usize) -> String; @ tools/src/builtins.rs:167

pub fn parse_file(bytes: &[u8]) -> Result<FileContent, PatchError>; @ tools/src/lp1.rs:286

pub fn parse_patch(input: &str) -> Result<Patch, PatchError>; @ tools/src/lp1.rs:72

/// Best-effort lookup of a process start timestamp (Unix epoch milliseconds).
pub fn process_started_at_unix_ms(pid: u32) -> Option<i64>; @ tools/src/process.rs:63

/// Redact sensitive tokens from a string.
pub fn redact_api_keys(raw: &str) -> String; @ tools/src/security.rs:310

/// Redact obvious secrets in output distillates (best-effort).
pub fn redact_distillate(raw: &str) -> String; @ tools/src/lib.rs:515

/// Register built-in tools into the registry.
pub fn register_builtins(registry: &mut super::ToolRegistry, read_limits: super::ReadFileLimits, patch_limits: super::PatchLimits, search_config: super::SearchToolConfig, webfetch_config: super::WebFetchToolConfig, shell: super::DetectedShell, run_policy: super::RunSandboxPolicy) -> Result<(), super::ToolError>; @ tools/src/builtins.rs:1316

pub fn register_git_tool(registry: &mut super::ToolRegistry) -> Result<(), super::ToolError>; @ tools/src/git.rs:513

/// Single global instance (IFA-7 compliant).
pub fn sanitize_display_text(input: &str) -> String; @ tools/src/security.rs:259

/// Sanitize tool output for terminal display and context inclusion.
pub fn sanitize_output(output: &str) -> String; @ tools/src/lib.rs:509

/// Sanitize a stream error message by redacting secrets and stripping controls.
pub fn sanitize_stream_error(raw: &str) -> String; @ tools/src/security.rs:286

/// Get the global secret redactor instance.
pub fn secret_redactor() -> &'static SecretRedactor; @ tools/src/security.rs:274

/// Truncate tool output to the effective maximum length.
pub fn truncate_output(output: String, effective_max: usize) -> String; @ tools/src/lib.rs:482

/// Terminate a process (and its process group on Unix) best-effort.
pub fn try_kill_process_group(pid: u32) -> std::io::Result<KillOutcome>; @ tools/src/process.rs:88

/// Validate arguments against a JSON schema.
pub fn validate_args(schema: &serde_json::Value, args: &serde_json::Value) -> Result<(), ToolError>; @ tools/src/lib.rs:467

pub struct ApplyPatchTool { @ tools/src/builtins.rs:60
}

impl ApplyPatchTool {
    pub fn new(limits: PatchLimits) -> Self; @ tools/src/builtins.rs:92
}

impl ToolExecutor for ApplyPatchTool {
    fn name(&self) -> &'static str;
    fn description(&self) -> &'static str;
    fn schema(&self) -> serde_json::Value;
    fn is_side_effecting(&self, _args: &serde_json::Value) -> bool;
    fn approval_summary(&self, args: &serde_json::Value) -> Result<String, ToolError>;
    fn execute<'a>(&'a Self, args: serde_json::Value, ctx: &'a mut ToolCtx) -> ToolFut<'a>;
}

/// Capability token that allows tool executors to record file changes.
pub struct ChangeRecorder { @ tools/src/change_recording.rs:45
}

impl ChangeRecorder {
    pub fn record_created(&self, path: PathBuf); @ tools/src/change_recording.rs:113
    pub fn record_modified(&self, path: PathBuf); @ tools/src/change_recording.rs:121
    pub fn record_stats(&self, path: PathBuf, additions: u32, deletions: u32); @ tools/src/change_recording.rs:129
}

/// RAII guard that kills a child process (and its process group on Unix) on drop.
pub struct ChildGuard { @ tools/src/process.rs:8
}

impl ChildGuard {
    pub fn child_mut(&mut self) -> &mut tokio::process::Child; @ tools/src/process.rs:18
    pub fn disarm(&mut self); @ tools/src/process.rs:22
    pub fn new(child: tokio::process::Child) -> Self; @ tools/src/process.rs:14
}

impl Drop for ChildGuard {
    fn drop(&mut self);
}

/// Command blacklist validator.
pub struct CommandBlacklist { @ tools/src/command_blacklist.rs:80
}

impl CommandBlacklist {
    /// Create a new blacklist from pattern-reason pairs.
    pub fn new(patterns: &[(&str, &str)]) -> Result<Self, ToolError>; @ tools/src/command_blacklist.rs:88
    /// Validate a command against the blacklist.
    pub fn validate(&self, command: &str) -> Result<(), ToolError>; @ tools/src/command_blacklist.rs:115
    /// Create a blacklist with default patterns.
    pub fn with_defaults() -> Result<Self, ToolError>; @ tools/src/command_blacklist.rs:105
}

/// Confirmation request for a tool call.
pub struct ConfirmationRequest { @ tools/src/lib.rs:95
    pub tool_call_id: String,
    pub tool_name: String,
    pub summary: String,
    /// Optional user-facing reason provided by the model for escalation prompts.
    pub reason: Option<String>,
    pub risk_level: RiskLevel,
    pub arguments: serde_json::Value,
    /// Homoglyph warnings detected in tool arguments.
    /// Existence of warnings proves analysis was performed and found issues.
    pub warnings: Vec<forge_types::HomoglyphWarning>,
}

/// Detected shell for command execution.
pub struct DetectedShell { @ tools/src/shell.rs:9
    /// Path or name of the shell binary.
    pub binary: std::path::PathBuf,
    /// Arguments to pass before the command (e.g., `["-c"]` or `["/C"]`).
    pub args: Vec<String>,
    /// Human-readable name for logging.
    pub name: String,
}

impl Display for DetectedShell {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

/// Stats for a single file change (lines added/removed).
pub struct DiffStats { @ tools/src/change_recording.rs:21
    pub additions: u32,
    pub deletions: u32,
}

/// Sanitizes environment variables before executing commands.
pub struct EnvSanitizer { @ tools/src/lib.rs:433
}

impl EnvSanitizer {
    pub fn new(patterns: &[String]) -> Result<Self, ToolError>; @ tools/src/lib.rs:438
    pub fn sanitize_env(&self, env: &[(String, String)]) -> Vec<(String, String)>; @ tools/src/lib.rs:458
}

/// File SHA cache entry for stale file detection.
pub struct FileCacheEntry { @ tools/src/lib.rs:341
    pub sha256: [u8; 32],
    pub read_at: std::time::SystemTime,
}

pub struct FileContent { @ tools/src/lp1.rs:66
    pub lines: Vec<String>,
    pub final_newline: bool,
    pub eol_kind: Option<EolKind>,
}

pub struct FilePatch { @ tools/src/lp1.rs:11
    pub path: String,
    pub ops: Vec<Op>,
}

pub struct GlobTool { @ tools/src/builtins.rs:81
}

impl ToolExecutor for GlobTool {
    fn name(&self) -> &'static str;
    fn description(&self) -> &'static str;
    fn schema(&self) -> serde_json::Value;
    fn is_side_effecting(&self, _args: &serde_json::Value) -> bool;
    fn reads_user_data(&self, _args: &serde_json::Value) -> bool;
    fn approval_summary(&self, args: &serde_json::Value) -> Result<String, ToolError>;
    fn execute<'a>(&'a Self, args: serde_json::Value, ctx: &'a mut ToolCtx) -> ToolFut<'a>;
}

/// Tool for storing facts in the Librarian's memory.
pub struct MemoryTool { @ tools/src/memory.rs:10
}

impl ToolExecutor for MemoryTool {
    fn name(&self) -> &'static str;
    fn description(&self) -> &'static str;
    fn schema(&self) -> serde_json::Value;
    fn is_side_effecting(&self, _args: &serde_json::Value) -> bool;
    fn risk_level(&self, _args: &serde_json::Value) -> RiskLevel;
    fn approval_summary(&self, args: &serde_json::Value) -> Result<String, ToolError>;
    fn execute<'a>(&'a Self, args: serde_json::Value, ctx: &'a mut ToolCtx) -> ToolFut<'a>;
}

pub struct Patch { @ tools/src/lp1.rs:6
    pub files: Vec<FilePatch>,
}

pub struct PatchError { @ tools/src/lp1.rs:47
    pub message: String,
}

impl Display for PatchError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result;
}

/// Tool-specific limits for `apply_patch`.
pub struct PatchLimits { @ tools/src/lib.rs:401
    pub max_patch_bytes: usize,
}

pub struct PhaseGateTool { @ tools/src/phase_gate.rs:15
}

impl ToolExecutor for PhaseGateTool {
    fn name(&self) -> &'static str;
    fn description(&self) -> &'static str;
    fn schema(&self) -> Value;
    fn is_side_effecting(&self, _args: &Value) -> bool;
    fn requires_approval(&self) -> bool;
    fn risk_level(&self, _args: &Value) -> RiskLevel;
    fn is_hidden(&self) -> bool;
    fn target_provider(&self) -> Option<Provider>;
    fn approval_summary(&self, args: &Value) -> Result<String, ToolError>;
    fn execute<'a>(&'a Self, args: Value, _ctx: &'a mut ToolCtx) -> ToolFut<'a>;
}

/// Policy for tool approval and deny/allow lists.
pub struct Policy { @ tools/src/lib.rs:75
    pub mode: ApprovalMode,
    pub allowlist: std::collections::HashSet<String>,
    pub denylist: std::collections::HashSet<String>,
}

impl Policy {
    pub fn is_allowlisted(&self, tool: &str) -> bool; @ tools/src/lib.rs:83
    pub fn is_denylisted(&self, tool: &str) -> bool; @ tools/src/lib.rs:88
}

/// Prepared command after sandbox policy evaluation.
pub struct PreparedRunCommand { @ tools/src/windows_run.rs:77
}

impl PreparedRunCommand {
    pub fn command(&self) -> &str; @ tools/src/windows_run.rs:93
    pub fn requires_windows_host_sandbox(&self) -> bool; @ tools/src/windows_run.rs:103
    pub fn warning(&self) -> Option<&str>; @ tools/src/windows_run.rs:98
}

/// Tool-specific limits for `read_file`.
pub struct ReadFileLimits { @ tools/src/lib.rs:394
    pub max_file_read_bytes: usize,
    pub max_scan_bytes: usize,
}

pub struct ReadFileTool { @ tools/src/builtins.rs:55
}

impl ReadFileTool {
    pub fn new(limits: ReadFileLimits) -> Self; @ tools/src/builtins.rs:85
}

impl ToolExecutor for ReadFileTool {
    fn name(&self) -> &'static str;
    fn description(&self) -> &'static str;
    fn schema(&self) -> serde_json::Value;
    fn is_side_effecting(&self, _args: &serde_json::Value) -> bool;
    fn reads_user_data(&self, _args: &serde_json::Value) -> bool;
    fn approval_summary(&self, args: &serde_json::Value) -> Result<String, ToolError>;
    fn execute<'a>(&'a Self, args: serde_json::Value, ctx: &'a mut ToolCtx) -> ToolFut<'a>;
}

/// Tool for recalling facts from the Librarian.
pub struct RecallTool { @ tools/src/recall.rs:14
}

impl ToolExecutor for RecallTool {
    fn name(&self) -> &'static str;
    fn description(&self) -> &'static str;
    fn schema(&self) -> serde_json::Value;
    fn is_side_effecting(&self, _args: &serde_json::Value) -> bool;
    fn approval_summary(&self, args: &serde_json::Value) -> Result<String, ToolError>;
    fn execute<'a>(&'a Self, args: serde_json::Value, ctx: &'a mut ToolCtx) -> ToolFut<'a>;
}

pub struct RunCommandTool { @ tools/src/builtins.rs:68
}

impl RunCommandTool {
    pub fn new(shell: super::DetectedShell, run_policy: RunSandboxPolicy) -> Self; @ tools/src/builtins.rs:75
}

impl ToolExecutor for RunCommandTool {
    fn name(&self) -> &'static str;
    fn description(&self) -> &'static str;
    fn schema(&self) -> serde_json::Value;
    fn is_side_effecting(&self, _args: &serde_json::Value) -> bool;
    fn requires_approval(&self) -> bool;
    fn risk_level(&self, _args: &serde_json::Value) -> RiskLevel;
    fn approval_summary(&self, args: &serde_json::Value) -> Result<String, ToolError>;
    fn execute<'a>(&'a Self, args: serde_json::Value, ctx: &'a mut ToolCtx) -> ToolFut<'a>;
}

/// Aggregate run sandbox policy (platform-specific sub-policies).
pub struct RunSandboxPolicy { @ tools/src/windows_run.rs:71
    pub windows: WindowsRunSandboxPolicy,
}

/// Filesystem sandbox configuration and validation.
pub struct Sandbox { @ tools/src/sandbox.rs:13
}

impl Sandbox {
    pub fn allow_absolute(&self) -> bool; @ tools/src/sandbox.rs:79
    pub fn allowed_roots(&self) -> &[PathBuf]; @ tools/src/sandbox.rs:73
    /// Validate a resolved path (absolute) against sandbox rules.
    pub fn ensure_path_allowed(&self, path: &Path) -> Result<PathBuf, ToolError>; @ tools/src/sandbox.rs:303
    pub fn new(allowed_roots: Vec<PathBuf>, denied_patterns: Vec<String>, allow_absolute: bool) -> Result<Self, ToolError>; @ tools/src/sandbox.rs:33
    /// Validate and resolve a path within the sandbox.
    pub fn resolve_path(&self, path: &str, working_dir: &Path) -> Result<PathBuf, ToolError>; @ tools/src/sandbox.rs:107
    /// Validate and resolve a path for file creation, allowing non-existent directories.
    pub fn resolve_path_for_create(&self, path: &str, working_dir: &Path) -> Result<PathBuf, ToolError>; @ tools/src/sandbox.rs:191
    /// Post-creation validation for TOCTOU mitigation.
    pub fn validate_created_parent(&self, path: &Path) -> Result<(), ToolError>; @ tools/src/sandbox.rs:339
    pub fn working_dir(&self) -> PathBuf; @ tools/src/sandbox.rs:84
}

pub struct SearchTool { @ tools/src/search.rs:49
}

impl SearchTool {
    pub fn new(config: SearchToolConfig) -> Self; @ tools/src/search.rs:56
}

impl ToolExecutor for SearchTool {
    fn name(&self) -> &'static str;
    fn description(&self) -> &'static str;
    fn schema(&self) -> serde_json::Value;
    fn is_side_effecting(&self, _args: &serde_json::Value) -> bool;
    fn reads_user_data(&self, _args: &serde_json::Value) -> bool;
    fn risk_level(&self, _args: &serde_json::Value) -> RiskLevel;
    fn approval_summary(&self, args: &serde_json::Value) -> Result<String, ToolError>;
    fn execute<'a>(&'a Self, args: serde_json::Value, ctx: &'a mut ToolCtx) -> ToolFut<'a>;
}

pub struct SearchToolConfig { @ tools/src/search.rs:24
    pub binary: String,
    pub fallback_binary: String,
    pub default_timeout_ms: u64,
    pub default_max_results: usize,
    pub max_matches_per_file: usize,
    pub max_files: usize,
    pub max_file_size_bytes: u64,
}

impl Default for SearchToolConfig {
    fn default() -> Self;
}

/// Runtime secret redactor built from environment variables.
pub struct SecretRedactor { @ tools/src/security.rs:50
}

impl SecretRedactor {
    /// Build redactor from environment (AUTHORITY BOUNDARY per IFA-7).
    pub fn from_env() -> Self; @ tools/src/security.rs:69
    /// Returns true if any secrets were detected in the environment.
    pub fn has_secrets(&self) -> bool; @ tools/src/security.rs:143
    /// Redact all known secret values from input.
    pub fn redact<'a>(&self, input: &'a str) -> std::borrow::Cow<'a, str>; @ tools/src/security.rs:110
    /// Returns the number of unique secrets detected.
    pub fn secret_count(&self) -> usize; @ tools/src/security.rs:150
}

impl Debug for SecretRedactor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

/// Shared batch-level tool context.
pub struct SharedToolCtx { @ tools/src/lib.rs:374
    pub sandbox: sandbox::Sandbox,
    pub output_tx: mpsc::Sender<ToolEvent>,
    pub default_timeout: std::time::Duration,
    pub max_output_bytes: usize,
    pub initial_capacity_bytes: usize,
    pub env_sanitizer: EnvSanitizer,
    pub file_cache: std::sync::Arc<tokio::sync::Mutex<ToolFileCache>>,
}

/// Shell configuration for command execution.
pub struct ShellConfig { @ tools/src/config.rs:22
    /// Override shell binary (e.g., "pwsh", "bash", "/usr/local/bin/fish").
    pub binary: Option<String>,
    /// Override shell args (e.g., `["-c"]` or `["/C"]`).
    pub args: Option<Vec<String>>,
}

/// Per-call tool context.
pub struct ToolCtx { @ tools/src/lib.rs:351
    pub sandbox: sandbox::Sandbox,
    pub abort: futures_util::future::AbortHandle,
    pub output_tx: mpsc::Sender<ToolEvent>,
    pub default_timeout: std::time::Duration,
    pub max_output_bytes: usize,
    pub available_capacity_bytes: usize,
    pub tool_call_id: String,
    pub allow_truncation: bool,
    pub working_dir: std::path::PathBuf,
    pub env_sanitizer: EnvSanitizer,
    pub file_cache: std::sync::Arc<tokio::sync::Mutex<ToolFileCache>>,
    pub turn_changes: change_recording::ChangeRecorder,
    /// The Librarian for fact recall (Context Infinity).
    pub librarian: Option<std::sync::Arc<tokio::sync::Mutex<forge_context::Librarian>>>,
    /// Command blacklist for blocking catastrophic commands.
    pub command_blacklist: CommandBlacklist,
}

/// Per-batch limits for tool execution.
pub struct ToolLimits { @ tools/src/lib.rs:386
    pub max_tool_calls_per_batch: usize,
    pub max_tool_iterations_per_user_turn: u32,
    pub max_tool_args_bytes: usize,
}

/// Tool registry for executors.
pub struct ToolRegistry { @ tools/src/lib.rs:293
}

impl ToolRegistry {
    pub fn definitions(&self) -> Vec<ToolDefinition>; @ tools/src/lib.rs:317
    pub fn is_empty(&self) -> bool; @ tools/src/lib.rs:334
    pub fn lookup(&self, name: &str) -> Result<&dyn ToolExecutor, ToolError>; @ tools/src/lib.rs:307
    pub fn register(&mut self, executor: Box<dyn ToolExecutor>) -> Result<(), ToolError>; @ tools/src/lib.rs:298
}

/// Aggregated tool settings derived from config.
pub struct ToolSettings { @ tools/src/lib.rs:415
    pub limits: ToolLimits,
    pub read_limits: ReadFileLimits,
    pub patch_limits: PatchLimits,
    pub search: SearchToolConfig,
    pub webfetch: WebFetchToolConfig,
    pub shell: DetectedShell,
    pub timeouts: ToolTimeouts,
    pub max_output_bytes: usize,
    pub policy: Policy,
    pub sandbox: sandbox::Sandbox,
    pub env_sanitizer: EnvSanitizer,
    pub command_blacklist: CommandBlacklist,
    pub run_policy: RunSandboxPolicy,
}

/// Tool-specific timeout configuration.
pub struct ToolTimeouts { @ tools/src/lib.rs:407
    pub default_timeout: std::time::Duration,
    pub file_operations_timeout: std::time::Duration,
    pub shell_commands_timeout: std::time::Duration,
}

/// Non-empty summary of changes made during a turn.
pub struct TurnChangeSummary { @ tools/src/change_recording.rs:58
}

impl TurnChangeSummary {
    pub fn into_message(self) -> NonEmptyString; @ tools/src/change_recording.rs:142
}

/// Proof that a user turn is active (IFA ยง10 capability token).
pub struct TurnContext { @ tools/src/change_recording.rs:37
}

impl TurnContext {
    /// Consume the turn and produce a report with the raw path sets.
    pub fn finish(self, working_dir: &Path) -> (TurnChangeReport, BTreeSet<PathBuf>, BTreeSet<PathBuf>); @ tools/src/change_recording.rs:96
    pub fn new() -> Self; @ tools/src/change_recording.rs:70
    pub fn new_for_recovery() -> Self; @ tools/src/change_recording.rs:77
    pub fn new_for_tests() -> Self; @ tools/src/change_recording.rs:82
    pub fn recorder(&self) -> ChangeRecorder; @ tools/src/change_recording.rs:87
}

impl Default for TurnContext {
    fn default() -> Self;
}

/// `WebFetch` tool executor.
pub struct WebFetchTool { @ tools/src/webfetch/mod.rs:243
}

impl WebFetchTool {
    pub fn new(config: WebFetchToolConfig) -> Self; @ tools/src/webfetch/mod.rs:249
}

impl ToolExecutor for WebFetchTool {
    fn name(&self) -> &'static str;
    fn description(&self) -> &'static str;
    fn schema(&self) -> serde_json::Value;
    fn is_side_effecting(&self, _args: &serde_json::Value) -> bool;
    fn requires_approval(&self) -> bool;
    fn risk_level(&self, _args: &serde_json::Value) -> RiskLevel;
    fn approval_summary(&self, args: &serde_json::Value) -> Result<String, ToolError>;
    fn execute<'a>(&'a Self, args: serde_json::Value, ctx: &'a mut ToolCtx) -> ToolFut<'a>;
}

/// Configuration for the `WebFetch` tool.
pub struct WebFetchToolConfig { @ tools/src/webfetch/mod.rs:217
    pub user_agent: Option<String>,
    pub timeout_seconds: u32,
    pub max_redirects: u32,
    pub default_max_chunk_tokens: u32,
    pub max_download_bytes: u64,
    pub cache_dir: Option<std::path::PathBuf>,
    pub cache_ttl_days: u32,
}

impl Default for WebFetchToolConfig {
    fn default() -> Self;
}

/// Windows-specific run sandbox policy.
pub struct WindowsRunSandboxPolicy { @ tools/src/windows_run.rs:51
    pub enabled: bool,
    pub enforce_powershell_only: bool,
    pub block_network: bool,
    pub fallback_mode: RunSandboxFallbackMode,
}

impl Default for WindowsRunSandboxPolicy {
    fn default() -> Self;
}

pub struct WriteFileTool { @ tools/src/builtins.rs:65
}

impl ToolExecutor for WriteFileTool {
    fn name(&self) -> &'static str;
    fn description(&self) -> &'static str;
    fn schema(&self) -> serde_json::Value;
    fn is_side_effecting(&self, _args: &serde_json::Value) -> bool;
    fn approval_summary(&self, args: &serde_json::Value) -> Result<String, ToolError>;
    fn execute<'a>(&'a Self, args: serde_json::Value, ctx: &'a mut ToolCtx) -> ToolFut<'a>;
}

/// Approval decision from the user.
pub enum ApprovalDecision { @ tools/src/lib.rs:56
    ApproveAll,
    ApproveSelected(Vec<String>),
    DenyAll,
}

/// Approval mode policy.
pub enum ApprovalMode { @ tools/src/lib.rs:64
    /// Auto-approve most tools, only prompt for high-risk operations.
    Permissive,
    /// Prompt for any side-effecting tool unless allowlisted.
    Default,
    /// Deny all tools unless explicitly allowlisted.
    Strict,
}

/// Denial reason for sandbox or policy.
pub enum DenialReason { @ tools/src/lib.rs:199
    Denylisted {
        tool: String,
    },
    PathOutsideSandbox {
        attempted: std::path::PathBuf,
        resolved: std::path::PathBuf,
    },
    DeniedPatternMatched {
        attempted: std::path::PathBuf,
        pattern: String,
    },
    LimitsExceeded {
        message: String,
    },
    CommandBlacklisted {
        command: String,
        reason: String,
    },
}

impl Display for DenialReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

pub enum EolKind { @ tools/src/lp1.rs:60
    Lf,
    CrLf,
}

pub enum KillOutcome { @ tools/src/process.rs:52
    NotRunning,
    Killed,
}

pub enum Op { @ tools/src/lp1.rs:17
    Replace {
        occ: Option<usize>,
        find: Vec<String>,
        replace: Vec<String>,
    },
    InsertAfter {
        occ: Option<usize>,
        find: Vec<String>,
        insert: Vec<String>,
    },
    InsertBefore {
        occ: Option<usize>,
        find: Vec<String>,
        insert: Vec<String>,
    },
    Erase {
        occ: Option<usize>,
        find: Vec<String>,
    },
    Append {
        block: Vec<String>,
    },
    Prepend {
        block: Vec<String>,
    },
    SetFinalNewline(bool),
}

/// Planned disposition for a tool call.
pub enum PlannedDisposition { @ tools/src/lib.rs:139
    ExecuteNow,
    RequiresConfirmation(ConfirmationRequest),
    PreResolved(forge_types::ToolResult),
}

/// Risk level for approval prompts.
pub enum RiskLevel { @ tools/src/lib.rs:48
    Low,
    Medium,
    High,
}

/// Behavior when Windows sandbox prerequisites are unavailable.
pub enum RunSandboxFallbackMode { @ tools/src/windows_run.rs:40
    /// Require explicit opt-in per call before allowing unsandboxed execution.
    Prompt,
    /// Never allow unsandboxed execution.
    Deny,
    /// Automatically allow unsandboxed execution with a warning.
    AllowWithWarning,
}

/// Error types for tool execution.
pub enum ToolError { @ tools/src/lib.rs:176
    BadArgs {
        message: String,
    },
    Timeout {
        tool: String,
        elapsed: std::time::Duration,
    },
    SandboxViolation(DenialReason),
    ExecutionFailed {
        tool: String,
        message: String,
    },
    UnknownTool {
        name: String,
    },
    DuplicateTool {
        name: String,
    },
    DuplicateToolCallId {
        id: String,
    },
    PatchFailed {
        file: std::path::PathBuf,
        message: String,
    },
    StaleFile {
        file: std::path::PathBuf,
        reason: String,
    },
}

/// Tool events for streaming output.
pub enum ToolEvent { @ tools/src/lib.rs:147
    Started {
        tool_call_id: String,
        tool_name: String,
    },
    /// A subprocess-backed tool spawned an OS process (best-effort metadata).
    ProcessSpawned {
        tool_call_id: String,
        pid: u32,
        process_started_at_unix_ms: Option<i64>,
    },
    StdoutChunk {
        tool_call_id: String,
        chunk: String,
    },
    StderrChunk {
        tool_call_id: String,
        chunk: String,
    },
    Completed {
        tool_call_id: String,
    },
}

/// Result of finishing a turn.
pub enum TurnChangeReport { @ tools/src/change_recording.rs:51
    NoChanges,
    Changes(TurnChangeSummary),
}
```

