# Forge API Digest

Auto-generated from rustdoc JSON. Public API surface for all workspace crates.

## forge-types

```rust
/// Analyze a string for mixed-script content (MECHANISM per IFA-8).
pub fn detect_mixed_script(input: &str, field_name: &str) -> Option<HomoglyphWarning>; @ types/src/confusables.rs:77

/// Sanitize text for safe terminal display.
pub fn sanitize_terminal_text(input: &str) -> std::borrow::Cow<'_, str>; @ types/src/sanitize.rs:56

/// Strip invisible Unicode characters used for steganographic prompt injection.
pub fn strip_steganographic_chars(input: &str) -> std::borrow::Cow<'_, str>; @ types/src/sanitize.rs:292

/// Truncate a string to a maximum length, adding `...` if needed.
pub fn truncate_with_ellipsis(raw: &str, max: usize) -> String; @ types/src/text.rs:9

/// API-reported token usage from provider responses.
pub struct ApiUsage { @ types/src/lib.rs:1230
    /// Total input tokens (includes cached tokens).
    pub input_tokens: u32,
    /// Input tokens read from cache (cache hits).
    pub cache_read_tokens: u32,
    /// Input tokens written to cache (cache misses that were cached).
    pub cache_creation_tokens: u32,
    /// Output tokens generated by the model.
    pub output_tokens: u32,
}

impl ApiUsage {
    /// Cache hit percentage (0-100).
    pub fn cache_hit_percentage(&self) -> f64; @ types/src/lib.rs:1270
    pub const fn has_data(&self) -> bool; @ types/src/lib.rs:1264
    /// Merge another usage into this one (for aggregation across multiple API calls).
    pub fn merge(&mut self, other: &ApiUsage); @ types/src/lib.rs:1252
    /// Input tokens that were not read from cache.
    pub const fn non_cached_input_tokens(&self) -> u32; @ types/src/lib.rs:1247
}

pub struct AssistantMessage { @ types/src/lib.rs:1440
}

impl AssistantMessage {
    pub fn content(&self) -> &str; @ types/src/lib.rs:1458
    pub fn model(&self) -> &ModelName; @ types/src/lib.rs:1468
    pub fn new(model: ModelName, content: NonEmptyString) -> Self; @ types/src/lib.rs:1449
    pub fn provider(&self) -> Provider; @ types/src/lib.rs:1463
}

/// A message with an associated cache hint for API serialization.
pub struct CacheableMessage { @ types/src/lib.rs:1621
    pub message: Message,
    pub cache_hint: CacheHint,
}

impl CacheableMessage {
    pub fn cached(message: Message) -> Self; @ types/src/lib.rs:1641
    pub fn new(message: Message, cache_hint: CacheHint) -> Self; @ types/src/lib.rs:1628
    pub fn plain(message: Message) -> Self; @ types/src/lib.rs:1636
}

pub struct EmptyStringError { @ types/src/lib.rs:68
}

pub struct EnumParseError { @ types/src/lib.rs:340
}

impl EnumParseError {
    pub const fn expected(&self) -> &'static [&'static str]; @ types/src/lib.rs:367
    pub const fn kind(&self) -> EnumKind; @ types/src/lib.rs:357
    pub fn new<impl Into<String>: Into<String>>(kind: EnumKind, raw: impl Into<String>, expected: &'static [&'static str]) -> Self; @ types/src/lib.rs:348
    pub fn raw(&self) -> &str; @ types/src/lib.rs:362
}

/// Proof that homoglyph analysis was performed and detected suspicious content.
pub struct HomoglyphWarning { @ types/src/confusables.rs:23
    /// The field name where mixed scripts were detected (e.g., "url", "command").
    pub field_name: String,
    /// A truncated snippet of the suspicious content for display.
    pub snippet: String,
    /// The scripts detected in the content.
    pub scripts: Vec<unicode_script::Script>,
}

impl HomoglyphWarning {
    /// Format scripts for human-readable display.
    pub fn scripts_display(&self) -> String; @ types/src/confusables.rs:37
}

pub struct ModelName { @ types/src/lib.rs:619
}

impl ModelName {
    pub fn as_str(&self) -> &str; @ types/src/lib.rs:666
    pub const fn from_predefined(model: PredefinedModel) -> Self; @ types/src/lib.rs:653
    pub fn parse(provider: Provider, raw: &str) -> Result<Self, ModelParseError>; @ types/src/lib.rs:626
    pub fn predefined(&self) -> PredefinedModel; @ types/src/lib.rs:671
    pub const fn provider(&self) -> Provider; @ types/src/lib.rs:661
}

impl Display for ModelName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

impl Deserialize<'de> for ModelName {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where D: serde::Deserializer<'de>;
}

/// **Note**: This only validates non-emptiness, not whitespace...
pub struct NonEmptyStaticStr { @ types/src/lib.rs:146
}

impl NonEmptyStaticStr {
    pub const fn as_str(self) -> &'static str; @ types/src/lib.rs:156
    pub const fn new(value: &'static str) -> Self; @ types/src/lib.rs:150
}

impl TryFrom<NonEmptyStaticStr> for NonEmptyStaticStr {
    fn try_from(value: NonEmptyStaticStr) -> Result<Self, Self::Error>;
}

/// This type enforces the invariant that the contained string is never empty
/// (or whitespace-only) after trimming. Validation occurs at construction time,
/// so all operations on an existing `NonEmptyStri...
pub struct NonEmptyString { @ types/src/lib.rs:64
}

impl NonEmptyString {
    pub fn append<impl AsRef<str>: AsRef<str>>(self, suffix: impl AsRef<str>) -> Self; @ types/src/lib.rs:92
    pub fn as_str(&self) -> &str; @ types/src/lib.rs:98
    pub fn into_inner(self) -> String; @ types/src/lib.rs:103
    pub fn new<impl Into<String>: Into<String>>(value: impl Into<String>) -> Result<Self, EmptyStringError>; @ types/src/lib.rs:71
    /// The `content` argument already satisfies the trim invariant...
    pub fn prefixed(prefix: NonEmptyStaticStr, separator: &str, content: &NonEmptyString) -> Self; @ types/src/lib.rs:82
}

impl TryFrom<String> for NonEmptyString {
    fn try_from(value: String) -> Result<Self, Self::Error>;
}

impl TryFrom<&str> for NonEmptyString {
    fn try_from(value: &str) -> Result<Self, Self::Error>;
}

impl From<NonEmptyString> for NonEmptyString {
    fn from(value: NonEmptyString) -> Self;
}

impl Deref for NonEmptyString {
    fn deref(&self) -> &Self::Target;
}

impl AsRef<str> for NonEmptyString {
    fn as_ref(&self) -> &str;
}

impl TryFrom<NonEmptyStaticStr> for NonEmptyString {
    fn try_from(value: NonEmptyStaticStr) -> Result<Self, Self::Error>;
}

pub struct OpenAIRequestOptions { @ types/src/lib.rs:964
}

impl OpenAIRequestOptions {
    pub fn new(reasoning_effort: OpenAIReasoningEffort, reasoning_summary: OpenAIReasoningSummary, verbosity: OpenAITextVerbosity, truncation: OpenAITruncation) -> Self; @ types/src/lib.rs:973
    pub fn reasoning_effort(self) -> OpenAIReasoningEffort; @ types/src/lib.rs:988
    pub fn reasoning_summary(self) -> OpenAIReasoningSummary; @ types/src/lib.rs:993
    pub fn truncation(self) -> OpenAITruncation; @ types/src/lib.rs:1003
    pub fn verbosity(self) -> OpenAITextVerbosity; @ types/src/lib.rs:998
}

impl Default for OpenAIRequestOptions {
    fn default() -> Self;
}

/// This type enforces the invariant that standalone `\r` characters are
/// normalized to `\n`. The normalization occurs at construction time
/// (single Authority Boundary per IFA-7).
pub struct PersistableContent { @ types/src/lib.rs:198
}

impl PersistableContent {
    pub fn as_str(&self) -> &str; @ types/src/lib.rs:244
    pub fn into_inner(self) -> String; @ types/src/lib.rs:249
    pub fn is_empty(&self) -> bool; @ types/src/lib.rs:254
    pub fn len(&self) -> usize; @ types/src/lib.rs:259
    /// Create persistable content by normalizing line endings.
    pub fn new<impl Into<String>: Into<String>>(input: impl Into<String>) -> Self; @ types/src/lib.rs:206
}

impl AsRef<str> for PersistableContent {
    fn as_ref(&self) -> &str;
}

impl From<PersistableContent> for PersistableContent {
    fn from(value: PersistableContent) -> Self;
}

impl Deref for PersistableContent {
    fn deref(&self) -> &Self::Target;
}

impl Display for PersistableContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

/// Opaque wrapper for secret strings that prevents accidental disclosure.
pub struct SecretString { @ types/src/lib.rs:708
}

impl SecretString {
    /// Deliberately named accessor that makes secret exposure auditable.
    pub fn expose_secret(&self) -> &str; @ types/src/lib.rs:718
    pub fn new(value: String) -> Self; @ types/src/lib.rs:712
}

impl Debug for SecretString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

pub struct SystemMessage { @ types/src/lib.rs:1398
}

impl SystemMessage {
    pub fn content(&self) -> &str; @ types/src/lib.rs:1413
    pub fn new(content: NonEmptyString) -> Self; @ types/src/lib.rs:1405
}

/// Validated thinking budget for extended reasoning.
pub struct ThinkingBudget { @ types/src/lib.rs:1049
}

impl ThinkingBudget {
    pub const fn as_u32(self) -> u32; @ types/src/lib.rs:1062
    pub fn new(value: u32) -> Result<Self, OutputLimitsError>; @ types/src/lib.rs:1054
}

/// Provider reasoning/thinking content (Claude extended thinking, Gemini thinking, etc.).
pub struct ThinkingMessage { @ types/src/lib.rs:1479
}

impl ThinkingMessage {
    pub fn content(&self) -> &str; @ types/src/lib.rs:1511
    pub const fn has_signature(&self) -> bool; @ types/src/lib.rs:1521
    pub fn model(&self) -> &ModelName; @ types/src/lib.rs:1531
    pub fn new(model: ModelName, content: NonEmptyString) -> Self; @ types/src/lib.rs:1491
    pub fn provider(&self) -> Provider; @ types/src/lib.rs:1526
    pub const fn signature_state(&self) -> &ThoughtSignatureState; @ types/src/lib.rs:1516
    pub fn with_signature(model: ModelName, content: NonEmptyString, signature: String) -> Self; @ types/src/lib.rs:1501
}

/// Opaque provider signature for thinking/tool-call replay.
pub struct ThoughtSignature { @ types/src/lib.rs:1150
}

impl ThoughtSignature {
    pub fn as_str(&self) -> &str; @ types/src/lib.rs:1159
    pub fn new<impl Into<String>: Into<String>>(raw: impl Into<String>) -> Self; @ types/src/lib.rs:1154
    pub fn push_str(&mut self, delta: &str); @ types/src/lib.rs:1163
}

impl From<String> for ThoughtSignature {
    fn from(value: String) -> Self;
}

impl From<&str> for ThoughtSignature {
    fn from(value: &str) -> Self;
}

pub struct ToolCall { @ types/src/lib.rs:1312
    /// Unique identifier for this tool call (used to match results).
    pub id: String,
    /// The name of the tool being called.
    pub name: String,
    /// The arguments to pass to the tool, as parsed JSON.
    pub arguments: serde_json::Value,
    /// Thought signature state for providers that require it (Gemini).
    pub thought_signature: ThoughtSignatureState,
}

impl ToolCall {
    pub fn new<impl Into<String>: Into<String>, impl Into<String>: Into<String>>(id: impl Into<String>, name: impl Into<String>, arguments: serde_json::Value) -> Self; @ types/src/lib.rs:1324
    pub fn new_signed<impl Into<String>: Into<String>, impl Into<String>: Into<String>>(id: impl Into<String>, name: impl Into<String>, arguments: serde_json::Value, thought_signature: ThoughtSignature) -> Self; @ types/src/lib.rs:1337
    pub const fn signature_state(&self) -> &ThoughtSignatureState; @ types/src/lib.rs:1352
}

pub struct ToolDefinition { @ types/src/lib.rs:1279
    /// The name of the tool (function name).
    pub name: String,
    /// A description of what the tool does.
    pub description: String,
    /// JSON Schema describing the tool's parameters.
    pub parameters: serde_json::Value,
    /// Whether this tool is hidden from UI rendering.
    /// Hidden tools execute normally but are invisible to the user.
    pub hidden: bool,
    /// If set, this tool is only included in the tool manifest for the specified provider.
    pub provider: Option<Provider>,
}

impl ToolDefinition {
    pub fn new<impl Into<String>: Into<String>, impl Into<String>: Into<String>>(name: impl Into<String>, description: impl Into<String>, parameters: serde_json::Value) -> Self; @ types/src/lib.rs:1296
}

pub struct ToolResult { @ types/src/lib.rs:1358
    /// The ID of the tool call this result is for.
    pub tool_call_id: String,
    /// The name of the tool that was called (needed for Gemini's functionResponse).
    pub tool_name: String,
    /// The result content (typically a string or JSON).
    pub content: String,
    /// Whether the tool execution resulted in an error.
    pub is_error: bool,
}

impl ToolResult {
    pub fn error<impl Into<String>: Into<String>, impl Into<String>: Into<String>, impl Into<String>: Into<String>>(tool_call_id: impl Into<String>, tool_name: impl Into<String>, error: impl Into<String>) -> Self; @ types/src/lib.rs:1383
    pub fn success<impl Into<String>: Into<String>, impl Into<String>: Into<String>, impl Into<String>: Into<String>>(tool_call_id: impl Into<String>, tool_name: impl Into<String>, content: impl Into<String>) -> Self; @ types/src/lib.rs:1370
}

pub struct UserMessage { @ types/src/lib.rs:1419
}

impl UserMessage {
    pub fn content(&self) -> &str; @ types/src/lib.rs:1434
    pub fn new(content: NonEmptyString) -> Self; @ types/src/lib.rs:1426
}

/// API key with provider tagging. Inner values are opaque [`SecretString`]s
/// to prevent credential disclosure in logs or error messages.
pub enum ApiKey { @ types/src/lib.rs:735
    Claude(SecretString),
    OpenAI(SecretString),
    Gemini(SecretString),
}

impl ApiKey {
    /// Construct a Claude API key.
    pub fn claude<impl Into<String>: Into<String>>(key: impl Into<String>) -> Self; @ types/src/lib.rs:754
    /// Access the raw key value. Named to make exposure auditable.
    pub fn expose_secret(&self) -> &str; @ types/src/lib.rs:781
    /// Construct a Gemini API key.
    pub fn gemini<impl Into<String>: Into<String>>(key: impl Into<String>) -> Self; @ types/src/lib.rs:766
    /// Construct an OpenAI API key.
    pub fn openai<impl Into<String>: Into<String>>(key: impl Into<String>) -> Self; @ types/src/lib.rs:760
    pub fn provider(&self) -> Provider; @ types/src/lib.rs:771
}

impl Debug for ApiKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

/// Hint for whether content should be cached by the provider.
pub enum CacheHint { @ types/src/lib.rs:1025
    /// No caching preference - provider uses default behavior.
    Default,
    /// Content is stable and should be cached if supported.
    Ephemeral,
}

pub enum EnumKind { @ types/src/lib.rs:309
    Provider,
    PredefinedModel,
    OpenAIReasoningEffort,
    OpenAIReasoningSummary,
    OpenAITextVerbosity,
    OpenAITruncation,
}

impl EnumKind {
    pub const fn as_str(self) -> &'static str; @ types/src/lib.rs:320
}

impl Display for EnumKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

/// A complete message.
pub enum Message { @ types/src/lib.rs:1540
    System(SystemMessage),
    User(UserMessage),
    Assistant(AssistantMessage),
    /// Provider reasoning/thinking content.
    Thinking(ThinkingMessage),
    /// A tool call requested by the assistant.
    ToolUse(ToolCall),
    /// The result of a tool call execution.
    ToolResult(ToolResult),
}

impl Message {
    pub fn assistant(model: ModelName, content: NonEmptyString) -> Self; @ types/src/lib.rs:1568
    pub fn content(&self) -> &str; @ types/src/lib.rs:1607
    pub fn role_str(&self) -> &'static str; @ types/src/lib.rs:1597
    pub fn system(content: NonEmptyString) -> Self; @ types/src/lib.rs:1554
    pub fn thinking(model: ModelName, content: NonEmptyString) -> Self; @ types/src/lib.rs:1573
    pub fn thinking_with_signature(model: ModelName, content: NonEmptyString, signature: String) -> Self; @ types/src/lib.rs:1578
    pub fn tool_result(result: ToolResult) -> Self; @ types/src/lib.rs:1592
    pub fn tool_use(call: ToolCall) -> Self; @ types/src/lib.rs:1587
    pub fn try_user<impl Into<String>: Into<String>>(content: impl Into<String>) -> Result<Self, EmptyStringError>; @ types/src/lib.rs:1563
    pub fn user(content: NonEmptyString) -> Self; @ types/src/lib.rs:1559
}

pub enum ModelParseError { @ types/src/lib.rs:605
    Empty,
    ClaudePrefix(String),
    OpenAIMinimum(String),
    GeminiPrefix(String),
    UnknownModel(String),
}

pub enum OpenAIReasoningEffort { @ types/src/lib.rs:798
    Disabled,
    Low,
    Medium,
    High,
    XHigh,
}

impl OpenAIReasoningEffort {
    pub const fn as_str(self) -> &'static str; @ types/src/lib.rs:832
    pub fn parse(value: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:808
}

pub enum OpenAIReasoningSummary { @ types/src/lib.rs:844
    Disabled,
    Auto,
    Concise,
    Detailed,
}

impl OpenAIReasoningSummary {
    pub const fn as_str(self) -> &'static str; @ types/src/lib.rs:876
    pub fn parse(value: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:853
}

pub enum OpenAITextVerbosity { @ types/src/lib.rs:887
    Low,
    Medium,
    High,
}

impl OpenAITextVerbosity {
    pub const fn as_str(self) -> &'static str; @ types/src/lib.rs:917
    pub fn parse(value: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:895
}

pub enum OpenAITruncation { @ types/src/lib.rs:927
    Auto,
    Disabled,
}

impl OpenAITruncation {
    pub const fn as_str(self) -> &'static str; @ types/src/lib.rs:955
    pub fn parse(value: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:934
}

/// Validated output configuration that guarantees invariants.
pub enum OutputLimits { @ types/src/lib.rs:1085
    Standard {
        max_output_tokens: u32,
    },
    WithThinking {
        max_output_tokens: u32,
        thinking_budget: ThinkingBudget,
    },
}

impl OutputLimits {
    pub const fn has_thinking(&self) -> bool; @ types/src/lib.rs:1143
    pub const fn max_output_tokens(&self) -> u32; @ types/src/lib.rs:1123
    /// Create output limits without thinking.
    pub const fn new(max_output_tokens: u32) -> Self; @ types/src/lib.rs:1098
    pub const fn thinking(&self) -> ThinkingState; @ types/src/lib.rs:1133
    /// Create output limits with thinking enabled.
    pub fn with_thinking(max_output_tokens: u32, thinking_budget: u32) -> Result<Self, OutputLimitsError>; @ types/src/lib.rs:1105
}

/// Error when trying to construct invalid output limits.
pub enum OutputLimitsError { @ types/src/lib.rs:1040
    ThinkingBudgetTooLarge {
        budget: u32,
        max_output: u32,
    },
    ThinkingBudgetTooSmall,
}

pub enum PredefinedModel { @ types/src/lib.rs:459
    ClaudeOpus,
    ClaudeHaiku,
    Gpt52Pro,
    Gpt52,
    GeminiPro,
    GeminiFlash,
}

impl PredefinedModel {
    pub const fn all() -> &'static [PredefinedModel]; @ types/src/lib.rs:493
    pub const fn display_name(self) -> &'static str; @ types/src/lib.rs:505
    pub const fn firm_name(self) -> &'static str; @ types/src/lib.rs:529
    pub fn from_model_id(raw: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:563
    pub fn from_provider_and_id(provider: Provider, raw: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:579
    pub const fn model_id(self) -> &'static str; @ types/src/lib.rs:538
    pub const fn model_name(self) -> &'static str; @ types/src/lib.rs:517
    pub const fn provider(self) -> Provider; @ types/src/lib.rs:550
    pub fn to_model_name(self) -> ModelName; @ types/src/lib.rs:559
}

pub enum Provider { @ types/src/lib.rs:291
    Claude,
    OpenAI,
    Gemini,
}

impl Provider {
    /// Get all available providers.
    pub fn all() -> &'static [Provider]; @ types/src/lib.rs:453
    pub fn as_str(&self) -> &'static str; @ types/src/lib.rs:374
    /// All available models for this provider.
    pub fn available_models(&self) -> Vec<PredefinedModel>; @ types/src/lib.rs:411
    pub fn default_model(&self) -> ModelName; @ types/src/lib.rs:401
    pub fn display_name(&self) -> &'static str; @ types/src/lib.rs:383
    pub fn env_var(&self) -> &'static str; @ types/src/lib.rs:392
    /// Infer provider from model name prefix.
    pub fn from_model_name(model: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:447
    /// Parse provider from string.
    pub fn parse(s: &str) -> Result<Self, EnumParseError>; @ types/src/lib.rs:425
    /// Parse a model name for this provider.
    pub fn parse_model(&self, raw: &str) -> Result<ModelName, ModelParseError>; @ types/src/lib.rs:420
}

pub enum StreamEvent { @ types/src/lib.rs:1195
    /// Text content delta.
    TextDelta(String),
    /// Provider reasoning content delta (Claude extended thinking or OpenAI reasoning summaries).
    ThinkingDelta(String),
    /// Encrypted thinking signature for API replay (Claude extended thinking).
    ThinkingSignature(String),
    /// Tool call started - emitted when a `tool_use` content block begins.
    ToolCallStart {
        id: String,
        name: String,
        thought_signature: ThoughtSignatureState,
    },
    /// Tool call arguments delta - emitted as JSON arguments stream in.
    ToolCallDelta {
        id: String,
        arguments: String,
    },
    /// API-reported token usage (from `message_start` or `message_delta` events).
    Usage(ApiUsage),
    /// Stream completed.
    Done,
    /// Error occurred.
    Error(String),
}

/// Reason a stream finished.
pub enum StreamFinishReason { @ types/src/lib.rs:1220
    Done,
    Error(String),
}

pub enum ThinkingState { @ types/src/lib.rs:1068
    Disabled,
    Enabled(ThinkingBudget),
}

impl ThinkingState {
    pub const fn is_enabled(self) -> bool; @ types/src/lib.rs:1075
}

pub enum ThoughtSignatureState { @ types/src/lib.rs:1182
    Unsigned,
    Signed(ThoughtSignature),
}

impl ThoughtSignatureState {
    pub const fn is_signed(&self) -> bool; @ types/src/lib.rs:1189
}
```

## forge-providers

```rust
/// Add retry-related headers to a request.
pub fn add_retry_headers(builder: reqwest::RequestBuilder, retry_count: u32, idempotency_key: &str, timeout: Option<std::time::Duration>) -> reqwest::RequestBuilder; @ providers/src/retry.rs:140

/// Calculate retry delay with exponential backoff and jitter.
pub fn calculate_retry_delay(backoff_step: u32, config: &RetryConfig, headers: Option<&reqwest::header::HeaderMap>) -> std::time::Duration; @ providers/src/retry.rs:114

/// Create a cached content object with the system prompt and tools.
pub async fn create_cache(api_key: &str, model: &str, system_prompt: &str, tools: Option<&[forge_types::ToolDefinition]>, ttl_seconds: u32) -> anyhow::Result<GeminiCache>; @ providers/src/lib.rs:2415

pub fn generate_idempotency_key() -> String; @ providers/src/retry.rs:158

pub fn http_client() -> &'static reqwest::Client; @ providers/src/lib.rs:80

pub fn http_client_with_timeout(timeout_secs: u64) -> anyhow::Result<reqwest::Client, reqwest::Error>; @ providers/src/lib.rs:122

/// Parse `Retry-After` or `Retry-After-Ms` headers.
pub fn parse_retry_after(headers: &reqwest::header::HeaderMap) -> Option<std::time::Duration>; @ providers/src/retry.rs:59

pub async fn read_capped_error_body(response: reqwest::Response) -> String; @ providers/src/lib.rs:322

pub async fn send_message(config: &ApiConfig, messages: &[forge_types::CacheableMessage], limits: forge_types::OutputLimits, system_prompt: Option<&str>, tools: Option<&[forge_types::ToolDefinition]>, gemini_cache: Option<&gemini::GeminiCache>, tx: mpsc::Sender<forge_types::StreamEvent>) -> anyhow::Result<()>; @ providers/src/lib.rs:491

pub async fn send_message(config: &super::ApiConfig, messages: &[forge_types::CacheableMessage], limits: forge_types::OutputLimits, system_prompt: Option<&str>, tools: Option<&[forge_types::ToolDefinition]>, tx: mpsc::Sender<forge_types::StreamEvent>) -> anyhow::Result<()>; @ providers/src/lib.rs:922

pub async fn send_message(config: &super::ApiConfig, messages: &[forge_types::CacheableMessage], limits: forge_types::OutputLimits, system_prompt: Option<&str>, tools: Option<&[forge_types::ToolDefinition]>, cache: Option<&GeminiCache>, tx: mpsc::Sender<forge_types::StreamEvent>) -> anyhow::Result<()>; @ providers/src/lib.rs:2821

pub async fn send_message(config: &super::ApiConfig, messages: &[forge_types::CacheableMessage], limits: forge_types::OutputLimits, system_prompt: Option<&str>, tools: Option<&[forge_types::ToolDefinition]>, tx: mpsc::Sender<forge_types::StreamEvent>) -> anyhow::Result<()>; @ providers/src/lib.rs:1916

/// Send a request with automatic retries.
pub async fn send_with_retry<F>(build_request: F, timeout: Option<std::time::Duration>, config: &RetryConfig) -> RetryOutcome
    where F: Fn() -> reqwest::RequestBuilder; @ providers/src/retry.rs:226

/// Determine if a response status is retryable.
pub fn should_retry(status: reqwest::StatusCode, headers: &reqwest::header::HeaderMap) -> bool; @ providers/src/retry.rs:89

/// Provider + model configuration with provider-specific tuning knobs.
pub struct ApiConfig { @ providers/src/lib.rs:395
}

impl ApiConfig {
    pub const fn anthropic_thinking_effort(&self) -> &str; @ providers/src/lib.rs:486
    pub const fn anthropic_thinking_mode(&self) -> &str; @ providers/src/lib.rs:481
    pub fn api_key(&self) -> &str; @ providers/src/lib.rs:456
    pub fn api_key_owned(&self) -> ApiKey; @ providers/src/lib.rs:461
    pub const fn gemini_thinking_enabled(&self) -> bool; @ providers/src/lib.rs:476
    pub fn model(&self) -> &ModelName; @ providers/src/lib.rs:466
    pub fn new(api_key: ApiKey, model: ModelName) -> Result<Self, ApiConfigError>; @ providers/src/lib.rs:411
    pub fn openai_options(&self) -> OpenAIRequestOptions; @ providers/src/lib.rs:471
    pub fn provider(&self) -> Provider; @ providers/src/lib.rs:451
    pub fn with_anthropic_thinking(self, mode: &'static str, effort: &'static str) -> Self; @ providers/src/lib.rs:444
    pub fn with_gemini_thinking_enabled(self, enabled: bool) -> Self; @ providers/src/lib.rs:438
    pub fn with_openai_options(self, options: OpenAIRequestOptions) -> Self; @ providers/src/lib.rs:432
}

/// Active Gemini cache reference.
pub struct GeminiCache { @ providers/src/lib.rs:2338
    /// Cache name returned by API (e.g., "cachedContents/abc123")
    pub name: String,
    /// When this cache expires (UTC)
    pub expire_time: chrono::DateTime<chrono::Utc>,
    /// Hash of cached system prompt (for detecting changes)
    pub system_prompt_hash: u64,
    /// Hash of cached tool definitions (for detecting changes)
    pub tools_hash: u64,
}

impl GeminiCache {
    /// Check if this cache has expired.
    pub fn is_expired(&self) -> bool; @ providers/src/lib.rs:2352
    /// Check if this cache matches the given system prompt and tools.
    pub fn matches_config(&self, prompt: &str, tools: Option<&[ToolDefinition]>) -> bool; @ providers/src/lib.rs:2358
}

/// Configuration for Gemini caching.
pub struct GeminiCacheConfig { @ providers/src/lib.rs:2365
    /// Whether caching is enabled
    pub enabled: bool,
    /// TTL in seconds for cached content (default: 3600 = 1 hour)
    pub ttl_seconds: u32,
}

/// Retry configuration matching official SDK defaults.
pub struct RetryConfig { @ providers/src/retry.rs:32
    /// Maximum number of retries (not counting initial request).
    pub max_retries: u32,
    /// Initial backoff delay before first retry.
    pub initial_delay: std::time::Duration,
    /// Maximum backoff delay.
    pub max_delay: std::time::Duration,
    /// Jitter factor for down-jitter (0.25 = up to 25% reduction).
    pub jitter_factor: f64,
}

impl Default for RetryConfig {
    fn default() -> Self;
}

pub enum ApiConfigError { @ providers/src/lib.rs:405
    ProviderMismatch {
        key: forge_types::Provider,
        model: forge_types::Provider,
    },
}

/// Outcome of a retry operation.
pub enum RetryOutcome { @ providers/src/retry.rs:167
    /// Request succeeded (2xx status).
    Success(reqwest::Response),
    /// Request failed with an HTTP error after exhausting retries.
    /// The response is provided for error body inspection.
    HttpError(reqwest::Response),
    /// Request failed with a connection/transport error after exhausting retries.
    ConnectionError {
        attempts: u32,
        source: reqwest::Error,
    },
    /// Request failed with a non-retryable connection error on first attempt.
    NonRetryable(reqwest::Error),
}

impl RetryOutcome {
    /// Returns the successful response, or an error description.
    pub fn into_response(self) -> Result<Response, String>; @ providers/src/retry.rs:186
    /// Returns true if this is a successful response.
    pub const fn is_success(&self) -> bool; @ providers/src/retry.rs:199
}
```

## forge-context

```rust
pub fn atomic_write<impl AsRef<Path>: AsRef<std::path::Path>>(path: impl AsRef<std::path::Path>, bytes: &[u8]) -> std::io::Result<()>; @ context/src/atomic_write.rs:39

pub fn atomic_write_new_with_options<impl AsRef<Path>: AsRef<std::path::Path>>(path: impl AsRef<std::path::Path>, bytes: &[u8], options: AtomicWriteOptions) -> std::io::Result<()>; @ context/src/atomic_write.rs:43

pub fn atomic_write_with_options<impl AsRef<Path>: AsRef<std::path::Path>>(path: impl AsRef<std::path::Path>, bytes: &[u8], options: AtomicWriteOptions) -> std::io::Result<()>; @ context/src/atomic_write.rs:118

/// Get the distillation model name for a given provider.
pub fn distillation_model(provider: forge_types::Provider) -> &'static str; @ context/src/distillation.rs:468

/// Extract facts from a conversation exchange.
pub async fn extract_facts(api_key: &str, user_message: &str, assistant_message: &str) -> anyhow::Result<ExtractionResult>; @ context/src/librarian.rs:121

/// Format retrieved facts for injection into context.
pub fn format_facts_for_context(facts: &[Fact]) -> String; @ context/src/librarian.rs:258

/// Distill conversation messages into a compact Distillate using an LLM.
pub async fn generate_distillation(config: &forge_providers::ApiConfig, counter: &super::token_counter::TokenCounter, messages: &[(super::MessageId, forge_types::Message)], target_tokens: u32) -> anyhow::Result<String>; @ context/src/distillation.rs:173

/// Retrieve relevant facts for a user query.
pub async fn retrieve_relevant(api_key: &str, user_query: &str, available_facts: &[Fact]) -> anyhow::Result<RetrievalResult>; @ context/src/librarian.rs:157

/// Active streaming journal.
pub struct ActiveJournal { @ context/src/stream_journal.rs:185
}

impl ActiveJournal {
    /// Append a Done event (terminal - flushes buffer first).
    pub fn append_done(&mut self, journal: &mut StreamJournal) -> Result<()>; @ context/src/stream_journal.rs:259
    /// Append an Error event (terminal - flushes buffer first).
    pub fn append_error<impl Into<String>: Into<String>>(&mut self, journal: &mut StreamJournal, message: impl Into<String>) -> Result<()>; @ context/src/stream_journal.rs:265
    /// Buffer a text delta for later persistence.
    pub fn append_text<impl Into<String>: Into<String>>(&mut self, journal: &mut StreamJournal, content: impl Into<String>) -> Result<()>; @ context/src/stream_journal.rs:217
    pub fn discard(self, journal: &mut StreamJournal) -> Result<u64>; @ context/src/stream_journal.rs:279
    /// Flush buffered deltas to the database.
    pub fn flush(&mut self, journal: &mut StreamJournal) -> Result<()>; @ context/src/stream_journal.rs:247
    /// Get the model name associated with this streaming session.
    pub fn model_name(&self) -> &str; @ context/src/stream_journal.rs:206
    pub fn seal(self, journal: &mut StreamJournal) -> Result<String>; @ context/src/stream_journal.rs:274
    pub fn step_id(&self) -> StepId; @ context/src/stream_journal.rs:200
}

pub struct AtomicWriteOptions { @ context/src/atomic_write.rs:13
    /// When true, `sync_all()` is called on the temp file before persisting.
    pub sync_all: bool,
    /// When true, best-effort `sync_all()` is called on the parent directory after
    /// the file has been persisted (renamed).
    pub dir_sync: bool,
    /// When set (Unix only), apply this mode to the temp file before writing and to
    /// the final file after persist (e.g. `0o600`).
    pub unix_mode: Option<u32>,
}

impl Default for AtomicWriteOptions {
    fn default() -> Self;
}

pub struct ContextManager { @ context/src/manager.rs:153
}

impl ContextManager {
    pub fn complete_distillation(&mut self, scope: DistillationScope, content: NonEmptyString, generated_by: String) -> Result<DistillateId>; @ context/src/manager.rs:524
    pub fn current_limits(&self) -> ModelLimits; @ context/src/manager.rs:644
    pub fn current_limits_source(&self) -> ModelLimitsSource; @ context/src/manager.rs:649
    pub fn current_model(&self) -> &ModelName; @ context/src/manager.rs:639
    /// if history already contains an entry with this `step_id`, we should not recover it again.
    pub fn has_step_id(&self, step_id: StepId) -> bool; @ context/src/manager.rs:217
    pub fn history(&self) -> &FullHistory; @ context/src/manager.rs:634
    /// Load history from a JSON file.
    pub fn load<impl AsRef<Path>: AsRef<Path>>(path: impl AsRef<Path>, model: ModelName) -> Result<Self>; @ context/src/manager.rs:676
    pub fn new(initial_model: ModelName) -> Self; @ context/src/manager.rs:167
    pub fn prepare(&self) -> Result<PreparedContext<'_>, ContextBuildError>; @ context/src/manager.rs:573
    pub fn prepare_distillation(&mut self, message_ids: &[MessageId]) -> Option<PendingDistillation>; @ context/src/manager.rs:468
    /// Get the configured preserve_recent count.
    pub fn preserve_recent_count(&self) -> usize; @ context/src/manager.rs:600
    pub fn push_message(&mut self, message: Message) -> MessageId; @ context/src/manager.rs:200
    pub fn push_message_with_step_id(&mut self, message: Message, stream_step_id: StepId) -> MessageId; @ context/src/manager.rs:205
    /// Get only the N most recent messages, bypassing distillation.
    pub fn recent_messages_only(&self, count: usize) -> Vec<Message>; @ context/src/manager.rs:589
    /// This is used for transactional rollback when a stream fails...
    pub fn rollback_last_message(&mut self, id: MessageId) -> Option<Message>; @ context/src/manager.rs:222
    /// Save history to a JSON file.
    pub fn save<impl AsRef<Path>: AsRef<Path>>(&self, path: impl AsRef<Path>) -> Result<()>; @ context/src/manager.rs:660
    /// Update model limits without triggering distillation behavior.
    pub fn set_model_without_adaptation(&mut self, new_model: ModelName); @ context/src/manager.rs:254
    /// This allows more input context when users configure smaller output limits.
    pub fn set_output_limit(&mut self, limit: u32); @ context/src/manager.rs:186
    pub fn switch_model(&mut self, new_model: ModelName) -> ContextAdaptation; @ context/src/manager.rs:226
    /// This does not mutate history. If the current model's budget can fit original messages...
    pub fn try_restore_messages(&self) -> usize; @ context/src/manager.rs:556
    /// Get current usage statistics with explicit distillation status.
    pub fn usage_status(&self) -> ContextUsageStatus; @ context/src/manager.rs:606
}

/// Usage statistics for display in UI.
pub struct ContextUsage { @ context/src/working_context.rs:172
    /// Tokens currently used in working context.
    pub used_tokens: u32,
    /// Token budget for current model.
    pub budget_tokens: u32,
    /// Count of distillates in context.
    pub distilled_segments: usize,
}

impl ContextUsage {
    /// Format for status bar: "2.1k / 200k (1%)"
    pub fn format_compact(&self) -> String; @ context/src/working_context.rs:202
    pub fn from_context(ctx: &WorkingContext) -> Self; @ context/src/working_context.rs:183
    pub fn percentage(&self) -> f32; @ context/src/working_context.rs:192
    pub fn severity(&self) -> u8; @ context/src/working_context.rs:234
}

/// Information about corrupted tool call arguments during recovery.
pub struct CorruptedToolArgs { @ context/src/tool_journal.rs:43
    pub tool_call_id: String,
    pub raw_json: String,
    pub parse_error: String,
}

pub struct Distillate { @ context/src/history.rs:275
}

impl Distillate {
    pub fn content(&self) -> &str; @ context/src/history.rs:307
    pub fn content_non_empty(&self) -> &NonEmptyString; @ context/src/history.rs:312
    pub fn new(id: DistillateId, covers: Range<MessageId>, content: NonEmptyString, token_count: u32, original_tokens: u32, generated_by: String) -> Self; @ context/src/history.rs:287
    pub fn token_count(&self) -> u32; @ context/src/history.rs:317
}

pub struct DistillateId { @ context/src/history.rs:38
}

pub struct DistillationNeeded { @ context/src/manager.rs:52
    pub excess_tokens: u32,
    pub messages_to_distill: Vec<super::history::MessageId>,
    pub suggestion: String,
}

/// Contiguous range of message IDs selected for distillation.
pub struct DistillationScope { @ context/src/manager.rs:63
}

/// Result of fact extraction from a conversation exchange.
pub struct ExtractionResult { @ context/src/librarian.rs:71
    /// Extracted facts.
    pub facts: Vec<Fact>,
}

/// A distilled fact extracted from conversation.
pub struct Fact { @ context/src/librarian.rs:60
    /// The type of fact.
    pub fact_type: FactType,
    /// The fact content.
    pub content: String,
    /// Searchable entities/keywords mentioned in this fact.
    pub entities: Vec<String>,
}

/// Persistent store for Librarian-extracted facts.
pub struct FactStore { @ context/src/fact_store.rs:59
}

impl FactStore {
    /// Add a pinned fact (user-explicitly marked as important).
    pub fn add_pinned_fact(&mut self, content: &str, entities: &[String], turn_number: u64) -> Result<FactId>; @ context/src/fact_store.rs:330
    /// Check staleness for a list of facts.
    pub fn check_staleness(&self, facts: &[StoredFact]) -> Result<Vec<FactWithStaleness>>; @ context/src/fact_store.rs:465
    /// Delete all facts (for testing/reset).
    pub fn clear(&mut self) -> Result<()>; @ context/src/fact_store.rs:322
    pub fn fact_count(&self) -> usize; @ context/src/fact_store.rs:315
    /// Get all stored facts.
    pub fn get_all_facts(&self) -> Result<Vec<StoredFact>>; @ context/src/fact_store.rs:190
    /// Get source files for a specific fact.
    pub fn get_sources_for_fact(&self, fact_id: FactId) -> Result<Vec<FactSource>>; @ context/src/fact_store.rs:435
    /// Link facts to their source files.
    pub fn link_facts_to_sources(&mut self, fact_ids: &[FactId], source_paths: &[String]) -> Result<()>; @ context/src/fact_store.rs:385
    /// Open or create fact store database at the given path.
    pub fn open<impl AsRef<Path>: AsRef<Path>>(path: impl AsRef<Path>) -> Result<Self>; @ context/src/fact_store.rs:111
    /// Open an in-memory fact store (for testing).
    pub fn open_in_memory() -> Result<Self>; @ context/src/fact_store.rs:130
    /// Search facts by entity keyword.
    pub fn search_by_entity(&self, keyword: &str) -> Result<Vec<StoredFact>>; @ context/src/fact_store.rs:259
    /// Search facts by entity and return with staleness info.
    pub fn search_with_staleness(&self, keyword: &str) -> Result<Vec<FactWithStaleness>>; @ context/src/fact_store.rs:495
    /// Store facts extracted from a conversation turn.
    pub fn store_facts(&mut self, facts: &[Fact], turn_number: u64) -> Result<Vec<FactId>>; @ context/src/fact_store.rs:146
    /// Record or update a source file's SHA256 hash.
    pub fn upsert_source(&mut self, file_path: &str, sha256: &str) -> Result<i64>; @ context/src/fact_store.rs:348
}

/// A fact with staleness information.
pub struct FactWithStaleness { @ context/src/fact_store.rs:44
    pub fact: StoredFact,
    /// Source files that have changed since the fact was extracted.
    pub stale_sources: Vec<String>,
}

impl FactWithStaleness {
    /// Returns true if any source files have changed.
    pub fn is_stale(&self) -> bool; @ context/src/fact_store.rs:53
}

pub struct FullHistory { @ context/src/history.rs:340
}

impl FullHistory {
    /// Under normal operation, distillates should only cover previously-undistilled...
    pub fn add_distillate(&mut self, distillate: Distillate) -> Result<DistillateId>; @ context/src/history.rs:520
    pub fn distillate(&self, id: DistillateId) -> &Distillate; @ context/src/history.rs:607
    pub fn distillates_len(&self) -> usize; @ context/src/history.rs:591
    pub fn distilled_count(&self) -> usize; @ context/src/history.rs:645
    pub fn entries(&self) -> &[HistoryEntry]; @ context/src/history.rs:586
    pub fn get_entry(&self, id: MessageId) -> &HistoryEntry; @ context/src/history.rs:601
    pub fn has_step_id(&self, step_id: StepId) -> bool; @ context/src/history.rs:513
    pub fn is_empty(&self) -> bool; @ context/src/history.rs:622
    pub fn len(&self) -> usize; @ context/src/history.rs:617
    pub fn new() -> Self; @ context/src/history.rs:483
    pub fn next_distillate_id(&self) -> DistillateId; @ context/src/history.rs:596
    /// Find orphaned distillates (distillates with no messages referencing them).
    pub fn orphaned_distillates(&self) -> Vec<DistillateId>; @ context/src/history.rs:654
    /// This is used for transactional rollback when a stream fails...
    pub fn pop_if_last(&mut self, id: MessageId) -> Option<Message>; @ context/src/history.rs:627
    pub fn push(&mut self, message: Message, token_count: u32) -> MessageId; @ context/src/history.rs:487
    pub fn push_with_step_id(&mut self, message: Message, token_count: u32, stream_step_id: StepId) -> MessageId; @ context/src/history.rs:495
    /// Total tokens across all original messages.
    pub fn total_tokens(&self) -> u32; @ context/src/history.rs:612
}

impl Serialize for FullHistory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where S: serde::Serializer;
}

impl Deserialize<'de> for FullHistory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where D: serde::Deserializer<'de>;
}

pub struct JournalStats { @ context/src/stream_journal.rs:931
    /// Total number of entries
    pub total_entries: u64,
    /// Number of sealed entries
    pub sealed_entries: u64,
    /// Number of unsealed entries
    pub unsealed_entries: u64,
    /// Current (last allocated) step ID
    pub current_step_id: StepId,
}

/// The Librarian - manages fact extraction, storage, and retrieval.
pub struct Librarian { @ context/src/librarian.rs:287
}

impl Librarian {
    /// Get all stored facts (for debugging/inspection).
    pub fn all_facts(&self) -> Result<Vec<Fact>>; @ context/src/librarian.rs:411
    /// Get the API key for direct API calls.
    pub fn api_key(&self) -> &str; @ context/src/librarian.rs:331
    /// Clear all facts (for testing/reset).
    pub fn clear(&mut self) -> Result<()>; @ context/src/librarian.rs:434
    /// Post-turn: Extract and store facts from a conversation exchange.
    pub async fn extract_and_store(&mut self, user_message: &str, assistant_message: &str) -> Result<ExtractionResult>; @ context/src/librarian.rs:388
    pub fn fact_count(&self) -> usize; @ context/src/librarian.rs:322
    /// Increment the turn counter.
    pub fn increment_turn(&mut self); @ context/src/librarian.rs:338
    pub fn open<impl AsRef<Path>: AsRef<Path>>(path: impl AsRef<Path>, api_key: String) -> Result<Self>; @ context/src/librarian.rs:294
    pub fn open_in_memory(api_key: String) -> Result<Self>; @ context/src/librarian.rs:303
    /// Add a user-pinned fact.
    pub fn pin_fact(&mut self, content: &str, entities: &[String]) -> Result<()>; @ context/src/librarian.rs:404
    /// Pre-flight: Retrieve relevant facts for a user query.
    pub async fn retrieve_context(&self, user_query: &str) -> Result<RetrievalResult>; @ context/src/librarian.rs:375
    /// Search facts by keyword.
    pub fn search(&self, keyword: &str) -> Result<Vec<Fact>>; @ context/src/librarian.rs:417
    /// Search facts by keyword with staleness information.
    pub fn search_with_staleness(&self, keyword: &str) -> Result<Vec<super::fact_store::FactWithStaleness>>; @ context/src/librarian.rs:426
    pub fn set_turn_counter(&mut self, turn: u64); @ context/src/librarian.rs:312
    /// Store extracted facts (sync operation).
    pub fn store_facts(&mut self, facts: &[Fact]) -> Result<()>; @ context/src/librarian.rs:345
    /// Store extracted facts and link them to source files.
    pub fn store_facts_with_sources(&mut self, facts: &[Fact], source_paths: &[String]) -> Result<()>; @ context/src/librarian.rs:356
    pub fn turn_counter(&self) -> u64; @ context/src/librarian.rs:317
}

impl Debug for Librarian {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

pub struct MessageId { @ context/src/history.rs:16
}

impl MessageId {
    pub fn as_u64(&self) -> u64; @ context/src/history.rs:33
}

/// The effective input budget accounts for output reservation and a safety margin.
pub struct ModelLimits { @ context/src/model_limits.rs:23
}

impl ModelLimits {
    pub const fn context_window(&self) -> u32; @ context/src/model_limits.rs:62
    /// This is the maximum number of tokens available for input messages,
    /// calculated as: `context_window - max_output - 5% safety margin`.
    pub fn effective_input_budget(&self) -> u32; @ context/src/model_limits.rs:47
    /// The reserved amount is clamped to the model's `max_output`.
    pub fn effective_input_budget_with_reserved(&self, reserved_output: u32) -> u32; @ context/src/model_limits.rs:53
    pub const fn max_output(&self) -> u32; @ context/src/model_limits.rs:67
    pub const fn new(context_window: u32, max_output: u32) -> Self; @ context/src/model_limits.rs:30
}

/// 1. First, check custom overrides set via [`ModelRegistry::set_override`]
/// 2. If no override exists, use the canonical model catalog
pub struct ModelRegistry { @ context/src/model_limits.rs:131
}

impl ModelRegistry {
    pub fn get(&self, model: &ModelName) -> ResolvedModelLimits; @ context/src/model_limits.rs:145
    pub fn new() -> Self; @ context/src/model_limits.rs:138
}

impl Default for ModelRegistry {
    fn default() -> Self;
}

/// Request for async distillation, created by [`ContextManager::prepare_distillation`].
pub struct PendingDistillation { @ context/src/manager.rs:92
    /// The scope defining which messages to distill.
    pub scope: DistillationScope,
    /// The actual messages to distill, in order.
    pub messages: Vec<(super::history::MessageId, forge_types::Message)>,
    /// Total tokens in the original messages.
    pub original_tokens: u32,
    /// Target token count for the generated distillation.
    pub target_tokens: u32,
}

/// Proof that working context was successfully built within the token budget.
pub struct PreparedContext<'a> { @ context/src/manager.rs:109
}

impl PreparedContext<'a> {
    pub fn api_messages(&self) -> Vec<Message>; @ context/src/manager.rs:116
    pub fn usage(&self) -> ContextUsage; @ context/src/manager.rs:121
}

/// Recovered tool batch data after a crash.
pub struct RecoveredToolBatch { @ context/src/tool_journal.rs:51
    pub batch_id: ToolBatchId,
    pub model_name: String,
    pub assistant_text: String,
    pub calls: Vec<forge_types::ToolCall>,
    pub results: Vec<forge_types::ToolResult>,
    /// Tool calls whose arguments failed to parse (substituted with {})
    pub corrupted_args: Vec<CorruptedToolArgs>,
}

pub struct ResolvedModelLimits { @ context/src/model_limits.rs:79
}

impl ResolvedModelLimits {
    pub const fn limits(self) -> ModelLimits; @ context/src/model_limits.rs:91
    pub const fn new(limits: ModelLimits, source: ModelLimitsSource) -> Self; @ context/src/model_limits.rs:86
    pub const fn source(self) -> ModelLimitsSource; @ context/src/model_limits.rs:96
}

/// Result of relevance retrieval for a user query.
pub struct RetrievalResult { @ context/src/librarian.rs:78
    /// Facts deemed relevant to the query, ordered by relevance.
    pub relevant_facts: Vec<Fact>,
    /// Total token estimate for the retrieved facts.
    pub token_estimate: u32,
}

/// Unique identifier for a streaming step/session.
pub struct StepId { @ context/src/stream_journal.rs:45
}

impl StepId {
    pub const fn new(value: i64) -> Self; @ context/src/stream_journal.rs:49
    pub const fn value(self) -> i64; @ context/src/stream_journal.rs:54
}

impl Display for StepId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

impl From<i64> for StepId {
    fn from(value: i64) -> Self;
}

impl From<StepId> for StepId {
    fn from(value: StepId) -> Self;
}

impl ToSql for StepId {
    fn to_sql(&self) -> rusqlite::Result<ToSqlOutput<'_>>;
}

impl FromSql for StepId {
    fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self>;
}

/// A stored fact with its metadata.
pub struct StoredFact { @ context/src/fact_store.rs:26
    pub id: FactId,
    pub fact: super::librarian::Fact,
    pub turn_number: u64,
    pub created_at: String,
}

/// Stream journal for durable streaming with crash recovery
pub struct StreamJournal { @ context/src/stream_journal.rs:332
}

impl StreamJournal {
    /// Begin a new journal session for streaming.
    pub fn begin_session<impl Into<String>: Into<String>>(&mut self, model_name: impl Into<String>) -> Result<ActiveJournal>; @ context/src/stream_journal.rs:425
    /// Atomically commit and prune a step.
    pub fn commit_and_prune_step(&mut self, step_id: StepId) -> Result<u64>; @ context/src/stream_journal.rs:499
    /// Discard a step that was never committed (error/cancel path).
    pub fn discard_step(&mut self, step_id: StepId) -> Result<u64>; @ context/src/stream_journal.rs:537
    /// Delete all unsealed entries for a step (discard recovery data).
    pub fn discard_unsealed(&mut self, step_id: StepId) -> Result<u64>; @ context/src/stream_journal.rs:579
    /// Allocate the next step ID
    pub fn next_step_id(&mut self) -> Result<StepId>; @ context/src/stream_journal.rs:592
    /// Open or create journal database at the given path
    pub fn open<impl AsRef<Path>: AsRef<Path>>(path: impl AsRef<Path>) -> Result<Self>; @ context/src/stream_journal.rs:371
    /// Open an in-memory journal (for testing)
    pub fn open_in_memory() -> Result<Self>; @ context/src/stream_journal.rs:393
    /// Check for and recover incomplete streams after a crash
    pub fn recover(&self) -> Result<Option<RecoveredStream>>; @ context/src/stream_journal.rs:708
    /// Seal unsealed entries for a step (used for crash recovery).
    pub fn seal_unsealed(&mut self, step_id: StepId) -> Result<String>; @ context/src/stream_journal.rs:482
    /// Get statistics about the journal.
    pub fn stats(&self) -> Result<JournalStats>; @ context/src/stream_journal.rs:585
}

/// Thread-safe approximate token counter using tiktoken's `o200k_base` encoding.
pub struct TokenCounter { @ context/src/token_counter.rs:61
}

impl TokenCounter {
    /// Counts tokens for a single message, including role overhead.
    pub fn count_message(&self, msg: &Message) -> u32; @ context/src/token_counter.rs:125
    /// Counts the number of tokens in a string.
    pub fn count_str(&self, text: &str) -> u32; @ context/src/token_counter.rs:99
    /// Initializes a counter using the shared singleton encoder.
    pub fn new() -> Self; @ context/src/token_counter.rs:76
}

impl Debug for TokenCounter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result;
}

impl Default for TokenCounter {
    fn default() -> Self;
}

/// Tool journal for durable tool batch tracking.
pub struct ToolJournal { @ context/src/tool_journal.rs:65
}

impl ToolJournal {
    /// Append a text delta to the assistant text for a streaming batch.
    pub fn append_assistant_delta(&mut self, batch_id: ToolBatchId, delta: &str) -> Result<()>; @ context/src/tool_journal.rs:300
    /// Append streamed JSON arguments for a tool call.
    pub fn append_call_args(&mut self, batch_id: ToolBatchId, tool_call_id: &str, delta: &str) -> Result<()>; @ context/src/tool_journal.rs:254
    /// Begin a new tool batch and persist its tool calls.
    pub fn begin_batch(&mut self, model_name: &str, assistant_text: &str, calls: &[ToolCall]) -> Result<ToolBatchId>; @ context/src/tool_journal.rs:147
    /// Begin a new tool batch during streaming (before tool arguments are complete).
    pub fn begin_streaming_batch(&mut self, model_name: &str) -> Result<ToolBatchId>; @ context/src/tool_journal.rs:205
    /// Commit and prune a completed batch.
    pub fn commit_batch(&mut self, batch_id: ToolBatchId) -> Result<()>; @ context/src/tool_journal.rs:335
    /// Discard an incomplete batch (used on cancel or user discard).
    pub fn discard_batch(&mut self, batch_id: ToolBatchId) -> Result<()>; @ context/src/tool_journal.rs:370
    /// Open or create tool journal database at the given path.
    pub fn open<impl AsRef<Path>: AsRef<Path>>(path: impl AsRef<Path>) -> Result<Self>; @ context/src/tool_journal.rs:110
    /// Open an in-memory journal (for testing).
    pub fn open_in_memory() -> Result<Self>; @ context/src/tool_journal.rs:129
    /// Record the start of a tool call in a streaming batch.
    pub fn record_call_start(&mut self, batch_id: ToolBatchId, seq: usize, tool_call_id: &str, tool_name: &str, thought_signature: &ThoughtSignatureState) -> Result<()>; @ context/src/tool_journal.rs:231
    /// Record a tool result for a batch.
    pub fn record_result(&mut self, batch_id: ToolBatchId, result: &ToolResult) -> Result<()>; @ context/src/tool_journal.rs:315
    /// Recover the most recent incomplete tool batch, if any.
    pub fn recover(&self) -> Result<Option<RecoveredToolBatch>>; @ context/src/tool_journal.rs:399
    /// Update assistant text for a streaming batch (full replacement).
    pub fn update_assistant_text(&mut self, batch_id: ToolBatchId, assistant_text: &str) -> Result<()>; @ context/src/tool_journal.rs:278
}

/// The working context: a plan for what to send to the API.
pub struct WorkingContext { @ context/src/working_context.rs:71
}

impl WorkingContext {
    pub fn distillate_count(&self) -> usize; @ context/src/working_context.rs:135
    /// Materialize into actual messages for API call.
    pub fn materialize(&self, history: &FullHistory) -> Vec<Message>; @ context/src/working_context.rs:144
    pub fn new(token_budget: u32) -> Self; @ context/src/working_context.rs:80
    /// Add a Distillate segment.
    pub fn push_distillate(&mut self, distillate_id: DistillateId, replaces: Vec<MessageId>, tokens: u32); @ context/src/working_context.rs:92
    pub fn push_original(&mut self, id: MessageId, tokens: u32); @ context/src/working_context.rs:87
    pub fn segments(&self) -> &[ContextSegment]; @ context/src/working_context.rs:103
    pub fn token_budget(&self) -> u32; @ context/src/working_context.rs:112
    pub fn total_tokens(&self) -> u32; @ context/src/working_context.rs:107
}

pub enum ContextAdaptation { @ context/src/manager.rs:69
    /// No change in effective budget.
    NoChange,
    /// Switched to a model with smaller context.
    Shrinking {
        old_budget: u32,
        new_budget: u32,
        needs_distillation: bool,
    },
    /// Switched to a model with larger context.
    Expanding {
        old_budget: u32,
        new_budget: u32,
        /// Number of messages that could potentially be restored.
        can_restore: usize,
    },
}

pub enum ContextBuildError { @ context/src/manager.rs:39
    /// Older messages need distillation to fit within budget.
    DistillationNeeded(DistillationNeeded),
    /// The most recent N messages alone exceed the budget.
    /// This is unrecoverable - user must reduce input or switch to larger model.
    RecentMessagesTooLarge {
        required_tokens: u32,
        budget_tokens: u32,
        message_count: usize,
    },
}

/// Represents a segment of the working context.
pub enum ContextSegment { @ context/src/working_context.rs:20
    Original {
        id: super::history::MessageId,
        tokens: u32,
    },
    Distilled {
        distillate_id: super::history::DistillateId,
        /// Original message IDs that this replaces.
        replaces: Vec<super::history::MessageId>,
        tokens: u32,
    },
}

impl ContextSegment {
    pub fn distilled(distillate_id: DistillateId, replaces: Vec<MessageId>, tokens: u32) -> Self; @ context/src/working_context.rs:40
    pub fn is_distilled(&self) -> bool; @ context/src/working_context.rs:55
    pub fn original(id: MessageId, tokens: u32) -> Self; @ context/src/working_context.rs:35
    pub fn tokens(&self) -> u32; @ context/src/working_context.rs:60
}

/// Current context usage state with explicit distillation status.
pub enum ContextUsageStatus { @ context/src/manager.rs:131
    /// Context fits within budget and is ready for use.
    Ready(super::working_context::ContextUsage),
    /// Context exceeds budget; distillation is needed before API call.
    NeedsDistillation {
        /// Current usage statistics.
        usage: super::working_context::ContextUsage,
        /// Details about what needs distillation.
        needed: DistillationNeeded,
    },
    /// Recent messages alone exceed budget; unrecoverable without user action.
    RecentMessagesTooLarge {
        /// Current usage statistics.
        usage: super::working_context::ContextUsage,
        /// Tokens required by recent messages.
        required_tokens: u32,
        /// Available budget tokens.
        budget_tokens: u32,
    },
}

/// Types of facts the Librarian can extract.
pub enum FactType { @ context/src/librarian.rs:32
    /// Entities: files, functions, variables, paths, URLs, etc.
    Entity,
    /// Decisions: "we chose X because Y"
    Decision,
    /// Constraints: "must stay compatible with Z", "don't modify X"
    Constraint,
    /// Code state: what was created, modified, deleted
    CodeState,
    /// User-pinned facts (explicitly marked important)
    Pinned,
}

impl FactType {
    pub fn as_str(&self) -> &'static str; @ context/src/librarian.rs:47
}

pub enum HistoryEntry { @ context/src/history.rs:52
    Original {
        id: MessageId,
        message: forge_types::Message,
        token_count: u32,
        created_at: std::time::SystemTime,
        /// Stream journal step ID for crash recovery linkage (assistant messages only)
        stream_step_id: Option<crate::StepId>,
    },
    Distilled {
        id: MessageId,
        message: forge_types::Message,
        token_count: u32,
        distillate_id: DistillateId,
        created_at: std::time::SystemTime,
        stream_step_id: Option<crate::StepId>,
    },
}

impl HistoryEntry {
    pub fn distillate_id(&self) -> Option<DistillateId>; @ context/src/history.rs:224
    pub fn id(&self) -> MessageId; @ context/src/history.rs:200
    pub fn is_distilled(&self) -> bool; @ context/src/history.rs:240
    pub fn mark_distilled(&mut self, distillate_id: DistillateId); @ context/src/history.rs:244
    pub fn message(&self) -> &Message; @ context/src/history.rs:207
    pub fn new(id: MessageId, message: Message, token_count: u32) -> Self; @ context/src/history.rs:171
    /// Used for assistant messages from streaming responses to enable
    /// idempotent crash recovery.
    pub fn new_with_step_id(id: MessageId, message: Message, token_count: u32, stream_step_id: StepId) -> Self; @ context/src/history.rs:184
    pub fn stream_step_id(&self) -> Option<StepId>; @ context/src/history.rs:232
    pub fn token_count(&self) -> u32; @ context/src/history.rs:216
}

impl Serialize for HistoryEntry {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where S: serde::Serializer;
}

impl Deserialize<'de> for HistoryEntry {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where D: serde::Deserializer<'de>;
}

pub enum ModelLimitsSource { @ context/src/model_limits.rs:73
    Override,
    Catalog(forge_types::PredefinedModel),
}

/// Recovered stream data after a crash.
pub enum RecoveredStream { @ context/src/stream_journal.rs:288
    /// The stream ended cleanly but was not sealed.
    Complete {
        /// The step ID that was interrupted
        step_id: StepId,
        /// Accumulated text from `text_delta` events
        partial_text: String,
        /// Last sequence number seen
        last_seq: u64,
        /// Model name from the original stream (for accurate attribution)
        model_name: Option<String>,
    },
    /// The stream ended with an error but was not sealed.
    Errored {
        /// The step ID that was interrupted
        step_id: StepId,
        /// Accumulated text from `text_delta` events
        partial_text: String,
        /// Last sequence number seen
        last_seq: u64,
        /// Error message captured from the stream
        error: String,
        /// Model name from the original stream (for accurate attribution)
        model_name: Option<String>,
    },
    /// The stream ended mid-flight.
    Incomplete {
        /// The step ID that was interrupted
        step_id: StepId,
        /// Accumulated text from `text_delta` events
        partial_text: String,
        /// Last sequence number seen
        last_seq: u64,
        /// Model name from the original stream (for accurate attribution)
        model_name: Option<String>,
    },
}
```

## forge-engine

```rust
pub fn command_specs() -> &'static [CommandSpec]; @ engine/src/commands.rs:82

/// Find match positions for highlighting in the UI.
pub fn find_match_positions(path: &str, filter: &str) -> Vec<usize>; @ engine/src/ui/file_picker.rs:222

/// Single global instance (IFA-7 compliant).
pub fn sanitize_display_text(input: &str) -> String; @ engine/src/security.rs:191

pub struct App { @ engine/src/lib.rs:407
}

impl App {
    pub fn cancel_active_operation(&mut self) -> bool; @ engine/src/commands.rs:259
    /// Check for and recover from a crashed streaming session.
    pub fn check_crash_recovery(&mut self) -> Option<RecoveredStream>; @ engine/src/persistence.rs:222
    pub fn clear_files_panel_effect(&mut self); @ engine/src/lib.rs:581
    pub fn clear_modal_effect(&mut self); @ engine/src/lib.rs:1199
    /// Close the files panel (no-op if already hidden).
    pub fn close_files_panel(&mut self); @ engine/src/lib.rs:555
    pub fn command_cursor(&self) -> Option<usize>; @ engine/src/lib.rs:1555
    pub fn command_cursor_byte_index(&self) -> Option<usize>; @ engine/src/lib.rs:1559
    /// Get command mode wrapper (requires proof token).
    pub fn command_mode(&mut self, _token: CommandToken) -> CommandMode<'_>; @ engine/src/input_modes.rs:261
    pub fn command_text(&self) -> Option<&str>; @ engine/src/lib.rs:1551
    /// Get proof token if currently in Command mode.
    pub fn command_token(&self) -> Option<CommandToken>; @ engine/src/input_modes.rs:251
    /// Get context usage statistics for the UI.
    /// Uses cached value when available to avoid recomputing every frame.
    pub fn context_usage_status(&mut self) -> ContextUsageStatus; @ engine/src/lib.rs:968
    /// Get the current API key for the selected provider.
    pub fn current_api_key(&self) -> Option<&String>; @ engine/src/lib.rs:943
    pub fn display_items(&self) -> &[DisplayItem]; @ engine/src/lib.rs:924
    /// Version counter for display changes - used for render caching.
    pub fn display_version(&self) -> usize; @ engine/src/lib.rs:934
    pub fn draft_cursor(&self) -> usize; @ engine/src/lib.rs:1543
    pub fn draft_cursor_byte_index(&self) -> usize; @ engine/src/lib.rs:1547
    pub fn draft_text(&self) -> &str; @ engine/src/lib.rs:1539
    pub fn enter_command_mode(&mut self); @ engine/src/lib.rs:1226
    /// Enter file select mode, scanning files from the current directory.
    pub fn enter_file_select_mode(&mut self); @ engine/src/lib.rs:1305
    pub fn enter_insert_mode(&mut self); @ engine/src/lib.rs:1222
    pub fn enter_insert_mode_at_end(&mut self); @ engine/src/lib.rs:1207
    pub fn enter_insert_mode_with_clear(&mut self); @ engine/src/lib.rs:1212
    pub fn enter_model_select_mode(&mut self); @ engine/src/lib.rs:1230
    pub fn enter_normal_mode(&mut self); @ engine/src/lib.rs:1217
    /// Get the file picker state for rendering.
    pub fn file_picker(&self) -> &ui::FilePickerState; @ engine/src/lib.rs:1336
    /// Delete a character from the file select filter (backspace).
    pub fn file_select_backspace(&mut self); @ engine/src/lib.rs:1378
    /// Cancel file selection and return to insert mode.
    pub fn file_select_cancel(&mut self); @ engine/src/lib.rs:1402
    /// Confirm file selection - insert the selected file path into the draft.
    pub fn file_select_confirm(&mut self); @ engine/src/lib.rs:1386
    /// Get filtered files for display.
    pub fn file_select_files(&self) -> Vec<&ui::FileEntry>; @ engine/src/lib.rs:1331
    /// Get the current file select filter text.
    pub fn file_select_filter(&self) -> Option<&str>; @ engine/src/lib.rs:1321
    /// Get the current file select index.
    pub fn file_select_index(&self) -> Option<usize>; @ engine/src/lib.rs:1326
    /// Move file selection down.
    pub fn file_select_move_down(&mut self); @ engine/src/lib.rs:1350
    /// Move file selection up.
    pub fn file_select_move_up(&mut self); @ engine/src/lib.rs:1341
    /// Push a character to the file select filter.
    pub fn file_select_push_char(&mut self, c: char); @ engine/src/lib.rs:1370
    /// Update the file select filter and refresh filtered results.
    pub fn file_select_update_filter(&mut self); @ engine/src/lib.rs:1360
    /// Collapse the expanded diff.
    pub fn files_panel_collapse(&mut self); @ engine/src/lib.rs:673
    pub fn files_panel_diff(&self) -> Option<FileDiff>; @ engine/src/lib.rs:714
    /// Get mutable reference to files panel effect for UI processing.
    pub fn files_panel_effect_mut(&mut self) -> Option<&mut PanelEffect>; @ engine/src/lib.rs:577
    pub fn files_panel_expanded(&self) -> bool; @ engine/src/lib.rs:664
    /// Cycle to the next file in the panel (wrapping).
    pub fn files_panel_next(&mut self); @ engine/src/lib.rs:625
    /// Cycle to the previous file in the panel (wrapping).
    pub fn files_panel_prev(&mut self); @ engine/src/lib.rs:643
    /// Scroll the diff view down.
    pub fn files_panel_scroll_diff_down(&mut self); @ engine/src/lib.rs:706
    pub fn files_panel_scroll_diff_up(&mut self); @ engine/src/lib.rs:710
    pub fn files_panel_state(&self) -> &FilesPanelState; @ engine/src/lib.rs:668
    pub fn files_panel_sync_selection(&mut self); @ engine/src/lib.rs:678
    pub fn files_panel_visible(&self) -> bool; @ engine/src/lib.rs:572
    pub fn finish_files_panel_effect(&mut self); @ engine/src/lib.rs:585
    /// Get elapsed time since last frame and update timing.
    pub fn frame_elapsed(&mut self) -> Duration; @ engine/src/lib.rs:1187
    pub fn has_api_key(&self, provider: Provider) -> bool; @ engine/src/lib.rs:938
    pub fn history(&self) -> &forge_context::FullHistory; @ engine/src/lib.rs:786
    pub fn input_mode(&self) -> InputMode; @ engine/src/lib.rs:1203
    /// Get insert mode wrapper (requires proof token).
    pub fn insert_mode(&mut self, _token: InsertToken) -> InsertMode<'_>; @ engine/src/input_modes.rs:256
    /// Get proof token if currently in Insert mode.
    pub fn insert_token(&self) -> Option<InsertToken>; @ engine/src/input_modes.rs:246
    pub fn is_empty(&self) -> bool; @ engine/src/lib.rs:909
    /// Whether we're currently streaming a response.
    pub fn is_loading(&self) -> bool; @ engine/src/lib.rs:948
    /// Whether the named tool should be hidden from UI rendering.
    pub fn is_tool_hidden(&self, name: &str) -> bool; @ engine/src/lib.rs:929
    /// API usage from the last completed turn (for status bar display).
    pub fn last_turn_usage(&self) -> Option<&TurnUsage>; @ engine/src/lib.rs:996
    /// Whether the LSP subsystem is active and has running servers.
    pub fn lsp_active(&self) -> bool; @ engine/src/lsp_integration.rs:153
    /// Get the current diagnostics snapshot for UI display.
    pub fn lsp_snapshot(&self) -> &forge_lsp::DiagnosticsSnapshot; @ engine/src/lsp_integration.rs:147
    pub fn memory_enabled(&self) -> bool; @ engine/src/lib.rs:983
    /// Get mutable reference to modal effect for UI processing.
    pub fn modal_effect_mut(&mut self) -> Option<&mut ModalEffect>; @ engine/src/lib.rs:1195
    pub fn model(&self) -> &str; @ engine/src/lib.rs:754
    /// Select the current model and return to normal mode.
    pub fn model_select_confirm(&mut self); @ engine/src/lib.rs:1285
    pub fn model_select_index(&self) -> Option<usize>; @ engine/src/lib.rs:1244
    pub fn model_select_move_down(&mut self); @ engine/src/lib.rs:1268
    pub fn model_select_move_up(&mut self); @ engine/src/lib.rs:1260
    pub fn model_select_set_index(&mut self, index: usize); @ engine/src/lib.rs:1277
    /// Navigate to next (newer) command in Command mode.
    pub fn navigate_command_history_down(&mut self); @ engine/src/lib.rs:1596
    /// Navigate to previous (older) command in Command mode.
    pub fn navigate_command_history_up(&mut self); @ engine/src/lib.rs:1587
    /// Navigate to next (newer) prompt in Insert mode.
    pub fn navigate_history_down(&mut self); @ engine/src/lib.rs:1578
    /// Navigate to previous (older) prompt in Insert mode.
    pub fn navigate_history_up(&mut self); @ engine/src/lib.rs:1567
    pub fn new(system_prompts: SystemPrompts) -> anyhow::Result<Self>; @ engine/src/init.rs:79
    /// Get ordered list of changed files: modified first (alphabetical), then created.
    /// Filters out files that no longer exist on disk.
    pub fn ordered_files(&self) -> Vec<(std::path::PathBuf, ChangeKind)>; @ engine/src/lib.rs:604
    /// Poll for completed distillation task and apply the result.
    pub fn poll_distillation(&mut self); @ engine/src/distillation.rs:136
    pub fn process_command(&mut self, command: EnteredCommand); @ engine/src/commands.rs:316
    /// Process any pending stream events.
    pub fn process_stream_events(&mut self); @ engine/src/streaming.rs:266
    pub fn provider(&self) -> Provider; @ engine/src/lib.rs:750
    /// Queue a system notification to be injected into the next API request.
    pub fn queue_notification(&mut self, notification: notifications::SystemNotification); @ engine/src/lib.rs:991
    pub fn request_quit(&mut self); @ engine/src/lib.rs:510
    pub fn save_history(&self) -> anyhow::Result<()>; @ engine/src/persistence.rs:30
    /// Save session state (draft input + input history) to disk.
    pub fn save_session(&self) -> anyhow::Result<()>; @ engine/src/persistence.rs:123
    pub fn scroll_down(&mut self); @ engine/src/lib.rs:1657
    pub fn scroll_offset_from_top(&self) -> u16; @ engine/src/lib.rs:1626
    /// Scroll down by a page.
    pub fn scroll_page_down(&mut self); @ engine/src/lib.rs:1673
    /// Scroll up by a page.
    pub fn scroll_page_up(&mut self); @ engine/src/lib.rs:1645
    pub fn scroll_to_bottom(&mut self); @ engine/src/lib.rs:1693
    pub fn scroll_to_top(&mut self); @ engine/src/lib.rs:1689
    pub fn scroll_up(&mut self); @ engine/src/lib.rs:1633
    /// Scroll up by 20% of total scrollable content.
    pub fn scroll_up_chunk(&mut self); @ engine/src/lib.rs:1698
    pub fn session_changes(&self) -> &SessionChangeLog; @ engine/src/lib.rs:598
    /// Set a specific model (called from :model command).
    pub fn set_model(&mut self, model: ModelName); @ engine/src/lib.rs:1099
    pub fn should_quit(&self) -> bool; @ engine/src/lib.rs:506
    /// Gracefully shut down all LSP servers.
    pub async fn shutdown_lsp(&mut self); @ engine/src/lsp_integration.rs:166
    /// Trigger distillation of older messages when context is near capacity.
    pub fn start_distillation(&mut self); @ engine/src/distillation.rs:17
    pub fn start_streaming(&mut self, queued: QueuedUserMessage); @ engine/src/streaming.rs:82
    pub fn streaming(&self) -> Option<&StreamingMessage>; @ engine/src/lib.rs:790
    /// Check if a transcript clear was requested and clear the flag.
    pub fn take_clear_transcript(&mut self) -> bool; @ engine/src/lib.rs:515
    /// Poll background tasks and update wall-clock based timers.
    pub fn tick(&mut self); @ engine/src/lib.rs:1166
    pub fn tick_count(&self) -> usize; @ engine/src/lib.rs:782
    /// Toggle visibility of the files panel.
    pub fn toggle_files_panel(&mut self); @ engine/src/lib.rs:529
    /// Toggle visibility of thinking/reasoning content in the UI.
    pub fn toggle_thinking(&mut self); @ engine/src/lib.rs:524
    /// Handle Enter key on approval prompt - action depends on cursor position:
    /// - On tool item: toggle selection
    /// - On Submit button: confirm selected
    /// - On Deny All button: deny all
    pub fn tool_approval_activate(&mut self); @ engine/src/lib.rs:1473
    pub fn tool_approval_approve_all(&mut self); @ engine/src/lib.rs:1461
    pub fn tool_approval_confirm_selected(&mut self); @ engine/src/lib.rs:1488
    pub fn tool_approval_cursor(&self) -> Option<usize>; @ engine/src/lib.rs:882
    pub fn tool_approval_deny_all(&mut self); @ engine/src/lib.rs:1465
    pub fn tool_approval_deny_confirm(&self) -> bool; @ engine/src/lib.rs:890
    pub fn tool_approval_expanded(&self) -> Option<usize>; @ engine/src/lib.rs:886
    pub fn tool_approval_move_down(&mut self); @ engine/src/lib.rs:1419
    pub fn tool_approval_move_up(&mut self); @ engine/src/lib.rs:1406
    pub fn tool_approval_request_deny_all(&mut self); @ engine/src/lib.rs:1509
    pub fn tool_approval_requests(&self) -> Option<&[tools::ConfirmationRequest]>; @ engine/src/lib.rs:874
    pub fn tool_approval_selected(&self) -> Option<&[bool]>; @ engine/src/lib.rs:878
    pub fn tool_approval_toggle(&mut self); @ engine/src/lib.rs:1433
    pub fn tool_approval_toggle_details(&mut self); @ engine/src/lib.rs:1445
    pub fn tool_loop_calls(&self) -> Option<&[ToolCall]>; @ engine/src/lib.rs:845
    pub fn tool_loop_current_call_id(&self) -> Option<&str>; @ engine/src/lib.rs:857
    pub fn tool_loop_execute_calls(&self) -> Option<&[ToolCall]>; @ engine/src/lib.rs:849
    pub fn tool_loop_output_lines(&self) -> Option<&[String]>; @ engine/src/lib.rs:861
    pub fn tool_loop_output_lines_for(&self, tool_call_id: &str) -> Option<&[String]>; @ engine/src/lib.rs:867
    pub fn tool_loop_results(&self) -> Option<&[ToolResult]>; @ engine/src/lib.rs:853
    pub fn tool_recovery_calls(&self) -> Option<&[ToolCall]>; @ engine/src/lib.rs:895
    pub fn tool_recovery_discard(&mut self); @ engine/src/lib.rs:1535
    pub fn tool_recovery_results(&self) -> Option<&[ToolResult]>; @ engine/src/lib.rs:902
    pub fn tool_recovery_resume(&mut self); @ engine/src/lib.rs:1531
    pub fn ui_options(&self) -> UiOptions; @ engine/src/lib.rs:519
    pub fn update_scroll_max(&mut self, max: u16); @ engine/src/lib.rs:1616
}

pub struct AppConfig { @ engine/src/config.rs:47
    pub model: Option<String>,
    pub tui: Option<String>,
    /// Use ASCII-only glyphs for icons and spinners.
    pub ascii_only: bool,
    /// Enable a high-contrast color palette.
    pub high_contrast: bool,
    /// Disable modal animations and motion effects.
    pub reduced_motion: bool,
    /// Render provider thinking/reasoning deltas in the UI (if available).
    pub show_thinking: bool,
}

/// Mode wrapper for safe command operations.
pub struct CommandMode<'a> { @ engine/src/input_modes.rs:236
}

impl CommandMode<'a> {
    pub fn backspace(&mut self); @ engine/src/input_modes.rs:437
    pub fn clear_line(&mut self); @ engine/src/input_modes.rs:451
    pub fn delete_word_backwards(&mut self); @ engine/src/input_modes.rs:444
    pub fn move_cursor_end(&mut self); @ engine/src/input_modes.rs:423
    pub fn move_cursor_left(&mut self); @ engine/src/input_modes.rs:402
    pub fn move_cursor_right(&mut self); @ engine/src/input_modes.rs:409
    pub fn push_char(&mut self, c: char); @ engine/src/input_modes.rs:430
    pub fn reset_cursor(&mut self); @ engine/src/input_modes.rs:416
    /// Perform shell-style tab completion on the command line.
    pub fn tab_complete(&mut self); @ engine/src/input_modes.rs:467
    pub fn take_command(self) -> Option<EnteredCommand>; @ engine/src/input_modes.rs:491
}

pub struct CommandSpec { @ engine/src/commands.rs:12
    pub palette_label: &'static str,
    pub help_label: &'static str,
    pub description: &'static str,
}

/// Proof token for Command mode operations.
pub struct CommandToken { @ engine/src/input_modes.rs:228
}

pub struct DistillationTask { @ engine/src/state.rs:210
}

/// Draft input buffer with cursor tracking.
pub struct DraftInput { @ engine/src/ui/input.rs:21
}

impl DraftInput {
    pub fn byte_index(&self) -> usize; @ engine/src/ui/input.rs:144
    pub fn clear(&mut self); @ engine/src/ui/input.rs:101
    pub fn cursor(&self) -> usize; @ engine/src/ui/input.rs:33
    pub fn delete_char(&mut self); @ engine/src/ui/input.rs:71
    pub fn delete_char_forward(&mut self); @ engine/src/ui/input.rs:82
    pub fn delete_word_backwards(&mut self); @ engine/src/ui/input.rs:112
    pub fn enter_char(&mut self, new_char: char); @ engine/src/ui/input.rs:51
    pub fn enter_newline(&mut self); @ engine/src/ui/input.rs:57
    pub fn enter_text(&mut self, text: &str); @ engine/src/ui/input.rs:61
    pub fn grapheme_count(&self) -> usize; @ engine/src/ui/input.rs:132
    pub fn move_cursor_end(&mut self); @ engine/src/ui/input.rs:97
    pub fn move_cursor_left(&mut self); @ engine/src/ui/input.rs:42
    pub fn move_cursor_right(&mut self); @ engine/src/ui/input.rs:46
    pub fn reset_cursor(&mut self); @ engine/src/ui/input.rs:93
    /// Set the draft text and move cursor to end.
    pub fn set_text(&mut self, text: String); @ engine/src/ui/input.rs:107
    pub fn take_text(&mut self) -> String; @ engine/src/ui/input.rs:37
    pub fn text(&self) -> &str; @ engine/src/ui/input.rs:28
}

/// Proof that a command line was entered in Command mode.
pub struct EnteredCommand { @ engine/src/input_modes.rs:218
}

/// Scanned file entry with display path and full path.
pub struct FileEntry { @ engine/src/ui/file_picker.rs:15
    /// Display path (relative to root, using forward slashes).
    pub display: String,
    /// Full absolute path.
    pub path: std::path::PathBuf,
}

/// File picker state for the "@" reference feature.
pub struct FilePickerState { @ engine/src/ui/file_picker.rs:24
}

impl FilePickerState {
    pub fn filtered_count(&self) -> usize; @ engine/src/ui/file_picker.rs:145
    /// Get filtered file entries for display.
    pub fn filtered_files(&self) -> Vec<&FileEntry>; @ engine/src/ui/file_picker.rs:130
    pub fn get_selected(&self, selected: usize) -> Option<&FileEntry>; @ engine/src/ui/file_picker.rs:138
    /// Check if files have been scanned.
    pub fn is_scanned(&self) -> bool; @ engine/src/ui/file_picker.rs:151
    pub fn new() -> Self; @ engine/src/ui/file_picker.rs:35
    /// Scan files from the given root directory, respecting .gitignore.
    pub fn scan_files(&mut self, root: &Path); @ engine/src/ui/file_picker.rs:40
    /// Get total file count (before filtering).
    pub fn total_count(&self) -> usize; @ engine/src/ui/file_picker.rs:157
    /// Update filtered results based on filter text.
    pub fn update_filter(&mut self, filter: &str); @ engine/src/ui/file_picker.rs:91
}

/// Interactive state for the files panel.
pub struct FilesPanelState { @ engine/src/ui/view_state.rs:22
    /// Whether the panel is visible.
    pub visible: bool,
    /// Index into the flattened file list (modified first, then created).
    pub selected: usize,
    /// Which file's diff is currently expanded (None = collapsed).
    pub expanded: Option<std::path::PathBuf>,
    /// Scroll offset within the diff view.
    pub diff_scroll: usize,
}

pub struct ForgeConfig { @ engine/src/config.rs:11
    pub app: Option<AppConfig>,
    pub api_keys: Option<ApiKeys>,
    pub context: Option<ContextConfig>,
    pub cache: Option<CacheConfig>,
    pub thinking: Option<ThinkingConfig>,
    pub anthropic: Option<AnthropicConfig>,
    pub openai: Option<OpenAIConfig>,
    pub google: Option<GeminiConfig>,
    /// Tool configurations for function calling.
    pub tools: Option<ToolsConfig>,
    /// LSP client configuration for language server diagnostics.
    pub lsp: Option<forge_lsp::LspConfig>,
}

impl ForgeConfig {
    pub fn load() -> Result<Option<Self>, ConfigError>; @ engine/src/config.rs:466
    pub fn path() -> Option<PathBuf>; @ engine/src/config.rs:493
    /// Persist the model to the config file.
    pub fn persist_model(model: &str) -> std::io::Result<()>; @ engine/src/config.rs:501
}

/// Input history for prompt and command recall.
pub struct InputHistory { @ engine/src/ui/history.rs:32
}

impl InputHistory {
    /// Navigate to the next (newer) command.
    pub fn navigate_command_down(&mut self) -> Option<&str>; @ engine/src/ui/history.rs:159
    /// Navigate to the previous (older) command.
    pub fn navigate_command_up(&mut self, current: &str) -> Option<&str>; @ engine/src/ui/history.rs:136
    /// Navigate to the next (newer) prompt.
    pub fn navigate_prompt_down(&mut self) -> Option<&str>; @ engine/src/ui/history.rs:116
    /// Navigate to the previous (older) prompt.
    pub fn navigate_prompt_up(&mut self, current: &str) -> Option<&str>; @ engine/src/ui/history.rs:93
    /// Add a command to history.
    pub fn push_command(&mut self, text: String); @ engine/src/ui/history.rs:75
    /// Add a prompt to history.
    pub fn push_prompt(&mut self, text: String); @ engine/src/ui/history.rs:58
    /// Reset navigation state.
    pub fn reset_navigation(&mut self); @ engine/src/ui/history.rs:178
}

/// Mode wrapper for safe insert operations.
pub struct InsertMode<'a> { @ engine/src/input_modes.rs:231
}

impl InsertMode<'a> {
    pub fn clear_line(&mut self); @ engine/src/input_modes.rs:315
    pub fn delete_char(&mut self); @ engine/src/input_modes.rs:295
    pub fn delete_char_forward(&mut self); @ engine/src/input_modes.rs:299
    pub fn delete_word_backwards(&mut self); @ engine/src/input_modes.rs:303
    pub fn enter_char(&mut self, new_char: char); @ engine/src/input_modes.rs:283
    pub fn enter_newline(&mut self); @ engine/src/input_modes.rs:287
    pub fn enter_text(&mut self, text: &str); @ engine/src/input_modes.rs:291
    pub fn move_cursor_end(&mut self); @ engine/src/input_modes.rs:311
    pub fn move_cursor_left(&mut self); @ engine/src/input_modes.rs:275
    pub fn move_cursor_right(&mut self); @ engine/src/input_modes.rs:279
    /// Queue the current draft as a user message.
    pub fn queue_message(self) -> Option<QueuedUserMessage>; @ engine/src/input_modes.rs:324
    pub fn reset_cursor(&mut self); @ engine/src/input_modes.rs:307
}

/// Proof token for Insert mode operations.
pub struct InsertToken { @ engine/src/input_modes.rs:224
}

/// Modal animation effect state.
pub struct ModalEffect { @ engine/src/ui/modal.rs:15
}

impl ModalEffect {
    /// Advance the animation by the given delta time.
    pub fn advance(&mut self, delta: Duration); @ engine/src/ui/modal.rs:50
    /// Check if the animation is finished.
    pub fn is_finished(&self) -> bool; @ engine/src/ui/modal.rs:67
    pub fn kind(&self) -> ModalEffectKind; @ engine/src/ui/modal.rs:72
    pub fn pop_scale(duration: Duration) -> Self; @ engine/src/ui/modal.rs:23
    /// Get the animation progress (0.0 to 1.0).
    pub fn progress(&self) -> f32; @ engine/src/ui/modal.rs:56
    pub fn shake(duration: Duration) -> Self; @ engine/src/ui/modal.rs:41
    pub fn slide_up(duration: Duration) -> Self; @ engine/src/ui/modal.rs:32
}

/// Animation state for the files panel.
pub struct PanelEffect { @ engine/src/ui/panel.rs:14
}

impl PanelEffect {
    /// Advance the animation by the given delta time.
    pub fn advance(&mut self, delta: Duration); @ engine/src/ui/panel.rs:40
    /// Check if the animation is finished.
    pub fn is_finished(&self) -> bool; @ engine/src/ui/panel.rs:57
    pub fn kind(&self) -> PanelEffectKind; @ engine/src/ui/panel.rs:62
    /// Get the animation progress (0.0 to 1.0).
    pub fn progress(&self) -> f32; @ engine/src/ui/panel.rs:46
    pub fn slide_in_right(duration: Duration) -> Self; @ engine/src/ui/panel.rs:22
    pub fn slide_out_right(duration: Duration) -> Self; @ engine/src/ui/panel.rs:31
}

/// Proof that a user message was validated and queued for sending.
pub struct QueuedUserMessage { @ engine/src/input_modes.rs:211
}

/// Tracks files created and modified during a session.
pub struct SessionChangeLog { @ engine/src/session_state.rs:20
    /// Files created during the session.
    pub created: std::collections::BTreeSet<std::path::PathBuf>,
    /// Files modified (but not created) during the session.
    pub modified: std::collections::BTreeSet<std::path::PathBuf>,
}

impl SessionChangeLog {
    /// Returns true if no files have been created or modified.
    pub fn is_empty(&self) -> bool; @ engine/src/session_state.rs:47
    /// Merge a turn's changes into the session-wide log.
    pub fn merge_turn(&mut self, created: &BTreeSet<PathBuf>, modified: &BTreeSet<PathBuf>); @ engine/src/session_state.rs:33
}

/// An in-flight streaming response from an LLM.
pub struct StreamingMessage { @ engine/src/lib.rs:170
}

impl StreamingMessage {
    pub fn apply_event(&mut self, event: StreamEvent) -> Option<StreamFinishReason>; @ engine/src/lib.rs:238
    pub fn content(&self) -> &str; @ engine/src/lib.rs:214
    pub fn has_tool_calls(&self) -> bool; @ engine/src/lib.rs:300
    pub fn into_message(self) -> Result<Message, forge_types::EmptyStringError>; @ engine/src/lib.rs:380
    pub fn model_name(&self) -> &ModelName; @ engine/src/lib.rs:209
    pub fn new(model: ModelName, receiver: mpsc::Receiver<StreamEvent>, max_tool_args_bytes: usize) -> Self; @ engine/src/lib.rs:186
    pub fn provider(&self) -> Provider; @ engine/src/lib.rs:204
    pub fn thinking(&self) -> &str; @ engine/src/lib.rs:219
    pub const fn thinking_signature_state(&self) -> &ThoughtSignatureState; @ engine/src/lib.rs:224
    pub fn try_recv_event(&mut self) -> Result<StreamEvent, mpsc::error::TryRecvError>; @ engine/src/lib.rs:234
    /// API-reported token usage accumulated during streaming.
    pub fn usage(&self) -> ApiUsage; @ engine/src/lib.rs:230
}

pub struct SystemPrompts { @ engine/src/lib.rs:387
    /// Claude-specific prompt.
    pub claude: &'static str,
    /// OpenAI-specific prompt.
    pub openai: &'static str,
    /// Gemini-specific prompt.
    pub gemini: &'static str,
}

impl SystemPrompts {
    pub fn get(&self, provider: Provider) -> &'static str; @ engine/src/lib.rs:398
}

/// Aggregated API usage for a user turn (may include multiple API calls).
pub struct TurnUsage { @ engine/src/lib.rs:117
    /// Number of API calls made during this turn.
    pub api_calls: u32,
    /// Total usage aggregated across all API calls.
    pub total: ApiUsage,
    /// Usage from the most recent API call (for display).
    pub last_call: ApiUsage,
}

impl TurnUsage {
    pub fn record_call(&mut self, usage: ApiUsage); @ engine/src/lib.rs:127
}

/// UI configuration options derived from config/environment.
pub struct UiOptions { @ engine/src/ui/view_state.rs:35
    pub ascii_only: bool,
    pub high_contrast: bool,
    pub reduced_motion: bool,
    /// Whether to render provider thinking/reasoning deltas (if available).
    pub show_thinking: bool,
}

/// State related to rendering and UI display.
pub struct ViewState { @ engine/src/ui/view_state.rs:49
    /// Scroll position for the message view.
    pub scroll: super::ScrollState,
    /// Maximum scroll offset (content length - viewport).
    pub scroll_max: u16,
    /// Request to clear the visible transcript (handled by the UI).
    pub clear_transcript: bool,
    /// Active modal animation effect.
    pub modal_effect: Option<super::ModalEffect>,
    /// Active files panel animation effect.
    pub files_panel_effect: Option<super::PanelEffect>,
    /// UI options (theme, motion, glyphs).
    pub ui_options: UiOptions,
    /// Timestamp of last frame (for animation timing).
    pub last_frame: std::time::Instant,
    /// Interactive state for the files panel.
    pub files_panel: FilesPanelState,
}

impl ViewState {
    pub fn new() -> Self; @ engine/src/ui/view_state.rs:85
}

impl Default for ViewState {
    fn default() -> Self;
}

/// Classification of file changes for display.
pub enum ChangeKind { @ engine/src/ui/view_state.rs:13
    /// File existed before and was modified.
    Modified,
    /// File was created during this session.
    Created,
}

/// An item to display in the message view.
pub enum DisplayItem { @ engine/src/ui/display.rs:11
    /// A message from persisted history, referenced by ID.
    History(forge_context::MessageId),
    /// A local message not yet in history (e.g., error messages, system notices).
    Local(forge_types::Message),
}

/// Result of diff generation for panel display.
pub enum FileDiff { @ engine/src/lib.rs:102
    /// Unified diff between baseline and current.
    Diff(String),
    /// File was created (no baseline) - show full content as additions.
    Created(String),
    /// File no longer exists on disk.
    Deleted,
    /// Binary file - show size only.
    Binary(usize),
    /// Error reading file.
    Error(String),
}

/// Input mode for the application.
pub enum InputMode { @ engine/src/ui/input.rs:8
    Normal,
    Insert,
    Command,
    ModelSelect,
    FileSelect,
}

/// The kind of modal animation effect.
pub enum ModalEffectKind { @ engine/src/ui/modal.rs:7
    PopScale,
    SlideUp,
    Shake,
}

/// The kind of panel animation effect.
pub enum PanelEffectKind { @ engine/src/ui/panel.rs:7
    SlideInRight,
    SlideOutRight,
}

/// Scroll position for the message view.
pub enum ScrollState { @ engine/src/ui/scroll.rs:5
    /// Always keep the newest content visible.
    AutoBottom,
    /// Manual scroll offset from the top of the rendered message buffer.
    Manual {
        offset_from_top: u16,
    },
}

/// A system notification that Forge can inject into the conversation.
pub enum SystemNotification { @ engine/src/notifications.rs:24
    /// User approved tool calls.
    ToolsApproved {
        /// Number of tools approved.
        count: u8,
    },
    /// User denied tool calls.
    ToolsDenied {
        /// Number of tools denied.
        count: u8,
    },
    /// Compiler/linter diagnostics found in recently edited files.
    DiagnosticsFound {
        /// Pre-formatted summary (e.g. "src/main.rs:42: error: expected `;`").
        summary: String,
    },
}

impl SystemNotification {
    /// Format the notification as a human-readable string.
    pub fn format(&self) -> String; @ engine/src/notifications.rs:48
}
```

## forge-tui

```rust
/// Apply a modal effect to transform the base rectangle.
pub fn apply_modal_effect(effect: &forge_engine::ModalEffect, base: ratatui::layout::Rect, viewport: ratatui::layout::Rect) -> ratatui::layout::Rect; @ tui/src/effects.rs:9

/// Clear the render cache. Call when switching themes or on memory pressure.
pub fn clear_render_cache(); @ tui/src/markdown.rs:108

pub fn draw(frame: &mut ratatui::Frame<'_>, app: &mut forge_engine::App); @ tui/src/lib.rs:102

pub fn draw_model_selector(frame: &mut ratatui::Frame<'_>, app: &mut forge_engine::App, palette: &Palette, glyphs: &Glyphs, elapsed: std::time::Duration); @ tui/src/lib.rs:1575

pub fn glyphs(options: forge_engine::UiOptions) -> Glyphs; @ tui/src/theme.rs:176

pub fn handle_events(app: &mut forge_engine::App, input: &mut InputPump) -> anyhow::Result<bool>; @ tui/src/input.rs:161

pub fn palette(options: forge_engine::UiOptions) -> Palette; @ tui/src/theme.rs:136

/// Render markdown content to ratatui Lines.
pub fn render_markdown(content: &str, base_style: ratatui::style::Style, palette: &crate::theme::Palette, max_width: u16) -> Vec<ratatui::text::Line<'static>>; @ tui/src/markdown.rs:119

/// Get spinner frame based on tick count and UI options.
pub fn spinner_frame(tick: usize, options: forge_engine::UiOptions) -> &'static str; @ tui/src/theme.rs:236

/// ASCII/Unicode glyphs for icons and spinners.
pub struct Glyphs { @ tui/src/theme.rs:146
    pub system: &'static str,
    pub user: &'static str,
    pub assistant: &'static str,
    pub thinking: &'static str,
    pub tool: &'static str,
    pub tool_result_ok: &'static str,
    pub tool_result_err: &'static str,
    pub tree_connector: &'static str,
    pub status_ready: &'static str,
    pub status_missing: &'static str,
    pub pending: &'static str,
    pub denied: &'static str,
    pub paused: &'static str,
    pub running: &'static str,
    pub bullet: &'static str,
    pub arrow_up: &'static str,
    pub arrow_down: &'static str,
    pub track: &'static str,
    pub thumb: &'static str,
    pub selected: &'static str,
    pub spinner_frames: &'static [&'static str],
    pub add: &'static str,
    pub modified: &'static str,
}

pub struct InputPump { @ tui/src/input.rs:82
}

impl InputPump {
    pub fn new() -> Self; @ tui/src/input.rs:91
    pub async fn shutdown(&mut self); @ tui/src/input.rs:106
}

impl Default for InputPump {
    fn default() -> Self;
}

impl Drop for InputPump {
    fn drop(&mut self);
}

pub struct MessageLinesCache { @ tui/src/lib.rs:50
}

/// Resolved theme palette used by the UI.
pub struct Palette { @ tui/src/theme.rs:52
    pub bg_dark: ratatui::style::Color,
    pub bg_panel: ratatui::style::Color,
    pub bg_highlight: ratatui::style::Color,
    pub bg_popup: ratatui::style::Color,
    pub bg_border: ratatui::style::Color,
    pub text_primary: ratatui::style::Color,
    pub text_secondary: ratatui::style::Color,
    pub text_muted: ratatui::style::Color,
    pub text_disabled: ratatui::style::Color,
    pub primary: ratatui::style::Color,
    pub primary_dim: ratatui::style::Color,
    pub accent: ratatui::style::Color,
    pub success: ratatui::style::Color,
    pub warning: ratatui::style::Color,
    pub error: ratatui::style::Color,
    pub peach: ratatui::style::Color,
    pub green: ratatui::style::Color,
    pub yellow: ratatui::style::Color,
    pub red: ratatui::style::Color,
    pub provider_claude: ratatui::style::Color,
    pub provider_openai: ratatui::style::Color,
    pub provider_gemini: ratatui::style::Color,
}

impl Palette {
    pub fn high_contrast() -> Self; @ tui/src/theme.rs:107
    pub fn standard() -> Self; @ tui/src/theme.rs:79
}
```

## forge-webfetch

```rust
pub async fn fetch(input: WebFetchInput, config: &WebFetchConfig) -> Result<WebFetchOutput, WebFetchError>; @ webfetch/src/lib.rs:25

/// Browser-specific configuration.
pub struct BrowserConfig { @ webfetch/src/types.rs:377
    /// Whether browser fallback is enabled. Default: true.
    pub enabled: bool,
    /// Path to Chromium executable.
    pub chromium_path: Option<std::path::PathBuf>,
    /// Browser navigation timeout in seconds.
    pub timeout_seconds: Option<u32>,
    /// Maximum rendered DOM size in bytes.
    pub max_rendered_dom_bytes: Option<u64>,
    /// Maximum subresource download bytes.
    pub max_subresource_bytes: Option<u64>,
    /// Blocked resource types (e.g., "image", "font").
    pub blocked_resource_types: Option<Vec<String>>,
}

/// Error details as key-value pairs.
pub struct ErrorDetails { @ webfetch/src/types.rs:583
    Vec<(String, String)>,
}

/// A chunk of extracted content.
pub struct FetchChunk { @ webfetch/src/types.rs:177
    /// Most recent preceding heading text, or empty string if none.
    pub heading: String,
    /// Chunk content as Markdown.
    pub text: String,
    /// Token count of `text` field only.
    pub token_count: u32,
}

/// HTTP-specific configuration.
pub struct HttpConfig { @ webfetch/src/types.rs:418
    /// Additional request headers.
    pub headers: Option<Vec<(String, String)>>,
    /// Use system proxy settings (`HTTP_PROXY/HTTPS_PROXY`).
    pub use_system_proxy: bool,
    /// Connect timeout in seconds.
    pub connect_timeout_seconds: Option<u32>,
    /// Read timeout in seconds.
    pub read_timeout_seconds: Option<u32>,
}

/// robots.txt-specific configuration.
pub struct RobotsConfig { @ webfetch/src/types.rs:435
    /// User-agent token for robots.txt matching.
    pub user_agent_token: Option<String>,
    /// Fail-open if robots.txt unavailable. Default: false.
    pub fail_open: bool,
}

/// Security-specific configuration.
pub struct SecurityConfig { @ webfetch/src/types.rs:400
    /// Additional blocked CIDR ranges.
    pub blocked_cidrs: Option<Vec<String>>,
    /// Allowed ports (overrides default allowlist).
    pub allowed_ports: Option<Vec<u16>>,
    /// Allow insecure TLS (for testing only).
    pub allow_insecure_tls: bool,
    /// Require explicit override for security relaxations.
    pub allow_insecure_overrides: bool,
}

/// `WebFetch` tool configuration.
pub struct WebFetchConfig { @ webfetch/src/types.rs:258
    /// Whether the tool is enabled. Default: true.
    pub enabled: bool,
    /// User-Agent string for HTTP requests.
    pub user_agent: Option<String>,
    /// Request timeout in seconds. Default: 20.
    pub timeout_seconds: Option<u32>,
    /// Maximum redirects to follow. Default: 5.
    pub max_redirects: Option<u32>,
    /// Default max tokens per chunk. Default: 600.
    pub default_max_chunk_tokens: Option<u32>,
    /// Cache directory path.
    pub cache_dir: Option<std::path::PathBuf>,
    /// Cache TTL in days. Default: 7.
    pub cache_ttl_days: Option<u32>,
    /// Maximum cache entries. Default: 1000.
    pub max_cache_entries: Option<u32>,
    /// Maximum total cache size in bytes. Default: 1 GiB.
    pub max_cache_bytes: Option<u64>,
    /// Maximum download size in bytes. Default: 10 MiB.
    pub max_download_bytes: Option<u64>,
    /// Maximum DNS resolution attempts. Default: 3.
    pub max_dns_attempts: Option<u32>,
    /// robots.txt cache entries. Default: 100.
    pub robots_cache_entries: Option<u32>,
    /// robots.txt cache TTL in hours. Default: 24.
    pub robots_cache_ttl_hours: Option<u32>,
    /// Allow auto-execution without approval prompts.
    pub allow_auto_execution: bool,
    /// Browser-specific configuration.
    pub browser: Option<BrowserConfig>,
    /// Security-specific configuration.
    pub security: Option<SecurityConfig>,
    /// HTTP-specific configuration.
    pub http: Option<HttpConfig>,
    /// robots.txt-specific configuration.
    pub robots: Option<RobotsConfig>,
}

impl WebFetchConfig {
    pub fn default_max_chunk_tokens(&self) -> u32; @ webfetch/src/types.rs:363
    pub fn max_download_bytes(&self) -> u64; @ webfetch/src/types.rs:369
    pub fn max_redirects(&self) -> u32; @ webfetch/src/types.rs:358
    pub fn timeout_seconds(&self) -> u32; @ webfetch/src/types.rs:352
}

/// `WebFetch` error with structured details.
pub struct WebFetchError { @ webfetch/src/types.rs:453
    /// Stable error code.
    pub code: ErrorCode,
    /// Human-readable description.
    pub message: String,
    /// Whether retry may succeed.
    pub retryable: bool,
    /// Error-specific context.
    pub details: ErrorDetails,
}

impl WebFetchError {
    pub fn new<impl Into<String>: Into<String>>(code: ErrorCode, message: impl Into<String>, retryable: bool) -> Self; @ webfetch/src/types.rs:468
    /// Serialize to JSON for tool output.
    pub fn to_json(&self) -> serde_json::Value; @ webfetch/src/types.rs:485
    /// Add a detail field.
    pub fn with_detail<impl Into<String>: Into<String>, impl Into<String>: Into<String>>(self, key: impl Into<String>, value: impl Into<String>) -> Self; @ webfetch/src/types.rs:478
}

impl Serialize for WebFetchError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where S: serde::Serializer;
}

/// Input parameters for a `WebFetch` request.
pub struct WebFetchInput { @ webfetch/src/types.rs:20
    /// Maximum tokens per chunk. Default: config value (typically 600).
    /// Must be in range [128, 2048] per FR-WF-02a.
    pub max_chunk_tokens: Option<u32>,
    /// If true, bypass cache and fetch fresh. Default: false.
    pub no_cache: bool,
    /// If true, force browser rendering even if HTTP succeeds. Default: false.
    pub force_browser: bool,
}

impl WebFetchInput {
    /// Create a new `WebFetchInput` from a URL string.
    pub fn new<impl Into<String>: Into<String>>(url: impl Into<String>) -> Result<Self, WebFetchError>; @ webfetch/src/types.rs:52
    pub fn original_url(&self) -> &str; @ webfetch/src/types.rs:126
    pub fn url(&self) -> &Url; @ webfetch/src/types.rs:121
    pub fn with_force_browser(self, force_browser: bool) -> Self; @ webfetch/src/types.rs:115
    /// # Errors
    pub fn with_max_chunk_tokens(self, tokens: u32) -> Result<Self, WebFetchError>; @ webfetch/src/types.rs:87
    pub fn with_no_cache(self, no_cache: bool) -> Self; @ webfetch/src/types.rs:109
}

/// Successful response from `WebFetch`.
pub struct WebFetchOutput { @ webfetch/src/types.rs:135
    /// Original input URL as provided (unchanged). FR-WF-RESP-URL-01.
    pub requested_url: String,
    /// Canonicalized URL of last fetched URL with fragment removed. FR-WF-RESP-URL-01.
    pub final_url: String,
    /// Original fetch time (RFC3339, second precision). FR-WF-CCH-TS-01.
    pub fetched_at: String,
    /// Page title from `<title>` or first `<h1>`. Optional.
    pub title: Option<String>,
    /// Language from `<html lang>` (BCP-47 tag). Optional.
    pub language: Option<String>,
    /// Content chunks. FR-WF-03b.
    pub chunks: Vec<FetchChunk>,
    /// Method used to fetch content. FR-WF-RESP-METHOD-01.
    pub rendering_method: RenderingMethod,
    /// True if content is incomplete. FR-WF-TRUNC-01.
    pub truncated: bool,
    /// Reason for truncation (if truncated). FR-WF-TRUNC-REASON-01.
    pub truncation_reason: Option<TruncationReason>,
    /// Condition tokens from fetch pipeline. FR-WF-03c.
    pub notes: Vec<Note>,
}

/// Error codes per FR-WF-18 registry.
pub enum ErrorCode { @ webfetch/src/types.rs:519
    /// Invalid request parameters.
    BadArgs,
    /// URL parsing failed.
    InvalidUrl,
    /// Non-http(s) scheme.
    InvalidScheme,
    /// Invalid host (e.g., numeric IP forms).
    InvalidHost,
    /// Port not in allowlist.
    PortBlocked,
    /// SSRF protection triggered.
    SsrfBlocked,
    /// DNS resolution failed.
    DnsFailed,
    /// robots.txt disallows path.
    RobotsDisallowed,
    /// Could not fetch robots.txt.
    RobotsUnavailable,
    /// Max redirects exceeded.
    RedirectLimit,
    /// Request timeout.
    Timeout,
    /// Network/connection error.
    Network,
    /// Response exceeds size limit.
    ResponseTooLarge,
    /// Content-Type not supported.
    UnsupportedContentType,
    /// HTTP 4xx client error.
    Http4xx,
    /// HTTP 5xx server error.
    Http5xx,
    /// Chromium not found/runnable.
    BrowserUnavailable,
    /// Browser process crashed.
    BrowserCrashed,
    /// HTML extraction failed.
    ExtractionFailed,
    /// Unexpected internal error.
    Internal,
}

impl ErrorCode {
    /// Check if this error code is retryable by default.
    pub fn default_retryable(&self) -> bool; @ webfetch/src/types.rs:567
}

/// Condition tokens for the `notes` array.
pub enum Note { @ webfetch/src/types.rs:215
    /// HTTP URL was automatically upgraded to HTTPS.
    HttpUpgradedToHttps,
    /// Response served from cache.
    CacheHit,
    /// robots.txt unavailable but `fail_open=true`.
    RobotsUnavailableFailOpen,
    /// Browser fallback requested but unavailable.
    BrowserUnavailableUsedHttp,
    /// DOM exceeded `max_rendered_dom_bytes`.
    BrowserDomTruncated,
    /// Browser blocked non-GET/HEAD subrequests.
    BrowserBlockedNonGet,
    /// Unknown charset; fell back to UTF-8 with replacement.
    CharsetFallback,
    /// Cache write failed (fetch still succeeded).
    CacheWriteFailed,
    /// Output truncated to fit byte budget.
    ToolOutputLimit,
}

impl Note {
    /// Canonical ordering per FR-WF-NOTES-ORDER-01.
    pub fn order(&self) -> u8; @ webfetch/src/types.rs:239
}

/// Method used to render/fetch the page.
pub enum RenderingMethod { @ webfetch/src/types.rs:191
    /// Standard HTTP fetch.
    Http,
    /// Headless browser rendering.
    Browser,
}

/// Reason for content truncation.
pub enum TruncationReason { @ webfetch/src/types.rs:203
    /// Output byte budget enforcement truncated chunks.
    ToolOutputLimit,
    /// Browser DOM exceeded `max_rendered_dom_bytes`.
    BrowserDomTruncated,
}
```

## forge-lsp

```rust
pub struct DiagnosticsSnapshot { @ lsp/src/types.rs:239
}

impl DiagnosticsSnapshot {
    /// Number of error-level diagnostics.
    pub fn error_count(&self) -> usize; @ lsp/src/types.rs:272
    /// Per-file diagnostics, sorted with error-containing files first.
    pub fn files(&self) -> &[(PathBuf, Vec<ForgeDiagnostic>)]; @ lsp/src/types.rs:252
    /// Number of hint-level diagnostics.
    pub fn hint_count(&self) -> usize; @ lsp/src/types.rs:290
    /// Number of info-level diagnostics.
    pub fn info_count(&self) -> usize; @ lsp/src/types.rs:284
    /// Whether there are any diagnostics.
    pub fn is_empty(&self) -> bool; @ lsp/src/types.rs:258
    /// Format a compact status string like "E:3 W:5".
    pub fn status_string(&self) -> String; @ lsp/src/types.rs:302
    /// Total diagnostic count across all files.
    pub fn total_count(&self) -> usize; @ lsp/src/types.rs:296
    /// Number of warning-level diagnostics.
    pub fn warning_count(&self) -> usize; @ lsp/src/types.rs:278
}

pub struct ForgeDiagnostic { @ lsp/src/types.rs:142
}

impl ForgeDiagnostic {
    /// 0-indexed column.
    pub fn col(&self) -> u32; @ lsp/src/types.rs:190
    /// Format as `path:line:col: severity: message` (1-indexed for display).
    pub fn display_with_path(&self, path: &std::path::Path) -> String; @ lsp/src/types.rs:202
    /// 0-indexed line number.
    pub fn line(&self) -> u32; @ lsp/src/types.rs:184
    pub fn message(&self) -> &str; @ lsp/src/types.rs:178
    pub fn new(severity: DiagnosticSeverity, message: String, line: u32, col: u32, source: String) -> Self; @ lsp/src/types.rs:156
    pub fn severity(&self) -> DiagnosticSeverity; @ lsp/src/types.rs:173
    /// Source of the diagnostic (e.g. "rustc", "clippy").
    pub fn source(&self) -> &str; @ lsp/src/types.rs:196
}

pub struct FrameReader<R> { @ lsp/src/codec.rs:8
}

impl FrameReader<R> {
    pub fn new(reader: R) -> Self; @ lsp/src/codec.rs:13
    pub async fn read_frame(&mut self) -> Result<Option<serde_json::Value>>; @ lsp/src/codec.rs:19
}

pub struct FrameWriter<W> { @ lsp/src/codec.rs:91
}

impl FrameWriter<W> {
    pub fn new(writer: W) -> Self; @ lsp/src/codec.rs:96
    pub async fn write_frame(&mut self, msg: &serde_json::Value) -> Result<()>; @ lsp/src/codec.rs:100
}

pub struct LspConfig { @ lsp/src/types.rs:28
}

impl LspConfig {
    pub fn enabled(&self) -> bool; @ lsp/src/types.rs:37
    pub fn servers(&self) -> &HashMap<String, ServerConfig>; @ lsp/src/types.rs:42
}

pub struct LspManager { @ lsp/src/manager.rs:34
}

impl LspManager {
    /// Get only errors for specific files.
    pub fn errors_for_files(&self, paths: &[PathBuf]) -> Vec<(PathBuf, Vec<ForgeDiagnostic>)>; @ lsp/src/manager.rs:160
    pub fn has_running_servers(&self) -> bool; @ lsp/src/manager.rs:165
    pub async fn on_file_changed(&mut self, path: &Path, text: &str); @ lsp/src/manager.rs:81
    pub fn poll_events(&mut self, budget: usize) -> usize; @ lsp/src/manager.rs:113
    pub async fn shutdown(&mut self); @ lsp/src/manager.rs:169
    pub fn snapshot(&self) -> DiagnosticsSnapshot; @ lsp/src/manager.rs:154
    pub async fn start(config: LspConfig, workspace_root: &Path) -> Self; @ lsp/src/manager.rs:44
}

pub struct ServerConfig { @ lsp/src/types.rs:49
}

impl ServerConfig {
    pub fn args(&self) -> &[String]; @ lsp/src/types.rs:84
    pub fn command(&self) -> &str; @ lsp/src/types.rs:79
    pub fn file_extensions(&self) -> &[String]; @ lsp/src/types.rs:94
    pub fn language_id(&self) -> &str; @ lsp/src/types.rs:89
    pub fn root_markers(&self) -> &[String]; @ lsp/src/types.rs:99
}

/// Severity level for a diagnostic.
pub enum DiagnosticSeverity { @ lsp/src/types.rs:106
    Error,
    Warning,
    Information,
    Hint,
}

impl DiagnosticSeverity {
    pub fn from_lsp(value: u64) -> Option<Self>; @ lsp/src/types.rs:115
    pub fn is_error(self) -> bool; @ lsp/src/types.rs:126
    pub fn label(self) -> &'static str; @ lsp/src/types.rs:131
}

pub enum LspEvent { @ lsp/src/types.rs:225
    /// Server stopped running. Manager removes it from the active map.
    ServerStopped {
        server: String,
        reason: ServerStopReason,
    },
    /// Diagnostics updated for a file.
    Diagnostics {
        path: std::path::PathBuf,
        items: Vec<ForgeDiagnostic>,
    },
}

pub enum ServerConfigError { @ lsp/src/types.rs:8
    EmptyCommand,
    EmptyLanguageId,
}

/// Reason a language server stopped running.
pub enum ServerStopReason { @ lsp/src/types.rs:217
    /// Clean shutdown (EOF on stdout).
    Exited,
    /// Crashed or encountered an I/O error.
    Failed(String),
}
```

## forge

```rust
/// Eagerly initializes all system prompts.
pub fn init(); @ cli/src/assets.rs:40

/// Returns provider-specific system prompts for LLM initialization.
pub fn system_prompts() -> forge_engine::SystemPrompts; @ cli/src/assets.rs:50
```

