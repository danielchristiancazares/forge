diff --git a/Cargo.lock b/Cargo.lock
index f0661f2..b98423f 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -15,7 +15,9 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5a15f179cd60c4584b8a8c596927aadc462e27f2ca70c04e0071964a73ba7a75"
 dependencies = [
  "cfg-if",
+ "getrandom 0.3.4",
  "once_cell",
+ "serde",
  "version_check",
  "zerocopy",
 ]
@@ -35,6 +37,56 @@ version = "0.2.21"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"
 
+[[package]]
+name = "anstream"
+version = "0.6.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "43d5b281e737544384e969a5ccad3f1cdd24b48086a0fc1b2a5262a26b8f4f4a"
+dependencies = [
+ "anstyle",
+ "anstyle-parse",
+ "anstyle-query",
+ "anstyle-wincon",
+ "colorchoice",
+ "is_terminal_polyfill",
+ "utf8parse",
+]
+
+[[package]]
+name = "anstyle"
+version = "1.0.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5192cca8006f1fd4f7237516f40fa183bb07f8fbdfedaa0036de5ea9b0b45e78"
+
+[[package]]
+name = "anstyle-parse"
+version = "0.2.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
+dependencies = [
+ "utf8parse",
+]
+
+[[package]]
+name = "anstyle-query"
+version = "1.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "40c48f72fd53cd289104fc64099abca73db4166ad86ea0b4341abe65af83dadc"
+dependencies = [
+ "windows-sys 0.61.2",
+]
+
+[[package]]
+name = "anstyle-wincon"
+version = "3.0.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "291e6a250ff86cd4a820112fb8898808a366d8f9f58ce16d1f538353ad55747d"
+dependencies = [
+ "anstyle",
+ "once_cell_polyfill",
+ "windows-sys 0.61.2",
+]
+
 [[package]]
 name = "anyhow"
 version = "1.0.100"
@@ -163,6 +215,12 @@ version = "3.19.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5dd9dc738b7a8311c7ade152424974d8115f2cdad61e8dab8dac9f2362298510"
 
+[[package]]
+name = "bytecount"
+version = "0.6.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "175812e0be2bccb6abe50bb8d566126198344f707e304f45c648fd8f2cc0365e"
+
 [[package]]
 name = "bytemuck"
 version = "1.24.0"
@@ -212,6 +270,46 @@ version = "0.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"
 
+[[package]]
+name = "clap"
+version = "4.5.54"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c6e6ff9dcd79cff5cd969a17a545d79e84ab086e444102a591e288a8aa3ce394"
+dependencies = [
+ "clap_builder",
+ "clap_derive",
+]
+
+[[package]]
+name = "clap_builder"
+version = "4.5.54"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fa42cf4d2b7a41bc8f663a7cab4031ebafa1bf3875705bfaf8466dc60ab52c00"
+dependencies = [
+ "anstream",
+ "anstyle",
+ "clap_lex",
+ "strsim",
+]
+
+[[package]]
+name = "clap_derive"
+version = "4.5.49"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2a0b5487afeab2deb2ff4e03a807ad1a03ac532ff5a2cee5d86884440c7f7671"
+dependencies = [
+ "heck",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.114",
+]
+
+[[package]]
+name = "clap_lex"
+version = "0.7.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a1d728cc89cf3aee9ff92b05e62b19ee65a02b5702cff7d5a377e32c6ae29d8d"
+
 [[package]]
 name = "clipboard-win"
 version = "5.4.1"
@@ -221,6 +319,12 @@ dependencies = [
  "error-code",
 ]
 
+[[package]]
+name = "colorchoice"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"
+
 [[package]]
 name = "compact_str"
 version = "0.9.0"
@@ -256,6 +360,22 @@ dependencies = [
  "unicode-segmentation",
 ]
 
+[[package]]
+name = "core-foundation"
+version = "0.9.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
+dependencies = [
+ "core-foundation-sys",
+ "libc",
+]
+
+[[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
 [[package]]
 name = "cpufeatures"
 version = "0.2.17"
@@ -495,6 +615,15 @@ version = "1.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "34aa73646ffb006b8f5147f3dc182bd4bcb190227ce861fc4a4844bf8e3cb2c0"
 
+[[package]]
+name = "encoding_rs"
+version = "0.8.35"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
+dependencies = [
+ "cfg-if",
+]
+
 [[package]]
 name = "equivalent"
 version = "1.0.2"
@@ -675,7 +804,7 @@ dependencies = [
  "dirs",
  "forge-providers",
  "forge-types",
- "reqwest",
+ "reqwest 0.12.28",
  "rusqlite",
  "serde",
  "serde_json",
@@ -690,13 +819,18 @@ name = "forge-engine"
 version = "0.1.0"
 dependencies = [
  "anyhow",
+ "base64 0.22.1",
  "dirs",
  "forge-context",
  "forge-providers",
  "forge-types",
  "futures-util",
+ "globset",
+ "jsonschema",
+ "libc",
  "serde",
  "serde_json",
+ "sha2",
  "tempfile",
  "thiserror 2.0.17",
  "tokio",
@@ -712,7 +846,7 @@ dependencies = [
  "anyhow",
  "forge-types",
  "futures-util",
- "reqwest",
+ "reqwest 0.12.28",
  "serde",
  "serde_json",
  "thiserror 2.0.17",
@@ -754,6 +888,16 @@ dependencies = [
  "percent-encoding",
 ]
 
+[[package]]
+name = "fraction"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3027ae1df8d41b4bed2241c8fdad4acc1e7af60c8e17743534b545e77182d678"
+dependencies = [
+ "lazy_static",
+ "num",
+]
+
 [[package]]
 name = "futures"
 version = "0.3.31"
@@ -899,6 +1043,38 @@ dependencies = [
  "wasm-bindgen",
 ]
 
+[[package]]
+name = "globset"
+version = "0.4.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "52dfc19153a48bde0cbd630453615c8151bce3a5adfac7a0aebfbf0a1e1f57e3"
+dependencies = [
+ "aho-corasick",
+ "bstr",
+ "log",
+ "regex-automata",
+ "regex-syntax",
+]
+
+[[package]]
+name = "h2"
+version = "0.3.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0beca50380b1fc32983fc1cb4587bfa4bb9e78fc259aad4a0032d2080309222d"
+dependencies = [
+ "bytes",
+ "fnv",
+ "futures-core",
+ "futures-sink",
+ "futures-util",
+ "http 0.2.12",
+ "indexmap",
+ "slab",
+ "tokio",
+ "tokio-util",
+ "tracing",
+]
+
 [[package]]
 name = "h2"
 version = "0.4.13"
@@ -910,7 +1086,7 @@ dependencies = [
  "fnv",
  "futures-core",
  "futures-sink",
- "http",
+ "http 1.4.0",
  "indexmap",
  "slab",
  "tokio",
@@ -976,6 +1152,17 @@ version = "0.4.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"
 
+[[package]]
+name = "http"
+version = "0.2.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "601cbb57e577e2f5ef5be8e7b83f0f63994f25aa94d673e54a92d5c516d101f1"
+dependencies = [
+ "bytes",
+ "fnv",
+ "itoa",
+]
+
 [[package]]
 name = "http"
 version = "1.4.0"
@@ -986,6 +1173,17 @@ dependencies = [
  "itoa",
 ]
 
+[[package]]
+name = "http-body"
+version = "0.4.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7ceab25649e9960c0311ea418d17bee82c0dcec1bd053b5f9a66e265a693bed2"
+dependencies = [
+ "bytes",
+ "http 0.2.12",
+ "pin-project-lite",
+]
+
 [[package]]
 name = "http-body"
 version = "1.0.1"
@@ -993,7 +1191,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1efedce1fb8e6913f23e0c92de8e62cd5b772a67e7b3946df930a62566c93184"
 dependencies = [
  "bytes",
- "http",
+ "http 1.4.0",
 ]
 
 [[package]]
@@ -1004,8 +1202,8 @@ checksum = "b021d93e26becf5dc7e1b75b1bed1fd93124b374ceb73f43d4d4eafec896a64a"
 dependencies = [
  "bytes",
  "futures-core",
- "http",
- "http-body",
+ "http 1.4.0",
+ "http-body 1.0.1",
  "pin-project-lite",
 ]
 
@@ -1021,6 +1219,30 @@ version = "1.0.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "df3b46402a9d5adb4c86a0cf463f42e19994e3ee891101b1841f30a545cb49a9"
 
+[[package]]
+name = "hyper"
+version = "0.14.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "41dfc780fdec9373c01bae43289ea34c972e40ee3c9f6b3c8801a35f35586ce7"
+dependencies = [
+ "bytes",
+ "futures-channel",
+ "futures-core",
+ "futures-util",
+ "h2 0.3.27",
+ "http 0.2.12",
+ "http-body 0.4.6",
+ "httparse",
+ "httpdate",
+ "itoa",
+ "pin-project-lite",
+ "socket2 0.5.10",
+ "tokio",
+ "tower-service",
+ "tracing",
+ "want",
+]
+
 [[package]]
 name = "hyper"
 version = "1.8.1"
@@ -1031,9 +1253,9 @@ dependencies = [
  "bytes",
  "futures-channel",
  "futures-core",
- "h2",
- "http",
- "http-body",
+ "h2 0.4.13",
+ "http 1.4.0",
+ "http-body 1.0.1",
  "httparse",
  "httpdate",
  "itoa",
@@ -1050,8 +1272,8 @@ version = "0.27.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e3c93eb611681b207e1fe55d5a71ecf91572ec8a6705cdb6857f7d8d5242cf58"
 dependencies = [
- "http",
- "hyper",
+ "http 1.4.0",
+ "hyper 1.8.1",
  "hyper-util",
  "rustls",
  "rustls-pki-types",
@@ -1072,14 +1294,14 @@ dependencies = [
  "futures-channel",
  "futures-core",
  "futures-util",
- "http",
- "http-body",
- "hyper",
+ "http 1.4.0",
+ "http-body 1.0.1",
+ "hyper 1.8.1",
  "ipnet",
  "libc",
  "percent-encoding",
  "pin-project-lite",
- "socket2",
+ "socket2 0.6.1",
  "tokio",
  "tower-service",
  "tracing",
@@ -1268,6 +1490,21 @@ dependencies = [
  "serde",
 ]
 
+[[package]]
+name = "is_terminal_polyfill"
+version = "1.70.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a6cb138bb79a146c1bd460005623e142ef0181e3d0219cb493e02f7d08a35695"
+
+[[package]]
+name = "iso8601"
+version = "0.6.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e1082f0c48f143442a1ac6122f67e360ceee130b967af4d50996e5154a45df46"
+dependencies = [
+ "nom 8.0.0",
+]
+
 [[package]]
 name = "itertools"
 version = "0.13.0"
@@ -1302,6 +1539,36 @@ dependencies = [
  "wasm-bindgen",
 ]
 
+[[package]]
+name = "jsonschema"
+version = "0.17.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2a071f4f7efc9a9118dfb627a0a94ef247986e1ab8606a4c806ae2b3aa3b6978"
+dependencies = [
+ "ahash",
+ "anyhow",
+ "base64 0.21.7",
+ "bytecount",
+ "clap",
+ "fancy-regex 0.11.0",
+ "fraction",
+ "getrandom 0.2.16",
+ "iso8601",
+ "itoa",
+ "memchr",
+ "num-cmp",
+ "once_cell",
+ "parking_lot",
+ "percent-encoding",
+ "regex",
+ "reqwest 0.11.27",
+ "serde",
+ "serde_json",
+ "time",
+ "url",
+ "uuid",
+]
+
 [[package]]
 name = "kasuari"
 version = "0.4.11"
@@ -1449,6 +1716,12 @@ dependencies = [
  "autocfg",
 ]
 
+[[package]]
+name = "mime"
+version = "0.3.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"
+
 [[package]]
 name = "minimal-lexical"
 version = "0.2.1"
@@ -1510,6 +1783,15 @@ dependencies = [
  "minimal-lexical",
 ]
 
+[[package]]
+name = "nom"
+version = "8.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "df9761775871bdef83bee530e60050f7e54b1105350d6884eb0fb4f46c2f9405"
+dependencies = [
+ "memchr",
+]
+
 [[package]]
 name = "nu-ansi-term"
 version = "0.50.3"
@@ -1519,6 +1801,45 @@ dependencies = [
  "windows-sys 0.61.2",
 ]
 
+[[package]]
+name = "num"
+version = "0.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "35bd024e8b2ff75562e5f34e7f4905839deb4b22955ef5e73d2fea1b9813cb23"
+dependencies = [
+ "num-bigint",
+ "num-complex",
+ "num-integer",
+ "num-iter",
+ "num-rational",
+ "num-traits",
+]
+
+[[package]]
+name = "num-bigint"
+version = "0.4.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a5e44f723f1133c9deac646763579fdb3ac745e418f2a7af9cd0c431da1f20b9"
+dependencies = [
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-cmp"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "63335b2e2c34fae2fb0aa2cecfd9f0832a1e24b3b32ecec612c3426d46dc8aaa"
+
+[[package]]
+name = "num-complex"
+version = "0.4.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "73f88a1307638156682bada9d7604135552957b7818057dcef22705b4d509495"
+dependencies = [
+ "num-traits",
+]
+
 [[package]]
 name = "num-conv"
 version = "0.1.0"
@@ -1536,6 +1857,37 @@ dependencies = [
  "syn 2.0.114",
 ]
 
+[[package]]
+name = "num-integer"
+version = "0.1.46"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
+dependencies = [
+ "num-traits",
+]
+
+[[package]]
+name = "num-iter"
+version = "0.1.45"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1429034a0490724d0075ebb2bc9e875d6503c3cf69e235a8941aa757d83ef5bf"
+dependencies = [
+ "autocfg",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-rational"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f83d14da390562dca69fc84082e73e548e1ad308d24accdedd2720017cb37824"
+dependencies = [
+ "num-bigint",
+ "num-integer",
+ "num-traits",
+]
+
 [[package]]
 name = "num-traits"
 version = "0.2.19"
@@ -1643,6 +1995,12 @@ version = "1.21.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
 
+[[package]]
+name = "once_cell_polyfill"
+version = "1.70.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "384b8ab6d37215f3c5301a95a4accb5d64aa607f1fcb26a11b5303878451b4fe"
+
 [[package]]
 name = "option-ext"
 version = "0.2.0"
@@ -1909,7 +2267,7 @@ dependencies = [
  "quinn-udp",
  "rustc-hash 2.1.1",
  "rustls",
- "socket2",
+ "socket2 0.6.1",
  "thiserror 2.0.17",
  "tokio",
  "tracing",
@@ -1946,7 +2304,7 @@ dependencies = [
  "cfg_aliases",
  "libc",
  "once_cell",
- "socket2",
+ "socket2 0.6.1",
  "tracing",
  "windows-sys 0.60.2",
 ]
@@ -2144,6 +2502,42 @@ version = "0.8.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7a2d987857b319362043e95f5353c0535c1f58eec5336fdfcf626430af7def58"
 
+[[package]]
+name = "reqwest"
+version = "0.11.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dd67538700a17451e7cba03ac727fb961abb7607553461627b97de0b89cf4a62"
+dependencies = [
+ "base64 0.21.7",
+ "bytes",
+ "encoding_rs",
+ "futures-core",
+ "futures-util",
+ "h2 0.3.27",
+ "http 0.2.12",
+ "http-body 0.4.6",
+ "hyper 0.14.32",
+ "ipnet",
+ "js-sys",
+ "log",
+ "mime",
+ "once_cell",
+ "percent-encoding",
+ "pin-project-lite",
+ "serde",
+ "serde_json",
+ "serde_urlencoded",
+ "sync_wrapper 0.1.2",
+ "system-configuration",
+ "tokio",
+ "tower-service",
+ "url",
+ "wasm-bindgen",
+ "wasm-bindgen-futures",
+ "web-sys",
+ "winreg",
+]
+
 [[package]]
 name = "reqwest"
 version = "0.12.28"
@@ -2154,10 +2548,10 @@ dependencies = [
  "bytes",
  "futures-core",
  "futures-util",
- "http",
- "http-body",
+ "http 1.4.0",
+ "http-body 1.0.1",
  "http-body-util",
- "hyper",
+ "hyper 1.8.1",
  "hyper-rustls",
  "hyper-util",
  "js-sys",
@@ -2170,7 +2564,7 @@ dependencies = [
  "serde",
  "serde_json",
  "serde_urlencoded",
- "sync_wrapper",
+ "sync_wrapper 1.0.2",
  "tokio",
  "tokio-rustls",
  "tokio-util",
@@ -2457,6 +2851,16 @@ version = "1.15.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"
 
+[[package]]
+name = "socket2"
+version = "0.5.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
+dependencies = [
+ "libc",
+ "windows-sys 0.52.0",
+]
+
 [[package]]
 name = "socket2"
 version = "0.6.1"
@@ -2534,6 +2938,12 @@ dependencies = [
  "unicode-ident",
 ]
 
+[[package]]
+name = "sync_wrapper"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2047c6ded9c721764247e62cd3b03c09ffc529b2ba5b10ec482ae507a4a70160"
+
 [[package]]
 name = "sync_wrapper"
 version = "1.0.2"
@@ -2554,6 +2964,27 @@ dependencies = [
  "syn 2.0.114",
 ]
 
+[[package]]
+name = "system-configuration"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ba3a3adc5c275d719af8cb4272ea1c4a6d668a777f37e115f6d11ddbc1c8e0e7"
+dependencies = [
+ "bitflags 1.3.2",
+ "core-foundation",
+ "system-configuration-sys",
+]
+
+[[package]]
+name = "system-configuration-sys"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a75fb188eb626b924683e3b95e3a48e63551fcfb51949de2f06a9d91dbee93c9"
+dependencies = [
+ "core-foundation-sys",
+ "libc",
+]
+
 [[package]]
 name = "tempfile"
 version = "3.24.0"
@@ -2574,7 +3005,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d4ea810f0692f9f51b382fff5893887bb4580f5fa246fde546e0b13e7fcee662"
 dependencies = [
  "fnv",
- "nom",
+ "nom 7.1.3",
  "phf",
  "phf_codegen",
 ]
@@ -2722,6 +3153,7 @@ dependencies = [
  "powerfmt",
  "serde",
  "time-core",
+ "time-macros",
 ]
 
 [[package]]
@@ -2730,6 +3162,16 @@ version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "40868e7c1d2f0b8d73e4a8c7f0ff63af4f6d19be117e90bd73eb1d62cf831c6b"
 
+[[package]]
+name = "time-macros"
+version = "0.2.24"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "30cfb0125f12d9c277f35663a0a33f8c30190f4e4574868a330595412d34ebf3"
+dependencies = [
+ "num-conv",
+ "time-core",
+]
+
 [[package]]
 name = "tinystr"
 version = "0.8.2"
@@ -2767,7 +3209,7 @@ dependencies = [
  "parking_lot",
  "pin-project-lite",
  "signal-hook-registry",
- "socket2",
+ "socket2 0.6.1",
  "tokio-macros",
  "windows-sys 0.61.2",
 ]
@@ -2878,7 +3320,7 @@ dependencies = [
  "futures-core",
  "futures-util",
  "pin-project-lite",
- "sync_wrapper",
+ "sync_wrapper 1.0.2",
  "tokio",
  "tower-layer",
  "tower-service",
@@ -2893,8 +3335,8 @@ dependencies = [
  "bitflags 2.10.0",
  "bytes",
  "futures-util",
- "http",
- "http-body",
+ "http 1.4.0",
+ "http-body 1.0.1",
  "iri-string",
  "pin-project-lite",
  "tower",
@@ -3606,6 +4048,16 @@ dependencies = [
  "memchr",
 ]
 
+[[package]]
+name = "winreg"
+version = "0.50.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "524e57b2c537c0f9b1e69f1965311ec12182b4122e45035b1508cd24d2adadb1"
+dependencies = [
+ "cfg-if",
+ "windows-sys 0.48.0",
+]
+
 [[package]]
 name = "wiremock"
 version = "0.6.5"
@@ -3616,9 +4068,9 @@ dependencies = [
  "base64 0.22.1",
  "deadpool",
  "futures",
- "http",
+ "http 1.4.0",
  "http-body-util",
- "hyper",
+ "hyper 1.8.1",
  "hyper-util",
  "log",
  "once_cell",
diff --git a/Cargo.toml b/Cargo.toml
index a4ea32e..2a8dea2 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -39,6 +39,12 @@ serde = { version = "1.0", features = ["derive"] }
 serde_json = "1.0"
 toml = "0.8"
 
+# Tooling
+base64 = "0.22"
+globset = "0.4"
+jsonschema = "0.17"
+sha2 = "0.10"
+
 # Error handling
 anyhow = "1.0"
 thiserror = "2.0"
diff --git a/context/src/lib.rs b/context/src/lib.rs
index aed6197..42632e6 100644
--- a/context/src/lib.rs
+++ b/context/src/lib.rs
@@ -23,6 +23,7 @@ mod history;
 mod manager;
 mod model_limits;
 mod stream_journal;
+mod tool_journal;
 mod summarization;
 mod token_counter;
 mod working_context;
@@ -34,6 +35,7 @@ pub use manager::{
 };
 pub use model_limits::{ModelLimits, ModelLimitsSource, ModelRegistry, ResolvedModelLimits};
 pub use stream_journal::{ActiveJournal, JournalStats, RecoveredStream, StepId, StreamJournal};
+pub use tool_journal::{RecoveredToolBatch, ToolBatchId, ToolJournal};
 pub use summarization::{generate_summary, summarization_model};
 pub use token_counter::TokenCounter;
 pub use working_context::{ContextSegment, ContextUsage, WorkingContext};
diff --git a/engine/Cargo.toml b/engine/Cargo.toml
index fcd9833..ef9c1f0 100644
--- a/engine/Cargo.toml
+++ b/engine/Cargo.toml
@@ -10,11 +10,16 @@ forge-types.workspace = true
 forge-providers.workspace = true
 forge-context.workspace = true
 
-tokio = { workspace = true, features = ["sync", "rt"] }
+tokio = { workspace = true, features = ["sync", "rt", "time", "process", "io-util", "fs"] }
 
 serde.workspace = true
 serde_json.workspace = true
 toml.workspace = true
+base64.workspace = true
+globset.workspace = true
+jsonschema.workspace = true
+sha2.workspace = true
+tempfile.workspace = true
 
 anyhow.workspace = true
 thiserror.workspace = true
@@ -26,6 +31,9 @@ tracing.workspace = true
 
 unicode-segmentation.workspace = true
 
+[target.'cfg(unix)'.dependencies]
+libc = "0.2"
+
 [dev-dependencies]
 tokio = { workspace = true, features = ["full"] }
 tempfile.workspace = true
diff --git a/engine/src/config.rs b/engine/src/config.rs
index d8d9417..67fe5d9 100644
--- a/engine/src/config.rs
+++ b/engine/src/config.rs
@@ -96,9 +96,33 @@ pub struct OpenAIConfig {
 /// ```
 #[derive(Debug, Default, Deserialize)]
 pub struct ToolsConfig {
+    /// Tool loop mode: disabled | parse_only | enabled
+    pub mode: Option<String>,
+    /// Whether parallel tool execution is allowed.
+    pub allow_parallel: Option<bool>,
+    /// Maximum tool calls per batch.
+    pub max_tool_calls_per_batch: Option<usize>,
+    /// Maximum tool iterations per user turn.
+    pub max_tool_iterations_per_user_turn: Option<u32>,
+    /// Maximum serialized tool args size (bytes).
+    pub max_tool_args_bytes: Option<usize>,
     /// List of tool definitions.
     #[serde(default)]
     pub definitions: Vec<ToolDefinitionConfig>,
+    /// Sandbox config.
+    pub sandbox: Option<ToolSandboxConfig>,
+    /// Timeout config.
+    pub timeouts: Option<ToolTimeoutsConfig>,
+    /// Output config.
+    pub output: Option<ToolOutputConfig>,
+    /// Environment sanitization config.
+    pub environment: Option<ToolEnvironmentConfig>,
+    /// Approval policy config.
+    pub approval: Option<ToolApprovalConfig>,
+    /// read_file limits.
+    pub read_file: Option<ReadFileConfig>,
+    /// apply_patch limits.
+    pub apply_patch: Option<ApplyPatchConfig>,
 }
 
 /// Configuration for a single tool definition.
@@ -110,6 +134,63 @@ pub struct ToolDefinitionConfig {
     pub parameters: toml::Value,
 }
 
+/// Sandbox configuration for tools.
+#[derive(Debug, Default, Deserialize)]
+pub struct ToolSandboxConfig {
+    #[serde(default)]
+    pub allowed_roots: Vec<String>,
+    #[serde(default)]
+    pub denied_patterns: Vec<String>,
+    pub allow_absolute: Option<bool>,
+    pub include_default_denies: Option<bool>,
+}
+
+/// Timeout configuration for tools.
+#[derive(Debug, Default, Deserialize)]
+pub struct ToolTimeoutsConfig {
+    pub default_seconds: Option<u64>,
+    pub file_operations_seconds: Option<u64>,
+    pub shell_commands_seconds: Option<u64>,
+}
+
+/// Output configuration for tools.
+#[derive(Debug, Default, Deserialize)]
+pub struct ToolOutputConfig {
+    pub max_bytes: Option<usize>,
+}
+
+/// Environment sanitization configuration for tools.
+#[derive(Debug, Default, Deserialize)]
+pub struct ToolEnvironmentConfig {
+    #[serde(default)]
+    pub denylist: Vec<String>,
+}
+
+/// Approval policy configuration for tools.
+#[derive(Debug, Default, Deserialize)]
+pub struct ToolApprovalConfig {
+    pub enabled: Option<bool>,
+    pub mode: Option<String>,
+    #[serde(default)]
+    pub allowlist: Vec<String>,
+    #[serde(default)]
+    pub denylist: Vec<String>,
+    pub prompt_side_effects: Option<bool>,
+}
+
+/// read_file limits configuration.
+#[derive(Debug, Default, Deserialize)]
+pub struct ReadFileConfig {
+    pub max_file_read_bytes: Option<usize>,
+    pub max_scan_bytes: Option<usize>,
+}
+
+/// apply_patch limits configuration.
+#[derive(Debug, Default, Deserialize)]
+pub struct ApplyPatchConfig {
+    pub max_patch_bytes: Option<usize>,
+}
+
 impl ToolDefinitionConfig {
     /// Convert this config to a ToolDefinition.
     pub fn to_tool_definition(&self) -> Result<forge_types::ToolDefinition, String> {
diff --git a/engine/src/lib.rs b/engine/src/lib.rs
index 1b557ee..35b615a 100644
--- a/engine/src/lib.rs
+++ b/engine/src/lib.rs
@@ -2,7 +2,7 @@
 //!
 //! This crate contains the App state machine without TUI dependencies.
 
-use std::collections::HashMap;
+use std::collections::{HashMap, VecDeque};
 use std::path::PathBuf;
 use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};
 
@@ -18,6 +18,7 @@ pub use forge_context::{
     ActiveJournal, ContextAdaptation, ContextBuildError, ContextManager, ContextUsageStatus,
     FullHistory, MessageId, ModelLimits, ModelLimitsSource, ModelRegistry, PendingSummarization,
     PreparedContext, RecoveredStream, StreamJournal, SummarizationNeeded, SummarizationScope,
+    ToolBatchId, ToolJournal, RecoveredToolBatch,
     TokenCounter, generate_summary, summarization_model,
 };
 pub use forge_providers::{self, ApiConfig};
@@ -32,6 +33,8 @@ pub use forge_types::{
 mod config;
 pub use config::{AppConfig, ForgeConfig};
 
+mod tools;
+
 // ============================================================================
 // StreamingMessage - async message being streamed
 // ============================================================================
@@ -248,6 +251,38 @@ const SUMMARIZATION_RETRY_BASE_MS: u64 = 500;
 const SUMMARIZATION_RETRY_MAX_MS: u64 = 8000;
 const SUMMARIZATION_RETRY_JITTER_MS: u64 = 200;
 
+const DEFAULT_MAX_TOOL_CALLS_PER_BATCH: usize = 8;
+const DEFAULT_MAX_TOOL_ITERATIONS_PER_TURN: u32 = 4;
+const DEFAULT_MAX_TOOL_ARGS_BYTES: usize = 256 * 1024;
+const DEFAULT_MAX_TOOL_OUTPUT_BYTES: usize = 102_400;
+const DEFAULT_MAX_PATCH_BYTES: usize = 512 * 1024;
+const DEFAULT_MAX_READ_FILE_BYTES: usize = 200 * 1024;
+const DEFAULT_MAX_READ_FILE_SCAN_BYTES: usize = 2 * 1024 * 1024;
+const DEFAULT_TOOL_TIMEOUT_SECS: u64 = 30;
+const DEFAULT_TOOL_FILE_TIMEOUT_SECS: u64 = 30;
+const DEFAULT_TOOL_SHELL_TIMEOUT_SECS: u64 = 300;
+const DEFAULT_TOOL_CAPACITY_BYTES: usize = 64 * 1024;
+const TOOL_OUTPUT_SAFETY_MARGIN_TOKENS: u32 = 256;
+const TOOL_EVENT_CHANNEL_CAPACITY: usize = 64;
+
+const DEFAULT_ENV_DENYLIST: [&str; 7] = [
+    "*_KEY",
+    "*_TOKEN",
+    "*_SECRET",
+    "*_PASSWORD",
+    "AWS_*",
+    "ANTHROPIC_*",
+    "OPENAI_*",
+];
+
+const DEFAULT_SANDBOX_DENIES: [&str; 5] = [
+    "**/.ssh/**",
+    "**/.gnupg/**",
+    "**/id_rsa*",
+    "**/*.pem",
+    "**/*.key",
+];
+
 const RECOVERY_COMPLETE_BADGE: NonEmptyStaticStr =
     NonEmptyStaticStr::new("[Recovered - stream completed but not finalized]");
 const RECOVERY_INCOMPLETE_BADGE: NonEmptyStaticStr =
@@ -584,6 +619,8 @@ struct ActiveStream {
     message: StreamingMessage,
     journal: ActiveJournal,
     abort_handle: AbortHandle,
+    tool_batch_id: Option<ToolBatchId>,
+    tool_call_seq: usize,
 }
 
 #[derive(Debug)]
@@ -625,6 +662,73 @@ pub struct PendingToolExecution {
     pub model: ModelName,
     /// Journal step ID for recovery.
     pub step_id: forge_context::StepId,
+    /// Tool batch journal ID.
+    pub batch_id: ToolBatchId,
+}
+
+#[derive(Debug)]
+struct ToolBatch {
+    assistant_text: String,
+    calls: Vec<ToolCall>,
+    results: Vec<ToolResult>,
+    model: ModelName,
+    step_id: forge_context::StepId,
+    batch_id: ToolBatchId,
+    iteration: u32,
+    execute_now: Vec<ToolCall>,
+    approval_calls: Vec<ToolCall>,
+    approval_requests: Vec<tools::ConfirmationRequest>,
+}
+
+#[derive(Debug)]
+struct ApprovalState {
+    requests: Vec<tools::ConfirmationRequest>,
+    selected: Vec<bool>,
+    cursor: usize,
+}
+
+#[derive(Debug)]
+struct ActiveToolExecution {
+    queue: VecDeque<ToolCall>,
+    current_call: Option<ToolCall>,
+    join_handle: Option<tokio::task::JoinHandle<ToolResult>>,
+    event_rx: Option<mpsc::Receiver<tools::ToolEvent>>,
+    abort_handle: Option<AbortHandle>,
+    output_lines: Vec<String>,
+    remaining_capacity_bytes: usize,
+}
+
+#[derive(Debug)]
+enum ToolLoopPhase {
+    AwaitingApproval(ApprovalState),
+    Executing(ActiveToolExecution),
+}
+
+#[derive(Debug)]
+struct ToolLoopState {
+    batch: ToolBatch,
+    phase: ToolLoopPhase,
+}
+
+#[derive(Debug)]
+struct ToolRecoveryState {
+    batch: RecoveredToolBatch,
+    step_id: forge_context::StepId,
+    model: ModelName,
+}
+
+#[derive(Debug, Clone, Copy)]
+enum ToolRecoveryDecision {
+    Resume,
+    Discard,
+}
+
+#[derive(Debug)]
+struct ToolPlan {
+    execute_now: Vec<ToolCall>,
+    approval_calls: Vec<ToolCall>,
+    approval_requests: Vec<tools::ConfirmationRequest>,
+    pre_resolved: Vec<ToolResult>,
 }
 
 #[derive(Debug)]
@@ -632,6 +736,8 @@ enum EnabledState {
     Idle,
     Streaming(ActiveStream),
     AwaitingToolResults(PendingToolExecution),
+    ToolLoop(ToolLoopState),
+    ToolRecovery(ToolRecoveryState),
     Summarizing(SummarizationState),
     SummarizingWithQueued(SummarizationWithQueuedState),
     SummarizationRetry(SummarizationRetryState),
@@ -722,6 +828,18 @@ pub struct App {
     pending_user_message: Option<(MessageId, String)>,
     /// Tool definitions to send with each request.
     tool_definitions: Vec<ToolDefinition>,
+    /// Tool registry for executors.
+    tool_registry: std::sync::Arc<tools::ToolRegistry>,
+    /// Tool loop mode.
+    tools_mode: tools::ToolsMode,
+    /// Tool settings derived from config.
+    tool_settings: tools::ToolSettings,
+    /// Tool journal for crash recovery.
+    tool_journal: ToolJournal,
+    /// File hash cache for tool safety checks.
+    tool_file_cache: std::sync::Arc<tokio::sync::Mutex<tools::ToolFileCache>>,
+    /// Tool iterations used in the current user turn.
+    tool_iterations: u32,
 }
 
 impl App {
@@ -875,6 +993,30 @@ impl App {
         let journal_path = data_dir.join("stream_journal.db");
         let stream_journal = StreamJournal::open(&journal_path)?;
 
+        // Tool settings and registry.
+        let tool_settings = Self::tool_settings_from_config(config.as_ref());
+        let mut tool_registry = tools::ToolRegistry::default();
+        if let Err(e) = tools::builtins::register_builtins(
+            &mut tool_registry,
+            tool_settings.read_limits,
+            tool_settings.patch_limits,
+        ) {
+            tracing::warn!("Failed to register built-in tools: {e}");
+        }
+        let tool_registry = std::sync::Arc::new(tool_registry);
+        let config_tool_definitions = Self::load_tool_definitions_from_config(config.as_ref());
+        let tool_definitions = match tool_settings.mode {
+            tools::ToolsMode::Enabled => tool_registry.definitions(),
+            tools::ToolsMode::ParseOnly => config_tool_definitions,
+            tools::ToolsMode::Disabled => Vec::new(),
+        };
+
+        let tool_journal_path = data_dir.join("tool_journal.db");
+        let tool_journal = ToolJournal::open(&tool_journal_path)?;
+        let tool_file_cache = std::sync::Arc::new(tokio::sync::Mutex::new(
+            std::collections::HashMap::new(),
+        ));
+
         let state = if context_infinity_enabled {
             AppState::Enabled(EnabledState::Idle)
         } else {
@@ -904,7 +1046,13 @@ impl App {
             system_prompt,
             cached_usage_status: None,
             pending_user_message: None,
-            tool_definitions: Vec::new(), // Loaded below after config processing
+            tool_definitions,
+            tool_registry,
+            tools_mode: tool_settings.mode,
+            tool_settings,
+            tool_journal,
+            tool_file_cache,
+            tool_iterations: 0,
         };
 
         app.clamp_output_limits_to_model();
@@ -922,21 +1070,6 @@ impl App {
             ));
         }
 
-        // Load tool definitions from config
-        if let Some(tools_cfg) = config.as_ref().and_then(|cfg| cfg.tools.as_ref()) {
-            for tool_cfg in &tools_cfg.definitions {
-                match tool_cfg.to_tool_definition() {
-                    Ok(tool_def) => {
-                        tracing::debug!("Loaded tool: {}", tool_def.name);
-                        app.tool_definitions.push(tool_def);
-                    }
-                    Err(e) => {
-                        tracing::warn!("Failed to load tool '{}': {}", tool_cfg.name, e);
-                    }
-                }
-            }
-        }
-
         Ok(app)
     }
 
@@ -1004,6 +1137,178 @@ impl App {
         OpenAIRequestOptions::new(reasoning_effort, verbosity, truncation)
     }
 
+    fn load_tool_definitions_from_config(config: Option<&ForgeConfig>) -> Vec<ToolDefinition> {
+        let mut defs = Vec::new();
+        if let Some(tools_cfg) = config.and_then(|cfg| cfg.tools.as_ref()) {
+            for tool_cfg in &tools_cfg.definitions {
+                match tool_cfg.to_tool_definition() {
+                    Ok(tool_def) => {
+                        tracing::debug!("Loaded tool: {}", tool_def.name);
+                        defs.push(tool_def);
+                    }
+                    Err(e) => {
+                        tracing::warn!("Failed to load tool '{}': {}", tool_cfg.name, e);
+                    }
+                }
+            }
+        }
+        defs
+    }
+
+    fn tool_settings_from_config(config: Option<&ForgeConfig>) -> tools::ToolSettings {
+        let tools_cfg = config.and_then(|cfg| cfg.tools.as_ref());
+        let has_defs = tools_cfg.map(|cfg| !cfg.definitions.is_empty()).unwrap_or(false);
+        let mode = parse_tools_mode(
+            tools_cfg.and_then(|cfg| cfg.mode.as_deref()),
+            has_defs,
+        );
+        let allow_parallel = tools_cfg
+            .and_then(|cfg| cfg.allow_parallel)
+            .unwrap_or(false);
+
+        let limits = tools::ToolLimits {
+            max_tool_calls_per_batch: tools_cfg
+                .and_then(|cfg| cfg.max_tool_calls_per_batch)
+                .unwrap_or(DEFAULT_MAX_TOOL_CALLS_PER_BATCH),
+            max_tool_iterations_per_user_turn: tools_cfg
+                .and_then(|cfg| cfg.max_tool_iterations_per_user_turn)
+                .unwrap_or(DEFAULT_MAX_TOOL_ITERATIONS_PER_TURN),
+            max_tool_args_bytes: tools_cfg
+                .and_then(|cfg| cfg.max_tool_args_bytes)
+                .unwrap_or(DEFAULT_MAX_TOOL_ARGS_BYTES),
+        };
+
+        let read_limits = tools::ReadFileLimits {
+            max_file_read_bytes: tools_cfg
+                .and_then(|cfg| cfg.read_file.as_ref())
+                .and_then(|cfg| cfg.max_file_read_bytes)
+                .unwrap_or(DEFAULT_MAX_READ_FILE_BYTES),
+            max_scan_bytes: tools_cfg
+                .and_then(|cfg| cfg.read_file.as_ref())
+                .and_then(|cfg| cfg.max_scan_bytes)
+                .unwrap_or(DEFAULT_MAX_READ_FILE_SCAN_BYTES),
+        };
+
+        let patch_limits = tools::PatchLimits {
+            max_patch_bytes: tools_cfg
+                .and_then(|cfg| cfg.apply_patch.as_ref())
+                .and_then(|cfg| cfg.max_patch_bytes)
+                .unwrap_or(DEFAULT_MAX_PATCH_BYTES),
+        };
+
+        let timeouts = tools::ToolTimeouts {
+            default_timeout: Duration::from_secs(
+                tools_cfg
+                    .and_then(|cfg| cfg.timeouts.as_ref())
+                    .and_then(|cfg| cfg.default_seconds)
+                    .unwrap_or(DEFAULT_TOOL_TIMEOUT_SECS),
+            ),
+            file_operations_timeout: Duration::from_secs(
+                tools_cfg
+                    .and_then(|cfg| cfg.timeouts.as_ref())
+                    .and_then(|cfg| cfg.file_operations_seconds)
+                    .unwrap_or(DEFAULT_TOOL_FILE_TIMEOUT_SECS),
+            ),
+            shell_commands_timeout: Duration::from_secs(
+                tools_cfg
+                    .and_then(|cfg| cfg.timeouts.as_ref())
+                    .and_then(|cfg| cfg.shell_commands_seconds)
+                    .unwrap_or(DEFAULT_TOOL_SHELL_TIMEOUT_SECS),
+            ),
+        };
+
+        let max_output_bytes = tools_cfg
+            .and_then(|cfg| cfg.output.as_ref())
+            .and_then(|cfg| cfg.max_bytes)
+            .unwrap_or(DEFAULT_MAX_TOOL_OUTPUT_BYTES);
+
+        let policy_cfg = tools_cfg.and_then(|cfg| cfg.approval.as_ref());
+        let policy = tools::Policy {
+            enabled: policy_cfg.and_then(|cfg| cfg.enabled).unwrap_or(true),
+            mode: parse_approval_mode(policy_cfg.and_then(|cfg| cfg.mode.as_deref())),
+            allowlist: {
+                let list = policy_cfg
+                    .map(|cfg| cfg.allowlist.clone())
+                    .unwrap_or_else(|| vec!["read_file".to_string()]);
+                list.into_iter().collect()
+            },
+            denylist: {
+                let list = if policy_cfg.and_then(|cfg| Some(&cfg.denylist)).is_some() {
+                    policy_cfg
+                        .map(|cfg| cfg.denylist.clone())
+                        .unwrap_or_default()
+                } else {
+                    vec!["run_command".to_string()]
+                };
+                list.into_iter().collect()
+            },
+            prompt_side_effects: policy_cfg
+                .and_then(|cfg| cfg.prompt_side_effects)
+                .unwrap_or(true),
+        };
+
+        let env_patterns: Vec<String> = tools_cfg
+            .and_then(|cfg| cfg.environment.as_ref())
+            .map(|cfg| cfg.denylist.clone())
+            .filter(|list| !list.is_empty())
+            .unwrap_or_else(|| DEFAULT_ENV_DENYLIST.iter().map(|s| s.to_string()).collect());
+        let env_sanitizer = tools::EnvSanitizer::new(&env_patterns).unwrap_or_else(|e| {
+            tracing::warn!("Invalid env denylist: {e}. Using defaults.");
+            tools::EnvSanitizer::new(
+                &DEFAULT_ENV_DENYLIST.iter().map(|s| s.to_string()).collect::<Vec<_>>(),
+            )
+            .expect("default env sanitizer")
+        });
+
+        let sandbox_cfg = tools_cfg.and_then(|cfg| cfg.sandbox.as_ref());
+        let include_default_denies = sandbox_cfg
+            .and_then(|cfg| cfg.include_default_denies)
+            .unwrap_or(true);
+        let mut denied_patterns = sandbox_cfg
+            .map(|cfg| cfg.denied_patterns.clone())
+            .unwrap_or_default();
+        if include_default_denies {
+            denied_patterns.extend(DEFAULT_SANDBOX_DENIES.iter().map(|s| s.to_string()));
+        }
+
+        let mut allowed_roots: Vec<PathBuf> = sandbox_cfg
+            .map(|cfg| cfg.allowed_roots.clone())
+            .unwrap_or_default()
+            .into_iter()
+            .map(|raw| PathBuf::from(config::expand_env_vars(&raw)))
+            .collect();
+        if allowed_roots.is_empty() {
+            allowed_roots.push(PathBuf::from("."));
+        }
+        let allow_absolute = sandbox_cfg
+            .and_then(|cfg| cfg.allow_absolute)
+            .unwrap_or(false);
+
+        let sandbox = tools::sandbox::Sandbox::new(allowed_roots.clone(), denied_patterns.clone(), allow_absolute)
+            .unwrap_or_else(|e| {
+                tracing::warn!("Invalid sandbox config: {e}. Using defaults.");
+                tools::sandbox::Sandbox::new(
+                    vec![PathBuf::from(".")],
+                    DEFAULT_SANDBOX_DENIES.iter().map(|s| s.to_string()).collect(),
+                    false,
+                )
+                .expect("default sandbox")
+            });
+
+        tools::ToolSettings {
+            mode,
+            allow_parallel,
+            limits,
+            read_limits,
+            patch_limits,
+            timeouts,
+            max_output_bytes,
+            policy,
+            sandbox,
+            env_sanitizer,
+        }
+    }
+
     /// Save the conversation history to disk.
     pub fn save_history(&self) -> anyhow::Result<()> {
         let path = self.history_path();
@@ -1098,6 +1403,68 @@ impl App {
     /// adding the message (it was already recovered or committed) and just finalize
     /// the journal cleanup.
     pub fn check_crash_recovery(&mut self) -> Option<RecoveredStream> {
+        if let Ok(Some(mut recovered_batch)) = self.tool_journal.recover() {
+            let stream_recovered = match self.stream_journal.recover() {
+                Ok(recovered) => recovered,
+                Err(e) => {
+                    self.set_status(format!("Recovery failed: {e}"));
+                    return None;
+                }
+            };
+
+            let (step_id, partial_text, stream_model_name) = match &stream_recovered {
+                Some(RecoveredStream::Complete {
+                    step_id,
+                    partial_text,
+                    model_name,
+                    ..
+                }) => (Some(*step_id), Some(partial_text.as_str()), model_name.clone()),
+                Some(RecoveredStream::Incomplete {
+                    step_id,
+                    partial_text,
+                    model_name,
+                    ..
+                }) => (Some(*step_id), Some(partial_text.as_str()), model_name.clone()),
+                Some(RecoveredStream::Errored {
+                    step_id,
+                    partial_text,
+                    model_name,
+                    ..
+                }) => (Some(*step_id), Some(partial_text.as_str()), model_name.clone()),
+                None => (None, None, None),
+            };
+
+            if recovered_batch.assistant_text.trim().is_empty()
+                && let Some(text) = partial_text
+                && !text.trim().is_empty()
+            {
+                recovered_batch.assistant_text = text.to_string();
+            }
+
+            let model = parse_model_name_from_string(&recovered_batch.model_name)
+                .or_else(|| {
+                    stream_model_name
+                        .as_ref()
+                        .and_then(|name| parse_model_name_from_string(name))
+                })
+                .unwrap_or_else(|| self.model.clone());
+
+            if let Some(step_id) = step_id {
+                self.state = AppState::Enabled(EnabledState::ToolRecovery(ToolRecoveryState {
+                    batch: recovered_batch,
+                    step_id,
+                    model,
+                }));
+                self.set_status("Recovered tool batch. Press R to resume or D to discard.");
+                return stream_recovered;
+            }
+
+            tracing::warn!("Tool batch recovery found but no stream journal step.");
+            self.set_status("Recovered tool batch but stream journal missing; discarding");
+            let _ = self.tool_journal.discard_batch(recovered_batch.batch_id);
+            return None;
+        }
+
         let recovered = match self.stream_journal.recover() {
             Ok(Some(recovered)) => recovered,
             Ok(None) => return None,
@@ -1276,12 +1643,102 @@ impl App {
         )
     }
 
+    pub fn tool_loop_calls(&self) -> Option<&[ToolCall]> {
+        match &self.state {
+            AppState::Enabled(EnabledState::ToolLoop(state)) => Some(&state.batch.calls),
+            _ => None,
+        }
+    }
+
+    pub fn tool_loop_execute_calls(&self) -> Option<&[ToolCall]> {
+        match &self.state {
+            AppState::Enabled(EnabledState::ToolLoop(state)) => Some(&state.batch.execute_now),
+            _ => None,
+        }
+    }
+
+    pub fn tool_loop_results(&self) -> Option<&[ToolResult]> {
+        match &self.state {
+            AppState::Enabled(EnabledState::ToolLoop(state)) => Some(&state.batch.results),
+            _ => None,
+        }
+    }
+
+    pub fn tool_loop_current_call_id(&self) -> Option<&str> {
+        match &self.state {
+            AppState::Enabled(EnabledState::ToolLoop(state)) => match &state.phase {
+                ToolLoopPhase::Executing(exec) => {
+                    exec.current_call.as_ref().map(|c| c.id.as_str())
+                }
+                _ => None,
+            },
+            _ => None,
+        }
+    }
+
+    pub fn tool_loop_output_lines(&self) -> Option<&[String]> {
+        match &self.state {
+            AppState::Enabled(EnabledState::ToolLoop(state)) => match &state.phase {
+                ToolLoopPhase::Executing(exec) => Some(&exec.output_lines),
+                _ => None,
+            },
+            _ => None,
+        }
+    }
+
+    pub fn tool_approval_requests(&self) -> Option<&[tools::ConfirmationRequest]> {
+        match &self.state {
+            AppState::Enabled(EnabledState::ToolLoop(state)) => match &state.phase {
+                ToolLoopPhase::AwaitingApproval(approval) => Some(&approval.requests),
+                _ => None,
+            },
+            _ => None,
+        }
+    }
+
+    pub fn tool_approval_selected(&self) -> Option<&[bool]> {
+        match &self.state {
+            AppState::Enabled(EnabledState::ToolLoop(state)) => match &state.phase {
+                ToolLoopPhase::AwaitingApproval(approval) => Some(&approval.selected),
+                _ => None,
+            },
+            _ => None,
+        }
+    }
+
+    pub fn tool_approval_cursor(&self) -> Option<usize> {
+        match &self.state {
+            AppState::Enabled(EnabledState::ToolLoop(state)) => match &state.phase {
+                ToolLoopPhase::AwaitingApproval(approval) => Some(approval.cursor),
+                _ => None,
+            },
+            _ => None,
+        }
+    }
+
+    pub fn tool_recovery_calls(&self) -> Option<&[ToolCall]> {
+        match &self.state {
+            AppState::Enabled(EnabledState::ToolRecovery(state)) => Some(&state.batch.calls),
+            _ => None,
+        }
+    }
+
+    pub fn tool_recovery_results(&self) -> Option<&[ToolResult]> {
+        match &self.state {
+            AppState::Enabled(EnabledState::ToolRecovery(state)) => Some(&state.batch.results),
+            _ => None,
+        }
+    }
+
     pub fn is_empty(&self) -> bool {
         self.display.is_empty()
             && !matches!(
                 self.state,
                 AppState::Enabled(EnabledState::Streaming(_))
                     | AppState::Disabled(DisabledState::Streaming(_))
+                    | AppState::Enabled(EnabledState::AwaitingToolResults(_))
+                    | AppState::Enabled(EnabledState::ToolLoop(_))
+                    | AppState::Enabled(EnabledState::ToolRecovery(_))
             )
     }
 
@@ -1304,6 +1761,12 @@ impl App {
             self.state,
             AppState::Enabled(EnabledState::Streaming(_))
                 | AppState::Disabled(DisabledState::Streaming(_))
+                | AppState::Enabled(EnabledState::AwaitingToolResults(_))
+                | AppState::Enabled(EnabledState::ToolLoop(_))
+                | AppState::Enabled(EnabledState::Summarizing(_))
+                | AppState::Enabled(EnabledState::SummarizingWithQueued(_))
+                | AppState::Enabled(EnabledState::SummarizationRetry(_))
+                | AppState::Enabled(EnabledState::SummarizationRetryWithQueued(_))
         )
     }
 
@@ -1530,6 +1993,14 @@ impl App {
                 self.set_status("Cannot summarize while awaiting tool results");
                 return SummarizationStart::Failed;
             }
+            AppState::Enabled(EnabledState::ToolLoop(_)) => {
+                self.set_status("Cannot summarize while tool execution runs");
+                return SummarizationStart::Failed;
+            }
+            AppState::Enabled(EnabledState::ToolRecovery(_)) => {
+                self.set_status("Cannot summarize while tool recovery is pending");
+                return SummarizationStart::Failed;
+            }
             AppState::Enabled(EnabledState::Summarizing(_))
             | AppState::Enabled(EnabledState::SummarizingWithQueued(_))
             | AppState::Enabled(EnabledState::SummarizationRetry(_))
@@ -1849,6 +2320,14 @@ impl App {
                 self.set_status("Busy: waiting for tool results");
                 return;
             }
+            AppState::Enabled(EnabledState::ToolLoop(_)) => {
+                self.set_status("Busy: tool execution in progress");
+                return;
+            }
+            AppState::Enabled(EnabledState::ToolRecovery(_)) => {
+                self.set_status("Busy: tool recovery pending");
+                return;
+            }
             AppState::Enabled(EnabledState::Summarizing(_))
             | AppState::Enabled(EnabledState::SummarizingWithQueued(_))
             | AppState::Enabled(EnabledState::SummarizationRetry(_))
@@ -1907,6 +2386,8 @@ impl App {
             message: StreamingMessage::new(config.model().clone(), rx),
             journal,
             abort_handle,
+            tool_batch_id: None,
+            tool_call_seq: 0,
         };
 
         self.state = if context_infinity_enabled {
@@ -2026,46 +2507,97 @@ impl App {
 
             let mut journal_error: Option<String> = None;
             let mut finish_reason: Option<StreamFinishReason> = None;
+            let update_assistant_text = matches!(event, StreamEvent::TextDelta(_));
 
-            {
-                let active = match self.state {
-                    AppState::Enabled(EnabledState::Streaming(ref mut active))
-                    | AppState::Disabled(DisabledState::Streaming(ref mut active)) => active,
-                    _ => return,
-                };
+            let idle = self.idle_state();
+            let state = std::mem::replace(&mut self.state, idle);
+            let (mut active, context_enabled) = match state {
+                AppState::Enabled(EnabledState::Streaming(active)) => (active, true),
+                AppState::Disabled(DisabledState::Streaming(active)) => (active, false),
+                other => {
+                    self.state = other;
+                    return;
+                }
+            };
 
-                let persist_result = match &event {
-                    StreamEvent::TextDelta(text) => active
-                        .journal
-                        .append_text(&mut self.stream_journal, text.clone()),
-                    StreamEvent::ThinkingDelta(_) => {
-                        // Don't persist thinking content to journal - silently consume
-                        Ok(())
-                    }
-                    StreamEvent::ToolCallStart { .. } => {
-                        // TODO: Persist tool call start in Phase 3
-                        Ok(())
+            let persist_result = match &event {
+                StreamEvent::TextDelta(text) => active
+                    .journal
+                    .append_text(&mut self.stream_journal, text.clone()),
+                StreamEvent::ThinkingDelta(_) => {
+                    // Don't persist thinking content to journal - silently consume
+                    Ok(())
+                }
+                StreamEvent::ToolCallStart { .. } | StreamEvent::ToolCallDelta { .. } => Ok(()),
+                StreamEvent::Done => active.journal.append_done(&mut self.stream_journal),
+                StreamEvent::Error(msg) => active
+                    .journal
+                    .append_error(&mut self.stream_journal, msg.clone()),
+            };
+
+            // Persist BEFORE display.
+            if let Err(e) = persist_result {
+                journal_error = Some(e.to_string());
+            }
+
+            if journal_error.is_none() {
+                match &event {
+                    StreamEvent::ToolCallStart { id, name } => {
+                        if active.tool_batch_id.is_none() {
+                            match self.tool_journal.begin_streaming_batch(
+                                active.journal.model_name(),
+                            ) {
+                                Ok(batch_id) => {
+                                    active.tool_batch_id = Some(batch_id);
+                                }
+                                Err(e) => journal_error = Some(e.to_string()),
+                            }
+                        }
+                        if let Some(batch_id) = active.tool_batch_id {
+                            let seq = active.tool_call_seq;
+                            active.tool_call_seq = active.tool_call_seq.saturating_add(1);
+                            if let Err(e) = self
+                                .tool_journal
+                                .record_call_start(batch_id, seq, id, name)
+                            {
+                                journal_error = Some(e.to_string());
+                            }
+                        }
                     }
-                    StreamEvent::ToolCallDelta { .. } => {
-                        // TODO: Persist tool call delta in Phase 3
-                        Ok(())
+                    StreamEvent::ToolCallDelta { id, arguments } => {
+                        if let Some(batch_id) = active.tool_batch_id {
+                            if let Err(e) = self
+                                .tool_journal
+                                .append_call_args(batch_id, id, arguments)
+                            {
+                                journal_error = Some(e.to_string());
+                            }
+                        }
                     }
-                    StreamEvent::Done => active.journal.append_done(&mut self.stream_journal),
-                    StreamEvent::Error(msg) => active
-                        .journal
-                        .append_error(&mut self.stream_journal, msg.clone()),
-                };
-
-                // Persist BEFORE display.
-                if let Err(e) = persist_result {
-                    journal_error = Some(e.to_string());
+                    _ => {}
                 }
+            }
 
-                if journal_error.is_none() {
-                    finish_reason = active.message.apply_event(event);
+            if journal_error.is_none() {
+                finish_reason = active.message.apply_event(event);
+                if update_assistant_text
+                    && let Some(batch_id) = active.tool_batch_id
+                {
+                    if let Err(e) = self
+                        .tool_journal
+                        .update_assistant_text(batch_id, active.message.content())
+                    {
+                        journal_error = Some(e.to_string());
+                    }
                 }
             }
 
+            self.state = if context_enabled {
+                AppState::Enabled(EnabledState::Streaming(active))
+            } else {
+                AppState::Disabled(DisabledState::Streaming(active))
+            };
+
             if let Some(err) = journal_error {
                 // Abort streaming without applying the unpersisted event.
                 let active = match self.replace_with_idle() {
@@ -2081,6 +2613,7 @@ impl App {
                     message,
                     journal,
                     abort_handle,
+                    ..
                 } = active;
 
                 abort_handle.abort();
@@ -2142,6 +2675,8 @@ impl App {
             mut message,
             journal,
             abort_handle,
+            tool_batch_id,
+            ..
         } = active;
 
         abort_handle.abort();
@@ -2162,18 +2697,14 @@ impl App {
         if message.has_tool_calls() {
             let tool_calls = message.take_tool_calls();
             let assistant_text = message.content().to_string();
-
-            // Transition to AwaitingToolResults state
             self.pending_user_message = None;
-            let pending = PendingToolExecution {
+            self.handle_tool_calls(
                 assistant_text,
-                pending_calls: tool_calls,
-                results: Vec::new(),
+                tool_calls,
                 model,
                 step_id,
-            };
-            self.state = AppState::Enabled(EnabledState::AwaitingToolResults(pending));
-            self.set_status("Waiting for tool results...");
+                tool_batch_id,
+            );
             return;
         }
 
@@ -2229,33 +2760,659 @@ impl App {
         // If save failed, leave journal recoverable for next session
     }
 
-    /// Submit a tool result. When all results are in, commit messages and return to Idle.
-    ///
-    /// Returns `Ok(true)` if all results are now complete and conversation can resume,
-    /// `Ok(false)` if more results are still needed, or an error if not in the right state.
-    pub fn submit_tool_result(&mut self, result: ToolResult) -> Result<bool, String> {
-        // First, validate and add the result to pending state
-        let (results_count, pending_count) = {
-            let pending = match &mut self.state {
-                AppState::Enabled(EnabledState::AwaitingToolResults(pending)) => pending,
-                _ => return Err("Not awaiting tool results".to_string()),
+    fn handle_tool_calls(
+        &mut self,
+        assistant_text: String,
+        tool_calls: Vec<ToolCall>,
+        model: ModelName,
+        step_id: forge_context::StepId,
+        tool_batch_id: Option<ToolBatchId>,
+    ) {
+        if tool_calls.is_empty() {
+            return;
+        }
+
+        let mut batch_id = tool_batch_id.unwrap_or(0);
+        if batch_id != 0 {
+            if let Err(e) = self
+                .tool_journal
+                .update_assistant_text(batch_id, &assistant_text)
+            {
+                tracing::warn!("Tool journal update failed: {e}");
+                self.set_status(format!("Tool journal error: {e}"));
+                batch_id = 0;
+            }
+        }
+        if batch_id == 0 {
+            batch_id = match self
+                .tool_journal
+                .begin_batch(model.as_str(), &assistant_text, &tool_calls)
+            {
+                Ok(id) => id,
+                Err(e) => {
+                    tracing::warn!("Tool journal begin failed: {e}");
+                    self.set_status(format!("Tool journal error: {e}"));
+                    0
+                }
             };
+        }
 
-            // Verify this result matches a pending call
-            let matching_call = pending
-                .pending_calls
-                .iter()
-                .any(|c| c.id == result.tool_call_id);
-            if !matching_call {
-                return Err(format!(
-                    "No pending tool call with ID '{}'",
-                    result.tool_call_id
-                ));
+        match self.tools_mode {
+            tools::ToolsMode::Disabled => {
+                let results: Vec<ToolResult> = tool_calls
+                    .iter()
+                    .map(|call| ToolResult::error(call.id.clone(), "Tool execution disabled"))
+                    .collect();
+                if batch_id != 0 {
+                    for result in &results {
+                        let _ = self.tool_journal.record_result(batch_id, result);
+                    }
+                }
+                self.commit_tool_batch(
+                    assistant_text,
+                    tool_calls,
+                    results,
+                    model,
+                    step_id,
+                    batch_id,
+                    false,
+                );
+            }
+            tools::ToolsMode::ParseOnly => {
+                let pending = PendingToolExecution {
+                    assistant_text,
+                    pending_calls: tool_calls,
+                    results: Vec::new(),
+                    model,
+                    step_id,
+                    batch_id,
+                };
+                self.state = AppState::Enabled(EnabledState::AwaitingToolResults(pending));
+                self.set_status("Waiting for tool results...");
+            }
+            tools::ToolsMode::Enabled => {
+                self.start_tool_loop(assistant_text, tool_calls, model, step_id, batch_id);
             }
+        }
+    }
 
-            // Check for duplicate result
-            if pending
-                .results
+    fn start_tool_loop(
+        &mut self,
+        assistant_text: String,
+        tool_calls: Vec<ToolCall>,
+        model: ModelName,
+        step_id: forge_context::StepId,
+        batch_id: ToolBatchId,
+    ) {
+        let next_iteration = self.tool_iterations.saturating_add(1);
+        if next_iteration > self.tool_settings.limits.max_tool_iterations_per_user_turn {
+            let results: Vec<ToolResult> = tool_calls
+                .iter()
+                .map(|call| {
+                    ToolResult::error(call.id.clone(), "Max tool iterations reached")
+                })
+                .collect();
+            if batch_id != 0 {
+                for result in &results {
+                    let _ = self.tool_journal.record_result(batch_id, result);
+                }
+            }
+            self.commit_tool_batch(
+                assistant_text,
+                tool_calls,
+                results,
+                model,
+                step_id,
+                batch_id,
+                true,
+            );
+            return;
+        }
+        self.tool_iterations = next_iteration;
+
+        let plan = self.plan_tool_calls(&tool_calls);
+        if batch_id != 0 {
+            for result in &plan.pre_resolved {
+                let _ = self.tool_journal.record_result(batch_id, result);
+            }
+        }
+
+        let batch = ToolBatch {
+            assistant_text,
+            calls: tool_calls,
+            results: plan.pre_resolved,
+            model,
+            step_id,
+            batch_id,
+            iteration: next_iteration,
+            execute_now: plan.execute_now,
+            approval_calls: plan.approval_calls,
+            approval_requests: plan.approval_requests.clone(),
+        };
+
+        let remaining_capacity_bytes = self.remaining_tool_capacity(&batch);
+
+        if !plan.approval_requests.is_empty() {
+            let approval = ApprovalState {
+                requests: plan.approval_requests,
+                selected: vec![false; batch.approval_requests.len()],
+                cursor: 0,
+            };
+            self.state = AppState::Enabled(EnabledState::ToolLoop(ToolLoopState {
+                batch,
+                phase: ToolLoopPhase::AwaitingApproval(approval),
+            }));
+            self.set_status("Tool approval required");
+            return;
+        }
+
+        let queue = batch.execute_now.clone();
+        if queue.is_empty() {
+            self.commit_tool_batch(
+                batch.assistant_text,
+                batch.calls,
+                batch.results,
+                batch.model,
+                batch.step_id,
+                batch.batch_id,
+                true,
+            );
+            return;
+        }
+
+        let exec = self.spawn_tool_execution(queue, remaining_capacity_bytes);
+        self.state = AppState::Enabled(EnabledState::ToolLoop(ToolLoopState {
+            batch,
+            phase: ToolLoopPhase::Executing(exec),
+        }));
+        self.set_status("Running tools...");
+    }
+
+    fn plan_tool_calls(&self, calls: &[ToolCall]) -> ToolPlan {
+        let mut execute_now = Vec::new();
+        let mut approval_calls = Vec::new();
+        let mut approval_requests = Vec::new();
+        let mut pre_resolved = Vec::new();
+        let mut seen_ids = std::collections::HashSet::new();
+        let mut accepted = 0usize;
+
+        for call in calls {
+            if !self.tool_settings.policy.enabled {
+                pre_resolved.push(tool_error_result(
+                    call,
+                    tools::ToolError::SandboxViolation(tools::DenialReason::Disabled),
+                ));
+                continue;
+            }
+
+            if self.tool_settings.policy.is_denylisted(&call.name) {
+                pre_resolved.push(tool_error_result(
+                    call,
+                    tools::ToolError::SandboxViolation(tools::DenialReason::Denylisted {
+                        tool: call.name.clone(),
+                    }),
+                ));
+                continue;
+            }
+
+            if !seen_ids.insert(call.id.clone()) {
+                pre_resolved.push(tool_error_result(
+                    call,
+                    tools::ToolError::DuplicateToolCallId {
+                        id: call.id.clone(),
+                    },
+                ));
+                continue;
+            }
+            accepted += 1;
+            if accepted > self.tool_settings.limits.max_tool_calls_per_batch {
+                pre_resolved.push(tool_error_result(
+                    call,
+                    tools::ToolError::SandboxViolation(tools::DenialReason::LimitsExceeded {
+                        message: "Exceeded max tool calls per batch".to_string(),
+                    }),
+                ));
+                continue;
+            }
+
+            let args_size = serde_json::to_vec(&call.arguments)
+                .map(|v| v.len())
+                .unwrap_or(0);
+            if args_size > self.tool_settings.limits.max_tool_args_bytes {
+                pre_resolved.push(tool_error_result(
+                    call,
+                    tools::ToolError::SandboxViolation(tools::DenialReason::LimitsExceeded {
+                        message: "Tool arguments too large".to_string(),
+                    }),
+                ));
+                continue;
+            }
+
+            if call.name == "apply_patch" {
+                if let Some(patch) = call.arguments.get("patch").and_then(|v| v.as_str()) {
+                    if patch.as_bytes().len() > self.tool_settings.patch_limits.max_patch_bytes {
+                        pre_resolved.push(tool_error_result(
+                            call,
+                            tools::ToolError::SandboxViolation(
+                                tools::DenialReason::LimitsExceeded {
+                                    message: "Patch exceeds max_patch_bytes".to_string(),
+                                },
+                            ),
+                        ));
+                        continue;
+                    }
+                }
+            }
+
+            let exec = match self.tool_registry.lookup(&call.name) {
+                Ok(exec) => exec,
+                Err(err) => {
+                    pre_resolved.push(tool_error_result(call, err));
+                    continue;
+                }
+            };
+
+            if let Err(err) = tools::validate_args(&exec.schema(), &call.arguments) {
+                pre_resolved.push(tool_error_result(call, err));
+                continue;
+            }
+
+            if let Err(err) = preflight_sandbox(&self.tool_settings.sandbox, &call) {
+                pre_resolved.push(tool_error_result(call, err));
+                continue;
+            }
+
+            if matches!(self.tool_settings.policy.mode, tools::ApprovalMode::Deny)
+                && !self.tool_settings.policy.is_allowlisted(&call.name)
+            {
+                pre_resolved.push(tool_error_result(
+                    call,
+                    tools::ToolError::SandboxViolation(tools::DenialReason::Denylisted {
+                        tool: call.name.clone(),
+                    }),
+                ));
+                continue;
+            }
+
+            let allowlisted = self.tool_settings.policy.is_allowlisted(&call.name);
+            let needs_confirmation = match self.tool_settings.policy.mode {
+                tools::ApprovalMode::Auto => exec.requires_approval(),
+                tools::ApprovalMode::Prompt => {
+                    exec.requires_approval()
+                        || (self.tool_settings.policy.prompt_side_effects
+                            && exec.is_side_effecting()
+                            && !allowlisted)
+                }
+                tools::ApprovalMode::Deny => exec.requires_approval(),
+            };
+
+            if needs_confirmation {
+                let summary = match exec.approval_summary(&call.arguments) {
+                    Ok(summary) => summary,
+                    Err(err) => {
+                        pre_resolved.push(tool_error_result(call, err));
+                        continue;
+                    }
+                };
+                let summary = truncate_with_ellipsis(&summary, 200);
+                approval_requests.push(tools::ConfirmationRequest {
+                    tool_call_id: call.id.clone(),
+                    tool_name: call.name.clone(),
+                    summary,
+                    risk_level: exec.risk_level(),
+                });
+                approval_calls.push(call.clone());
+            } else {
+                execute_now.push(call.clone());
+            }
+        }
+
+        ToolPlan {
+            execute_now,
+            approval_calls,
+            approval_requests,
+            pre_resolved,
+        }
+    }
+
+    fn tool_capacity_bytes(&mut self) -> usize {
+        let usage = match self.context_usage_status() {
+            ContextUsageStatus::Ready(usage)
+            | ContextUsageStatus::NeedsSummarization { usage, .. }
+            | ContextUsageStatus::RecentMessagesTooLarge { usage, .. } => usage,
+        };
+
+        if usage.budget_tokens == 0 {
+            return DEFAULT_TOOL_CAPACITY_BYTES;
+        }
+
+        let available_tokens = usage
+            .budget_tokens
+            .saturating_sub(usage.used_tokens)
+            .saturating_sub(TOOL_OUTPUT_SAFETY_MARGIN_TOKENS);
+        if available_tokens == 0 {
+            return 0;
+        }
+
+        let available_bytes = (available_tokens as usize).saturating_mul(4);
+        if available_bytes == 0 {
+            DEFAULT_TOOL_CAPACITY_BYTES
+        } else {
+            available_bytes
+        }
+    }
+
+    fn remaining_tool_capacity(&mut self, batch: &ToolBatch) -> usize {
+        let mut remaining = self.tool_capacity_bytes();
+        for result in &batch.results {
+            remaining = remaining.saturating_sub(result.content.len());
+        }
+        remaining
+    }
+
+    fn spawn_tool_execution(
+        &self,
+        queue: Vec<ToolCall>,
+        initial_capacity_bytes: usize,
+    ) -> ActiveToolExecution {
+        let mut exec = ActiveToolExecution {
+            queue: VecDeque::from(queue),
+            current_call: None,
+            join_handle: None,
+            event_rx: None,
+            abort_handle: None,
+            output_lines: Vec::new(),
+            remaining_capacity_bytes: initial_capacity_bytes,
+        };
+        self.start_next_tool_call(&mut exec);
+        exec
+    }
+
+    fn start_next_tool_call(&self, exec: &mut ActiveToolExecution) -> bool {
+        let Some(call) = exec.queue.pop_front() else {
+            return false;
+        };
+
+        exec.output_lines.clear();
+        exec.current_call = Some(call.clone());
+
+        let (event_tx, event_rx) = mpsc::channel(TOOL_EVENT_CHANNEL_CAPACITY);
+        exec.event_rx = Some(event_rx);
+
+        let (abort_handle, abort_registration) = AbortHandle::new_pair();
+        exec.abort_handle = Some(abort_handle.clone());
+
+        let registry = self.tool_registry.clone();
+        let settings = self.tool_settings.clone();
+        let file_cache = self.tool_file_cache.clone();
+        let working_dir = settings.sandbox.working_dir();
+        let remaining_capacity = exec.remaining_capacity_bytes;
+
+        let handle = tokio::spawn(async move {
+            use futures_util::FutureExt;
+            let _ = event_tx
+                .send(tools::ToolEvent::Started {
+                    tool_call_id: call.id.clone(),
+                    tool_name: call.name.clone(),
+                })
+                .await;
+
+            let exec_ref = match registry.lookup(&call.name) {
+                Ok(exec) => exec,
+                Err(err) => {
+                    let result = tool_error_result(&call, err);
+                    let _ = event_tx
+                        .send(tools::ToolEvent::Completed {
+                            tool_call_id: call.id.clone(),
+                        })
+                        .await;
+                    return result;
+                }
+            };
+
+            let default_timeout = match call.name.as_str() {
+                "read_file" | "apply_patch" => settings.timeouts.file_operations_timeout,
+                "run_command" => settings.timeouts.shell_commands_timeout,
+                _ => settings.timeouts.default_timeout,
+            };
+
+            let mut ctx = tools::ToolCtx {
+                sandbox: settings.sandbox.clone(),
+                abort: abort_handle,
+                output_tx: event_tx.clone(),
+                default_timeout,
+                max_output_bytes: settings.max_output_bytes,
+                available_capacity_bytes: remaining_capacity,
+                tool_call_id: call.id.clone(),
+                allow_truncation: true,
+                working_dir,
+                env_sanitizer: settings.env_sanitizer.clone(),
+                file_cache,
+            };
+
+            let timeout = exec_ref.timeout().unwrap_or(ctx.default_timeout);
+            let exec_future = exec_ref.execute(call.arguments.clone(), &mut ctx);
+            let exec_future = std::panic::AssertUnwindSafe(exec_future).catch_unwind();
+            let exec_future = Abortable::new(exec_future, abort_registration);
+
+            let result = match tokio::time::timeout(timeout, exec_future).await {
+                Err(_) => tool_error_result(
+                    &call,
+                    tools::ToolError::Timeout {
+                        tool: call.name.clone(),
+                        elapsed: timeout,
+                    },
+                ),
+                Ok(Err(_)) => tool_error_result(&call, tools::ToolError::Cancelled),
+                Ok(Ok(Err(panic_payload))) => {
+                    let panic_msg = panic_payload_to_string(&panic_payload);
+                    let message = format!("Tool panicked: {}", panic_msg);
+                    ToolResult::error(call.id.clone(), tools::sanitize_output(&message))
+                }
+                Ok(Ok(Ok(inner))) => match inner {
+                    Ok(output) => {
+                        let sanitized = tools::sanitize_output(&output);
+                        let effective_max =
+                            ctx.max_output_bytes.min(ctx.available_capacity_bytes);
+                        let final_output = if ctx.allow_truncation {
+                            tools::truncate_output(sanitized, effective_max)
+                        } else {
+                            sanitized
+                        };
+                        ToolResult::success(call.id.clone(), final_output)
+                    }
+                    Err(err) => tool_error_result(&call, err),
+                },
+            };
+
+            let _ = event_tx
+                .send(tools::ToolEvent::Completed {
+                    tool_call_id: call.id.clone(),
+                })
+                .await;
+
+            result
+        });
+
+        exec.join_handle = Some(handle);
+        true
+    }
+
+    fn poll_tool_loop(&mut self) {
+        use futures_util::future::FutureExt;
+
+        let idle = self.idle_state();
+        let state = match std::mem::replace(&mut self.state, idle) {
+            AppState::Enabled(EnabledState::ToolLoop(state)) => state,
+            other => {
+                self.state = other;
+                return;
+            }
+        };
+        let mut state = state;
+        let mut completed: Option<ToolResult> = None;
+        let mut should_commit = false;
+
+        match &mut state.phase {
+            ToolLoopPhase::AwaitingApproval(_) => {}
+            ToolLoopPhase::Executing(exec) => {
+                if let Some(rx) = exec.event_rx.as_mut() {
+                    loop {
+                        match rx.try_recv() {
+                            Ok(event) => match event {
+                                tools::ToolEvent::Started { tool_name, .. } => {
+                                    exec.output_lines.push(format!(
+                                        " {}",
+                                        tools::sanitize_output(&tool_name)
+                                    ));
+                                }
+                                tools::ToolEvent::StdoutChunk { chunk, .. } => {
+                                    append_tool_output_lines(
+                                        &mut exec.output_lines,
+                                        &tools::sanitize_output(&chunk),
+                                        None,
+                                    );
+                                }
+                                tools::ToolEvent::StderrChunk { chunk, .. } => {
+                                    append_tool_output_lines(
+                                        &mut exec.output_lines,
+                                        &tools::sanitize_output(&chunk),
+                                        Some("[stderr] "),
+                                    );
+                                }
+                                tools::ToolEvent::Completed { .. } => {
+                                    exec.output_lines.push(" Tool completed".to_string());
+                                }
+                            },
+                            Err(mpsc::error::TryRecvError::Empty) => break,
+                            Err(mpsc::error::TryRecvError::Disconnected) => {
+                                exec.event_rx = None;
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                if let Some(handle) = exec.join_handle.as_mut() {
+                    if let Some(joined) = handle.now_or_never() {
+                        exec.join_handle = None;
+                        exec.event_rx = None;
+                        exec.abort_handle = None;
+
+                        let result = match joined {
+                            Ok(result) => result,
+                            Err(err) => {
+                                let call_id = exec
+                                    .current_call
+                                    .as_ref()
+                                    .map(|c| c.id.clone())
+                                    .unwrap_or_else(|| "<unknown>".to_string());
+                                let message = if err.is_cancelled() {
+                                    "Tool execution cancelled"
+                                } else {
+                                    "Tool execution failed"
+                                };
+                                ToolResult::error(call_id, message)
+                            }
+                        };
+                        exec.current_call = None;
+                        completed = Some(result);
+                    }
+                }
+
+                if let Some(result) = completed.take() {
+                    if state.batch.batch_id != 0 {
+                        let _ = self.tool_journal.record_result(state.batch.batch_id, &result);
+                    }
+                    exec.remaining_capacity_bytes = exec
+                        .remaining_capacity_bytes
+                        .saturating_sub(result.content.len());
+                    state.batch.results.push(result);
+
+                    if exec.queue.is_empty() {
+                        should_commit = true;
+                    } else {
+                        self.start_next_tool_call(exec);
+                    }
+                }
+            }
+        }
+
+        if should_commit {
+            self.commit_tool_batch(
+                state.batch.assistant_text,
+                state.batch.calls,
+                state.batch.results,
+                state.batch.model,
+                state.batch.step_id,
+                state.batch.batch_id,
+                true,
+            );
+        } else {
+            self.state = AppState::Enabled(EnabledState::ToolLoop(state));
+        }
+    }
+
+    fn cancel_tool_batch(
+        &mut self,
+        assistant_text: String,
+        calls: Vec<ToolCall>,
+        mut results: Vec<ToolResult>,
+        model: ModelName,
+        step_id: forge_context::StepId,
+        batch_id: ToolBatchId,
+    ) {
+        let existing: std::collections::HashSet<String> =
+            results.iter().map(|r| r.tool_call_id.clone()).collect();
+        for call in &calls {
+            if existing.contains(&call.id) {
+                continue;
+            }
+            let result = ToolResult::error(call.id.clone(), "Cancelled by user");
+            if batch_id != 0 {
+                let _ = self.tool_journal.record_result(batch_id, &result);
+            }
+            results.push(result);
+        }
+
+        self.commit_tool_batch(
+            assistant_text,
+            calls,
+            results,
+            model,
+            step_id,
+            batch_id,
+            false,
+        );
+    }
+
+    /// Submit a tool result. When all results are in, commit messages and return to Idle.
+    ///
+    /// Returns `Ok(true)` if all results are now complete and conversation can resume,
+    /// `Ok(false)` if more results are still needed, or an error if not in the right state.
+    pub fn submit_tool_result(&mut self, result: ToolResult) -> Result<bool, String> {
+        // First, validate and add the result to pending state
+        let (results_count, pending_count, batch_id) = {
+            let pending = match &mut self.state {
+                AppState::Enabled(EnabledState::AwaitingToolResults(pending)) => pending,
+                _ => return Err("Not awaiting tool results".to_string()),
+            };
+
+            // Verify this result matches a pending call
+            let matching_call = pending
+                .pending_calls
+                .iter()
+                .any(|c| c.id == result.tool_call_id);
+            if !matching_call {
+                return Err(format!(
+                    "No pending tool call with ID '{}'",
+                    result.tool_call_id
+                ));
+            }
+
+            // Check for duplicate result
+            if pending
+                .results
                 .iter()
                 .any(|r| r.tool_call_id == result.tool_call_id)
             {
@@ -2266,7 +3423,10 @@ impl App {
             }
 
             pending.results.push(result);
-            (pending.results.len(), pending.pending_calls.len())
+            if pending.batch_id != 0 {
+                let _ = self.tool_journal.record_result(pending.batch_id, pending.results.last().unwrap());
+            }
+            (pending.results.len(), pending.pending_calls.len(), pending.batch_id)
         };
 
         // Check if all results are in
@@ -2289,35 +3449,92 @@ impl App {
                 }
             };
 
-        let step_id = pending.step_id;
+        self.commit_tool_batch(
+            pending.assistant_text,
+            pending.pending_calls,
+            pending.results,
+            pending.model,
+            pending.step_id,
+            batch_id,
+            false,
+        );
+        Ok(true)
+    }
 
-        // Push assistant text as a message if non-empty
-        if !pending.assistant_text.is_empty()
-            && let Ok(content) = NonEmptyString::new(pending.assistant_text)
-        {
-            let assistant_msg = Message::assistant(pending.model.clone(), content);
-            self.push_history_message_with_step_id(assistant_msg, step_id);
+    fn commit_tool_batch(
+        &mut self,
+        assistant_text: String,
+        tool_calls: Vec<ToolCall>,
+        results: Vec<ToolResult>,
+        model: ModelName,
+        step_id: forge_context::StepId,
+        batch_id: ToolBatchId,
+        auto_resume: bool,
+    ) {
+        self.state = self.idle_state();
+
+        if let Ok(content) = NonEmptyString::new(assistant_text.clone()) {
+            let message = Message::assistant(model.clone(), content);
+            self.push_history_message_with_step_id(message, step_id);
+        }
+
+        let mut result_map: std::collections::HashMap<String, ToolResult> =
+            std::collections::HashMap::new();
+        for result in results {
+            result_map.entry(result.tool_call_id.clone()).or_insert(result);
         }
 
-        // Push tool use messages for each call
-        for call in pending.pending_calls {
-            let tool_use_msg = Message::tool_use(call);
-            self.push_history_message(tool_use_msg);
+        let mut ordered_results: Vec<ToolResult> = Vec::new();
+        for call in &tool_calls {
+            if let Some(result) = result_map.remove(&call.id) {
+                ordered_results.push(result);
+            } else {
+                ordered_results
+                    .push(ToolResult::error(call.id.clone(), "Missing tool result"));
+            }
         }
 
-        // Push tool result messages
-        for result in pending.results {
-            let tool_result_msg = Message::tool_result(result);
-            self.push_history_message(tool_result_msg);
+        for call in &tool_calls {
+            self.push_history_message(Message::tool_use(call.clone()));
+        }
+
+        for result in &ordered_results {
+            self.push_history_message(Message::tool_result(result.clone()));
         }
 
-        // Persist history and finalize journal
         if self.autosave_history() {
             self.finalize_journal_commit(step_id);
+            if batch_id != 0 {
+                if let Err(e) = self.tool_journal.commit_batch(batch_id) {
+                    tracing::warn!("Failed to commit tool batch {}: {e}", batch_id);
+                }
+            }
         }
 
-        self.set_status("Tool results processed");
-        Ok(true)
+        if auto_resume {
+            let Some(api_key) = self.api_keys.get(&model.provider()).cloned() else {
+                self.set_status(format!(
+                    "Cannot resume: no API key for {}",
+                    model.provider().display_name()
+                ));
+                return;
+            };
+
+            let api_key = match model.provider() {
+                Provider::Claude => ApiKey::Claude(api_key),
+                Provider::OpenAI => ApiKey::OpenAI(api_key),
+            };
+
+            let config = match ApiConfig::new(api_key, model.clone()) {
+                Ok(config) => config.with_openai_options(self.openai_options),
+                Err(e) => {
+                    self.set_status(format!("Cannot resume after tools: {e}"));
+                    return;
+                }
+            };
+
+            self.start_streaming(QueuedUserMessage { config });
+        }
     }
 
     /// Atomically commit and prune a journal step.
@@ -2380,6 +3597,7 @@ impl App {
         self.tick = self.tick.wrapping_add(1);
         self.poll_summarization();
         self.poll_summarization_retry();
+        self.poll_tool_loop();
     }
 
     /// Get elapsed time since last frame and update timing.
@@ -2498,6 +3716,226 @@ impl App {
         self.enter_normal_mode();
     }
 
+    pub fn tool_approval_move_up(&mut self) {
+        if let AppState::Enabled(EnabledState::ToolLoop(state)) = &mut self.state
+            && let ToolLoopPhase::AwaitingApproval(approval) = &mut state.phase
+            && approval.cursor > 0
+        {
+            approval.cursor -= 1;
+        }
+    }
+
+    pub fn tool_approval_move_down(&mut self) {
+        if let AppState::Enabled(EnabledState::ToolLoop(state)) = &mut self.state
+            && let ToolLoopPhase::AwaitingApproval(approval) = &mut state.phase
+        {
+            if approval.cursor + 1 < approval.requests.len() {
+                approval.cursor += 1;
+            }
+        }
+    }
+
+    pub fn tool_approval_toggle(&mut self) {
+        if let AppState::Enabled(EnabledState::ToolLoop(state)) = &mut self.state
+            && let ToolLoopPhase::AwaitingApproval(approval) = &mut state.phase
+            && approval.cursor < approval.selected.len()
+        {
+            approval.selected[approval.cursor] = !approval.selected[approval.cursor];
+        }
+    }
+
+    pub fn tool_approval_approve_all(&mut self) {
+        self.resolve_tool_approval(tools::ApprovalDecision::ApproveAll);
+    }
+
+    pub fn tool_approval_deny_all(&mut self) {
+        self.resolve_tool_approval(tools::ApprovalDecision::DenyAll);
+    }
+
+    pub fn tool_approval_confirm_selected(&mut self) {
+        let ids = if let AppState::Enabled(EnabledState::ToolLoop(state)) = &self.state
+            && let ToolLoopPhase::AwaitingApproval(approval) = &state.phase
+        {
+            approval
+                .requests
+                .iter()
+                .zip(approval.selected.iter())
+                .filter_map(|(req, selected)| selected.then(|| req.tool_call_id.clone()))
+                .collect::<Vec<_>>()
+        } else {
+            Vec::new()
+        };
+
+        if ids.is_empty() {
+            self.resolve_tool_approval(tools::ApprovalDecision::DenyAll);
+        } else {
+            self.resolve_tool_approval(tools::ApprovalDecision::ApproveSelected(ids));
+        }
+    }
+
+    pub fn tool_recovery_resume(&mut self) {
+        self.resolve_tool_recovery(ToolRecoveryDecision::Resume);
+    }
+
+    pub fn tool_recovery_discard(&mut self) {
+        self.resolve_tool_recovery(ToolRecoveryDecision::Discard);
+    }
+
+    fn resolve_tool_approval(&mut self, decision: tools::ApprovalDecision) {
+        let idle = self.idle_state();
+        let state = match std::mem::replace(&mut self.state, idle) {
+            AppState::Enabled(EnabledState::ToolLoop(state)) => state,
+            other => {
+                self.state = other;
+                return;
+            }
+        };
+
+        let ToolLoopState { mut batch, phase } = state;
+        let ToolLoopPhase::AwaitingApproval(_approval) = phase else {
+            self.state = AppState::Enabled(EnabledState::ToolLoop(ToolLoopState { batch, phase }));
+            return;
+        };
+
+        let mut approved_ids: std::collections::HashSet<String> = std::collections::HashSet::new();
+        match &decision {
+            tools::ApprovalDecision::ApproveAll => {
+                approved_ids = batch
+                    .approval_calls
+                    .iter()
+                    .map(|call| call.id.clone())
+                    .collect();
+            }
+            tools::ApprovalDecision::ApproveSelected(ids) => {
+                approved_ids.extend(ids.iter().cloned());
+            }
+            tools::ApprovalDecision::DenyAll => {}
+        }
+
+        let mut approved_calls = Vec::new();
+        let mut denied_results = Vec::new();
+        for call in batch.approval_calls.drain(..) {
+            if approved_ids.contains(&call.id) {
+                approved_calls.push(call);
+            } else {
+                denied_results.push(ToolResult::error(
+                    call.id.clone(),
+                    "Tool call denied by user",
+                ));
+            }
+        }
+
+        if batch.batch_id != 0 {
+            for result in &denied_results {
+                let _ = self.tool_journal.record_result(batch.batch_id, result);
+            }
+        }
+        batch.results.extend(denied_results);
+
+        let mut queue = batch.execute_now.clone();
+        queue.extend(approved_calls);
+        batch.execute_now = queue.clone();
+
+        if queue.is_empty() {
+            self.commit_tool_batch(
+                batch.assistant_text,
+                batch.calls,
+                batch.results,
+                batch.model,
+                batch.step_id,
+                batch.batch_id,
+                true,
+            );
+            return;
+        }
+
+        let remaining_capacity = self.remaining_tool_capacity(&batch);
+        let exec = self.spawn_tool_execution(queue, remaining_capacity);
+        self.state = AppState::Enabled(EnabledState::ToolLoop(ToolLoopState {
+            batch,
+            phase: ToolLoopPhase::Executing(exec),
+        }));
+        self.set_status("Running tools...");
+    }
+
+    fn resolve_tool_recovery(&mut self, decision: ToolRecoveryDecision) {
+        let idle = self.idle_state();
+        let state = match std::mem::replace(&mut self.state, idle) {
+            AppState::Enabled(EnabledState::ToolRecovery(state)) => state,
+            other => {
+                self.state = other;
+                return;
+            }
+        };
+
+        self.commit_recovered_tool_batch(state, decision);
+    }
+
+    fn commit_recovered_tool_batch(
+        &mut self,
+        state: ToolRecoveryState,
+        decision: ToolRecoveryDecision,
+    ) {
+        let ToolRecoveryState {
+            batch,
+            step_id,
+            model,
+        } = state;
+
+        let assistant_text = batch.assistant_text.clone();
+        let results = match decision {
+            ToolRecoveryDecision::Resume => {
+                let mut merged = batch.results;
+                let existing: std::collections::HashSet<String> = merged
+                    .iter()
+                    .map(|r| r.tool_call_id.clone())
+                    .collect();
+                for call in &batch.calls {
+                    if !existing.contains(&call.id) {
+                        merged.push(ToolResult::error(
+                            call.id.clone(),
+                            "Tool result missing after crash",
+                        ));
+                    }
+                }
+                merged
+            }
+            ToolRecoveryDecision::Discard => batch
+                .calls
+                .iter()
+                .map(|call| {
+                    ToolResult::error(call.id.clone(), "Tool results discarded after crash")
+                })
+                .collect(),
+        };
+
+        if batch.batch_id != 0 {
+            for result in &results {
+                let _ = self.tool_journal.record_result(batch.batch_id, result);
+            }
+        }
+
+        let auto_resume = matches!(self.tools_mode, tools::ToolsMode::Enabled);
+        self.commit_tool_batch(
+            assistant_text,
+            batch.calls,
+            results,
+            model,
+            step_id,
+            batch.batch_id,
+            auto_resume,
+        );
+
+        match decision {
+            ToolRecoveryDecision::Resume => {
+                self.set_status("Recovered tool batch resumed");
+            }
+            ToolRecoveryDecision::Discard => {
+                self.set_status("Tool results discarded after crash");
+            }
+        }
+    }
+
     pub fn draft_text(&self) -> &str {
         self.input.draft().text()
     }
@@ -2586,6 +4024,26 @@ impl App {
                     AppState::Enabled(EnabledState::AwaitingToolResults(pending)) => {
                         // Clear pending tool execution and discard the journal step.
                         self.discard_journal_step(pending.step_id);
+                        if pending.batch_id != 0 {
+                            let _ = self.tool_journal.discard_batch(pending.batch_id);
+                        }
+                    }
+                    AppState::Enabled(EnabledState::ToolLoop(state)) => {
+                        if let ToolLoopPhase::Executing(exec) = &state.phase {
+                            if let Some(handle) = &exec.abort_handle {
+                                handle.abort();
+                            }
+                        }
+                        if state.batch.batch_id != 0 {
+                            let _ = self.tool_journal.discard_batch(state.batch.batch_id);
+                        }
+                        self.discard_journal_step(state.batch.step_id);
+                    }
+                    AppState::Enabled(EnabledState::ToolRecovery(state)) => {
+                        if state.batch.batch_id != 0 {
+                            let _ = self.tool_journal.discard_batch(state.batch.batch_id);
+                        }
+                        self.discard_journal_step(state.step_id);
                     }
                     AppState::Enabled(EnabledState::Summarizing(state)) => {
                         state.task.handle.abort();
@@ -2771,6 +4229,36 @@ impl App {
                         let _ = active.journal.discard(&mut self.stream_journal);
                         self.set_status("Streaming cancelled");
                     }
+                    AppState::Enabled(EnabledState::AwaitingToolResults(pending)) => {
+                        self.cancel_tool_batch(
+                            pending.assistant_text,
+                            pending.pending_calls,
+                            pending.results,
+                            pending.model,
+                            pending.step_id,
+                            pending.batch_id,
+                        );
+                        self.set_status("Tool results cancelled");
+                    }
+                    AppState::Enabled(EnabledState::ToolLoop(state)) => {
+                        if let ToolLoopPhase::Executing(exec) = &state.phase {
+                            if let Some(handle) = &exec.abort_handle {
+                                handle.abort();
+                            }
+                        }
+                        self.cancel_tool_batch(
+                            state.batch.assistant_text,
+                            state.batch.calls,
+                            state.batch.results,
+                            state.batch.model,
+                            state.batch.step_id,
+                            state.batch.batch_id,
+                        );
+                        self.set_status("Tool execution cancelled");
+                    }
+                    AppState::Enabled(EnabledState::ToolRecovery(state)) => {
+                        self.commit_recovered_tool_batch(state, ToolRecoveryDecision::Discard);
+                    }
                     other => {
                         self.state = other;
                         self.set_status("No active stream to cancel");
@@ -2836,6 +4324,119 @@ impl App {
     }
 }
 
+fn parse_tools_mode(raw: Option<&str>, has_definitions: bool) -> tools::ToolsMode {
+    match raw.map(|s| s.trim().to_ascii_lowercase()) {
+        Some(ref s) if s == "disabled" => tools::ToolsMode::Disabled,
+        Some(ref s) if s == "parse_only" => tools::ToolsMode::ParseOnly,
+        Some(ref s) if s == "enabled" => tools::ToolsMode::Enabled,
+        _ => {
+            if has_definitions {
+                tools::ToolsMode::ParseOnly
+            } else {
+                tools::ToolsMode::Disabled
+            }
+        }
+    }
+}
+
+fn parse_approval_mode(raw: Option<&str>) -> tools::ApprovalMode {
+    match raw.map(|s| s.trim().to_ascii_lowercase()) {
+        Some(ref s) if s == "auto" => tools::ApprovalMode::Auto,
+        Some(ref s) if s == "deny" => tools::ApprovalMode::Deny,
+        Some(ref s) if s == "prompt" => tools::ApprovalMode::Prompt,
+        _ => tools::ApprovalMode::Prompt,
+    }
+}
+
+fn preflight_sandbox(
+    sandbox: &tools::sandbox::Sandbox,
+    call: &ToolCall,
+) -> Result<(), tools::ToolError> {
+    let working_dir = sandbox.working_dir();
+    match call.name.as_str() {
+        "read_file" => {
+            let path = call
+                .arguments
+                .get("path")
+                .and_then(|v| v.as_str())
+                .ok_or_else(|| tools::ToolError::BadArgs {
+                    message: "path must be a string".to_string(),
+                })?;
+            let _ = sandbox.resolve_path(path, &working_dir)?;
+        }
+        "apply_patch" => {
+            let patch_str = call
+                .arguments
+                .get("patch")
+                .and_then(|v| v.as_str())
+                .ok_or_else(|| tools::ToolError::BadArgs {
+                    message: "patch must be a string".to_string(),
+                })?;
+            let patch = tools::lp1::parse_patch(patch_str).map_err(|e| {
+                tools::ToolError::BadArgs {
+                    message: e.to_string(),
+                }
+            })?;
+            for file in patch.files {
+                let _ = sandbox.resolve_path(&file.path, &working_dir)?;
+            }
+        }
+        _ => {}
+    }
+    Ok(())
+}
+
+fn tool_error_result(call: &ToolCall, err: tools::ToolError) -> ToolResult {
+    let message = match err {
+        tools::ToolError::BadArgs { message } => format!("Bad args: {message}"),
+        tools::ToolError::Timeout { tool, elapsed } => {
+            format!("Tool '{tool}' timed out after {}s", elapsed.as_secs())
+        }
+        tools::ToolError::SandboxViolation(reason) => reason.to_string(),
+        tools::ToolError::ExecutionFailed { tool, message } => {
+            format!("{tool} failed: {message}")
+        }
+        tools::ToolError::Cancelled => "Cancelled by user".to_string(),
+        tools::ToolError::UnknownTool { name } => format!("Unknown tool: {name}"),
+        tools::ToolError::DuplicateTool { name } => format!("Duplicate tool: {name}"),
+        tools::ToolError::DuplicateToolCallId { id } => {
+            format!("Duplicate tool call id: {id}")
+        }
+        tools::ToolError::PatchFailed { file, message } => {
+            format!("Patch failed for {}: {message}", file.display())
+        }
+        tools::ToolError::StaleFile { file, reason } => {
+            format!("Stale file {}: {reason}", file.display())
+        }
+    };
+
+    ToolResult::error(call.id.clone(), tools::sanitize_output(&message))
+}
+
+fn append_tool_output_lines(lines: &mut Vec<String>, chunk: &str, prefix: Option<&str>) {
+    let prefix = prefix.unwrap_or("");
+    for line in chunk.lines() {
+        let mut entry = String::new();
+        entry.push_str(prefix);
+        entry.push_str(line);
+        lines.push(entry);
+    }
+    if lines.len() > 50 {
+        let overflow = lines.len() - 50;
+        lines.drain(0..overflow);
+    }
+}
+
+fn panic_payload_to_string(payload: &Box<dyn std::any::Any + Send>) -> String {
+    if let Some(s) = payload.downcast_ref::<&str>() {
+        s.to_string()
+    } else if let Some(s) = payload.downcast_ref::<String>() {
+        s.clone()
+    } else {
+        "unknown panic".to_string()
+    }
+}
+
 fn summarization_retry_delay(attempt: u8) -> Duration {
     let exponent = attempt.saturating_sub(1).min(10) as u32;
     let base = SUMMARIZATION_RETRY_BASE_MS.saturating_mul(1u64 << exponent);
@@ -2909,6 +4510,14 @@ impl<'a> InsertMode<'a> {
                 self.app.set_status("Busy: waiting for tool results");
                 return None;
             }
+            AppState::Enabled(EnabledState::ToolLoop(_)) => {
+                self.app.set_status("Busy: tool execution in progress");
+                return None;
+            }
+            AppState::Enabled(EnabledState::ToolRecovery(_)) => {
+                self.app.set_status("Busy: tool recovery pending");
+                return None;
+            }
             AppState::Enabled(EnabledState::Summarizing(_))
             | AppState::Enabled(EnabledState::SummarizingWithQueued(_))
             | AppState::Enabled(EnabledState::SummarizationRetry(_))
@@ -2951,6 +4560,7 @@ impl<'a> InsertMode<'a> {
         self.app.pending_user_message = Some((msg_id, raw_content));
 
         self.app.scroll_to_bottom();
+        self.app.tool_iterations = 0;
 
         let api_key = match self.app.model.provider() {
             Provider::Claude => ApiKey::Claude(api_key),
@@ -3211,6 +4821,21 @@ mod tests {
         let output_limits = OutputLimits::new(4096);
         let mut context_manager = ContextManager::new(model.as_str());
         context_manager.set_output_limit(output_limits.max_output_tokens());
+        let tool_settings = App::tool_settings_from_config(None);
+        let mut tool_registry = tools::ToolRegistry::default();
+        let _ = tools::builtins::register_builtins(
+            &mut tool_registry,
+            tool_settings.read_limits,
+            tool_settings.patch_limits,
+        );
+        let tool_registry = std::sync::Arc::new(tool_registry);
+        let tool_definitions = match tool_settings.mode {
+            tools::ToolsMode::Enabled => tool_registry.definitions(),
+            tools::ToolsMode::ParseOnly => Vec::new(),
+            tools::ToolsMode::Disabled => Vec::new(),
+        };
+        let tool_journal = ToolJournal::open_in_memory().expect("in-memory tool journal");
+        let tool_file_cache = std::sync::Arc::new(tokio::sync::Mutex::new(HashMap::new()));
 
         App {
             input: InputState::default(),
@@ -3235,7 +4860,13 @@ mod tests {
             system_prompt: None,
             cached_usage_status: None,
             pending_user_message: None,
-            tool_definitions: Vec::new(),
+            tool_definitions,
+            tool_registry,
+            tools_mode: tool_settings.mode,
+            tool_settings,
+            tool_journal,
+            tool_file_cache,
+            tool_iterations: 0,
         }
     }
 
@@ -3382,6 +5013,8 @@ mod tests {
             message: streaming,
             journal,
             abort_handle,
+            tool_batch_id: None,
+            tool_call_seq: 0,
         }));
         assert!(app.is_loading());
 
diff --git a/providers/src/lib.rs b/providers/src/lib.rs
index f0eb7fb..82c89ca 100644
--- a/providers/src/lib.rs
+++ b/providers/src/lib.rs
@@ -545,6 +545,7 @@ pub mod claude {
 pub mod openai {
     use super::*;
     use serde_json::{Value, json};
+    use std::collections::{HashMap, HashSet};
 
     const API_URL: &str = "https://api.openai.com/v1/responses";
 
@@ -572,6 +573,23 @@ pub mod openai {
             .map(|s| s.to_string())
     }
 
+    fn resolve_call_id(
+        item_id: Option<&str>,
+        call_id: Option<&str>,
+        item_to_call: &HashMap<String, String>,
+    ) -> Option<String> {
+        if let Some(call_id) = call_id {
+            return Some(call_id.to_string());
+        }
+        if let Some(item_id) = item_id {
+            if let Some(mapped) = item_to_call.get(item_id) {
+                return Some(mapped.clone());
+            }
+            return Some(item_id.to_string());
+        }
+        None
+    }
+
     /// Map message role to OpenAI Responses API role.
     ///
     /// Per the OpenAI Model Spec, the authority hierarchy is:
@@ -600,11 +618,31 @@ pub mod openai {
         let mut input_items: Vec<Value> = Vec::new();
         for cacheable in messages {
             let msg = &cacheable.message;
-            // TODO: Handle ToolUse and ToolResult message variants for OpenAI format
-            input_items.push(json!({
-                "role": openai_role(msg),
-                "content": msg.content(),
-            }));
+            match msg {
+                Message::ToolUse(call) => {
+                    let args_json =
+                        serde_json::to_string(&call.arguments).unwrap_or_else(|_| "{}".to_string());
+                    input_items.push(json!({
+                        "type": "function_call",
+                        "call_id": call.id,
+                        "name": call.name,
+                        "arguments": args_json,
+                    }));
+                }
+                Message::ToolResult(result) => {
+                    input_items.push(json!({
+                        "type": "function_call_output",
+                        "call_id": result.tool_call_id,
+                        "output": result.content,
+                    }));
+                }
+                _ => {
+                    input_items.push(json!({
+                        "role": openai_role(msg),
+                        "content": msg.content(),
+                    }));
+                }
+            }
         }
 
         let mut body = serde_json::Map::new();
@@ -622,9 +660,22 @@ pub mod openai {
             body.insert("instructions".to_string(), json!(prompt));
         }
 
-        // TODO: Add tool definitions for OpenAI format when tools is Some
-        // OpenAI uses "tools" array with "type": "function" wrapper
-        let _ = tools; // Suppress unused warning for now
+        if let Some(tools) = tools
+            && !tools.is_empty()
+        {
+            let tool_defs: Vec<Value> = tools
+                .iter()
+                .map(|tool| {
+                    json!({
+                        "type": "function",
+                        "name": tool.name,
+                        "description": tool.description,
+                        "parameters": tool.parameters,
+                    })
+                })
+                .collect();
+            body.insert("tools".to_string(), Value::Array(tool_defs));
+        }
 
         let options = config.openai_options();
         body.insert(
@@ -682,6 +733,8 @@ pub mod openai {
         let mut buffer: Vec<u8> = Vec::new();
         let mut saw_delta = false;
         let saw_done = false;
+        let mut item_to_call: HashMap<String, String> = HashMap::new();
+        let mut call_has_delta: HashSet<String> = HashSet::new();
 
         while let Some(chunk) = stream.next().await {
             let chunk = chunk?;
@@ -718,6 +771,38 @@ pub mod openai {
 
                     if let Ok(json) = serde_json::from_str::<Value>(&data) {
                         match json["type"].as_str().unwrap_or("") {
+                            "response.output_item.added" => {
+                                let item = json.get("item").or_else(|| json.get("output_item"));
+                                if let Some(item) = item
+                                    && item.get("type").and_then(|value| value.as_str())
+                                        == Some("function_call")
+                                {
+                                    let item_id = item.get("id").and_then(|v| v.as_str());
+                                    let call_id = item.get("call_id").and_then(|v| v.as_str()).or(item_id);
+                                    let name = item.get("name").and_then(|v| v.as_str()).unwrap_or("");
+                                    if let Some(call_id) = call_id {
+                                        let call_id = call_id.to_string();
+                                        if let Some(item_id) = item_id {
+                                            item_to_call
+                                                .insert(item_id.to_string(), call_id.clone());
+                                        }
+                                        on_event(StreamEvent::ToolCallStart {
+                                            id: call_id.clone(),
+                                            name: name.to_string(),
+                                        });
+                                        if let Some(arguments) =
+                                            item.get("arguments").and_then(|v| v.as_str())
+                                            && !arguments.is_empty()
+                                        {
+                                            on_event(StreamEvent::ToolCallDelta {
+                                                id: call_id.clone(),
+                                                arguments: arguments.to_string(),
+                                            });
+                                            call_has_delta.insert(call_id);
+                                        }
+                                    }
+                                }
+                            }
                             "response.output_text.delta" => {
                                 if let Some(delta) = json["delta"].as_str() {
                                     saw_delta = true;
@@ -735,6 +820,40 @@ pub mod openai {
                                     on_event(StreamEvent::TextDelta(text.to_string()));
                                 }
                             }
+                            "response.function_call_arguments.delta" => {
+                                let item_id = json.get("item_id").and_then(|v| v.as_str());
+                                let call_id = json.get("call_id").and_then(|v| v.as_str());
+                                let resolved =
+                                    resolve_call_id(item_id, call_id, &item_to_call);
+                                if let Some(delta) = json.get("delta").and_then(|v| v.as_str())
+                                    && let Some(call_id) = resolved
+                                {
+                                    on_event(StreamEvent::ToolCallDelta {
+                                        id: call_id.clone(),
+                                        arguments: delta.to_string(),
+                                    });
+                                    call_has_delta.insert(call_id);
+                                }
+                            }
+                            "response.function_call_arguments.done" => {
+                                let item_id = json.get("item_id").and_then(|v| v.as_str());
+                                let call_id = json.get("call_id").and_then(|v| v.as_str());
+                                let resolved =
+                                    resolve_call_id(item_id, call_id, &item_to_call);
+                                if let Some(arguments) = json.get("arguments").and_then(|v| v.as_str())
+                                    && let Some(call_id) = resolved
+                                {
+                                    if !call_has_delta.contains(&call_id)
+                                        && !arguments.is_empty()
+                                    {
+                                        on_event(StreamEvent::ToolCallDelta {
+                                            id: call_id.clone(),
+                                            arguments: arguments.to_string(),
+                                        });
+                                    }
+                                    call_has_delta.insert(call_id);
+                                }
+                            }
                             "response.completed" => {
                                 on_event(StreamEvent::Done);
                                 return Ok(());
diff --git a/tui/src/input.rs b/tui/src/input.rs
index edf3e2e..6fab431 100644
--- a/tui/src/input.rs
+++ b/tui/src/input.rs
@@ -42,6 +42,30 @@ pub async fn handle_events(app: &mut App) -> Result<bool> {
 }
 
 fn handle_normal_mode(app: &mut App, key: KeyEvent) {
+    if app.tool_approval_requests().is_some() {
+        match key.code {
+            KeyCode::Char('k') | KeyCode::Up => app.tool_approval_move_up(),
+            KeyCode::Char('j') | KeyCode::Down => app.tool_approval_move_down(),
+            KeyCode::Char(' ') => app.tool_approval_toggle(),
+            KeyCode::Char('a') => app.tool_approval_approve_all(),
+            KeyCode::Char('d') => app.tool_approval_deny_all(),
+            KeyCode::Enter => app.tool_approval_confirm_selected(),
+            KeyCode::Esc => app.tool_approval_deny_all(),
+            _ => {}
+        }
+        return;
+    }
+
+    if app.tool_recovery_calls().is_some() {
+        match key.code {
+            KeyCode::Char('r') => app.tool_recovery_resume(),
+            KeyCode::Char('d') => app.tool_recovery_discard(),
+            KeyCode::Esc => app.tool_recovery_discard(),
+            _ => {}
+        }
+        return;
+    }
+
     match key.code {
         // Quit
         KeyCode::Char('q') => {
diff --git a/tui/src/lib.rs b/tui/src/lib.rs
index a617734..138b848 100644
--- a/tui/src/lib.rs
+++ b/tui/src/lib.rs
@@ -30,6 +30,7 @@ use unicode_width::UnicodeWidthStr;
 use forge_engine::{
     App, ContextUsageStatus, DisplayItem, InputMode, Message, PredefinedModel, Provider,
 };
+use forge_types::ToolResult;
 
 pub use self::markdown::clear_render_cache;
 use self::markdown::render_markdown;
@@ -68,6 +69,14 @@ pub fn draw(frame: &mut Frame, app: &mut App) {
     if app.input_mode() == InputMode::ModelSelect {
         draw_model_selector(frame, app);
     }
+
+    if app.tool_approval_requests().is_some() {
+        draw_tool_approval_prompt(frame, app);
+    }
+
+    if app.tool_recovery_calls().is_some() {
+        draw_tool_recovery_prompt(frame, app);
+    }
 }
 
 fn draw_messages(frame: &mut Frame, app: &mut App, area: Rect) {
@@ -260,6 +269,133 @@ fn draw_messages(frame: &mut Frame, app: &mut App, area: Rect) {
                 Style::default().fg(colors::TEXT_MUTED),
             )));
         }
+
+        lines.push(Line::from(Span::styled(
+            "  Use /tool <id> <result> or /tool error <id> <message>",
+            Style::default()
+                .fg(colors::TEXT_MUTED)
+                .add_modifier(Modifier::ITALIC),
+        )));
+    }
+
+    if let Some(calls) = app.tool_loop_calls() {
+        if msg_count > 0 || app.streaming().is_some() || app.pending_tool_calls().is_some() {
+            lines.push(Line::from(""));
+        }
+        let spinner = spinner_frame(app.tick_count());
+        let approval_pending = app.tool_approval_requests().is_some();
+        let header = if approval_pending {
+            format!("{spinner} Tool approval required")
+        } else {
+            format!("{spinner} Tool execution")
+        };
+        lines.push(Line::from(Span::styled(
+            header,
+            Style::default()
+                .fg(colors::WARNING)
+                .add_modifier(Modifier::ITALIC),
+        )));
+
+        let mut results_map: std::collections::HashMap<&str, &ToolResult> =
+            std::collections::HashMap::new();
+        if let Some(results) = app.tool_loop_results() {
+            for result in results {
+                results_map.insert(result.tool_call_id.as_str(), result);
+            }
+        }
+
+        let execute_ids: std::collections::HashSet<&str> = app
+            .tool_loop_execute_calls()
+            .map(|exec_calls| exec_calls.iter().map(|c| c.id.as_str()).collect())
+            .unwrap_or_default();
+
+        let current_id = app.tool_loop_current_call_id();
+
+        for call in calls {
+            let result = results_map.get(call.id.as_str());
+            let mut reason: Option<String> = None;
+            let (icon, style) = if let Some(result) = result {
+                if !execute_ids.contains(call.id.as_str()) {
+                    reason = result
+                        .content
+                        .lines()
+                        .next()
+                        .map(|line| truncate_with_ellipsis(line, 80));
+                    (
+                        "",
+                        Style::default()
+                            .fg(colors::WARNING)
+                            .add_modifier(Modifier::BOLD),
+                    )
+                } else if result.is_error {
+                    reason = result
+                        .content
+                        .lines()
+                        .next()
+                        .map(|line| truncate_with_ellipsis(line, 80));
+                    (
+                        "",
+                        Style::default()
+                            .fg(colors::ERROR)
+                            .add_modifier(Modifier::BOLD),
+                    )
+                } else {
+                    (
+                        "",
+                        Style::default()
+                            .fg(colors::SUCCESS)
+                            .add_modifier(Modifier::BOLD),
+                    )
+                }
+            } else if current_id == Some(call.id.as_str()) {
+                (
+                    spinner,
+                    Style::default()
+                        .fg(colors::PRIMARY)
+                        .add_modifier(Modifier::BOLD),
+                )
+            } else if approval_pending && !execute_ids.contains(call.id.as_str()) {
+                (
+                    "",
+                    Style::default()
+                        .fg(colors::WARNING)
+                        .add_modifier(Modifier::BOLD),
+                )
+            } else {
+                ("", Style::default().fg(colors::TEXT_MUTED))
+            };
+
+            lines.push(Line::from(vec![
+                Span::styled(format!("  {icon} "), style),
+                Span::styled(
+                    format!("{} ({})", call.name, call.id),
+                    Style::default().fg(colors::TEXT_MUTED),
+                ),
+            ]));
+
+            if let Some(reason) = reason {
+                lines.push(Line::from(Span::styled(
+                    format!("     {reason}"),
+                    Style::default().fg(colors::TEXT_MUTED),
+                )));
+            }
+        }
+
+        if let Some(output_lines) = app.tool_loop_output_lines() {
+            if !output_lines.is_empty() {
+                lines.push(Line::from(""));
+                lines.push(Line::from(Span::styled(
+                    "  Tool output:",
+                    Style::default().fg(colors::TEXT_MUTED),
+                )));
+                for line in output_lines {
+                    lines.push(Line::from(Span::styled(
+                        format!("    {line}"),
+                        Style::default().fg(colors::TEXT_SECONDARY),
+                    )));
+                }
+            }
+        }
     }
 
     // Calculate content height and visible height for scrolling
@@ -320,6 +456,17 @@ fn wrapped_line_count(lines: &[Line], width: u16) -> u16 {
     total
 }
 
+fn truncate_with_ellipsis(raw: &str, max: usize) -> String {
+    let max = max.max(3);
+    let trimmed = raw.trim();
+    if trimmed.chars().count() <= max {
+        trimmed.to_string()
+    } else {
+        let head: String = trimmed.chars().take(max - 3).collect();
+        format!("{head}...")
+    }
+}
+
 pub(crate) fn draw_input(frame: &mut Frame, app: &mut App, area: Rect) {
     let mode = app.input_mode();
     // Clone command text to avoid borrow conflict with mutable context_usage_status()
@@ -784,6 +931,186 @@ pub fn draw_model_selector(frame: &mut Frame, app: &mut App) {
     frame.render_widget(selector, selector_area);
 }
 
+fn draw_tool_approval_prompt(frame: &mut Frame, app: &App) {
+    let Some(requests) = app.tool_approval_requests() else {
+        return;
+    };
+    let selected = app.tool_approval_selected().unwrap_or(&[]);
+    let cursor = app.tool_approval_cursor().unwrap_or(0);
+
+    let mut lines: Vec<Line> = Vec::new();
+    lines.push(Line::from(Span::styled(
+        " Tool approval required ",
+        Style::default()
+            .fg(colors::TEXT_PRIMARY)
+            .add_modifier(Modifier::BOLD),
+    )));
+    lines.push(Line::from(""));
+
+    let max_width = frame.area().width.saturating_sub(6).min(80).max(20) as usize;
+
+    for (i, req) in requests.iter().enumerate() {
+        let is_selected = selected.get(i).copied().unwrap_or(false);
+        let pointer = if i == cursor { ">" } else { " " };
+        let checkbox = if is_selected { "[x]" } else { "[ ]" };
+        let risk_label = format!("{:?}", req.risk_level).to_uppercase();
+        let risk_style = match risk_label.as_str() {
+            "HIGH" => Style::default().fg(colors::ERROR).add_modifier(Modifier::BOLD),
+            "MEDIUM" => Style::default().fg(colors::WARNING).add_modifier(Modifier::BOLD),
+            _ => Style::default().fg(colors::SUCCESS).add_modifier(Modifier::BOLD),
+        };
+        let name_style = if i == cursor {
+            Style::default()
+                .fg(colors::TEXT_PRIMARY)
+                .add_modifier(Modifier::BOLD)
+        } else {
+            Style::default().fg(colors::TEXT_PRIMARY)
+        };
+
+        lines.push(Line::from(vec![
+            Span::styled(
+                format!("{pointer} {checkbox} "),
+                Style::default().fg(colors::TEXT_MUTED),
+            ),
+            Span::styled(req.tool_name.clone(), name_style),
+            Span::raw(" "),
+            Span::styled(risk_label, risk_style),
+        ]));
+
+        if !req.summary.trim().is_empty() {
+            let summary = truncate_with_ellipsis(&req.summary, max_width.saturating_sub(6));
+            lines.push(Line::from(Span::styled(
+                format!("    {summary}"),
+                Style::default().fg(colors::TEXT_MUTED),
+            )));
+        }
+    }
+
+    lines.push(Line::from(""));
+    lines.push(Line::from(vec![
+        Span::styled("A", styles::key_highlight()),
+        Span::styled(" approve all  ", styles::key_hint()),
+        Span::styled("D", styles::key_highlight()),
+        Span::styled(" deny all  ", styles::key_hint()),
+        Span::styled("Space", styles::key_highlight()),
+        Span::styled(" toggle  ", styles::key_hint()),
+        Span::styled("Enter", styles::key_highlight()),
+        Span::styled(" confirm selected", styles::key_hint()),
+    ]));
+
+    let content_width = lines.iter().map(|line| line.width()).max().unwrap_or(10) as u16;
+    let content_width = content_width.min(frame.area().width.saturating_sub(4));
+    let content_height = lines.len() as u16;
+
+    let block = Block::default()
+        .borders(Borders::ALL)
+        .border_type(BorderType::Rounded)
+        .border_style(Style::default().fg(colors::PRIMARY))
+        .style(Style::default().bg(colors::BG_PANEL))
+        .padding(Padding::uniform(1));
+
+    let height = content_height.saturating_add(4);
+    let width = content_width.saturating_add(4);
+    let area = frame.area();
+    let rect = Rect {
+        x: area.x + (area.width.saturating_sub(width) / 2),
+        y: area.y + (area.height.saturating_sub(height) / 2),
+        width,
+        height,
+    };
+
+    frame.render_widget(Clear, rect);
+    frame.render_widget(Paragraph::new(lines).block(block), rect);
+}
+
+fn draw_tool_recovery_prompt(frame: &mut Frame, app: &App) {
+    let Some(calls) = app.tool_recovery_calls() else {
+        return;
+    };
+    let results = app.tool_recovery_results().unwrap_or(&[]);
+
+    let mut results_map: std::collections::HashMap<&str, &ToolResult> =
+        std::collections::HashMap::new();
+    for result in results {
+        results_map.insert(result.tool_call_id.as_str(), result);
+    }
+
+    let mut lines: Vec<Line> = Vec::new();
+    lines.push(Line::from(Span::styled(
+        " Tool recovery detected ",
+        Style::default()
+            .fg(colors::TEXT_PRIMARY)
+            .add_modifier(Modifier::BOLD),
+    )));
+    lines.push(Line::from(Span::styled(
+        " Tools will not be re-run.",
+        Style::default().fg(colors::TEXT_MUTED),
+    )));
+    lines.push(Line::from(""));
+
+    for call in calls {
+        let (icon, style) = if let Some(result) = results_map.get(call.id.as_str()) {
+            if result.is_error {
+                (
+                    "",
+                    Style::default()
+                        .fg(colors::ERROR)
+                        .add_modifier(Modifier::BOLD),
+                )
+            } else {
+                (
+                    "",
+                    Style::default()
+                        .fg(colors::SUCCESS)
+                        .add_modifier(Modifier::BOLD),
+                )
+            }
+        } else {
+            ("", Style::default().fg(colors::TEXT_MUTED))
+        };
+
+        lines.push(Line::from(vec![
+            Span::styled(format!("  {icon} "), style),
+            Span::styled(
+                format!("{} ({})", call.name, call.id),
+                Style::default().fg(colors::TEXT_MUTED),
+            ),
+        ]));
+    }
+
+    lines.push(Line::from(""));
+    lines.push(Line::from(vec![
+        Span::styled("R", styles::key_highlight()),
+        Span::styled(" resume with recovered results  ", styles::key_hint()),
+        Span::styled("D", styles::key_highlight()),
+        Span::styled(" discard results", styles::key_hint()),
+    ]));
+
+    let content_width = lines.iter().map(|line| line.width()).max().unwrap_or(10) as u16;
+    let content_width = content_width.min(frame.area().width.saturating_sub(4));
+    let content_height = lines.len() as u16;
+
+    let block = Block::default()
+        .borders(Borders::ALL)
+        .border_type(BorderType::Rounded)
+        .border_style(Style::default().fg(colors::PRIMARY))
+        .style(Style::default().bg(colors::BG_PANEL))
+        .padding(Padding::uniform(1));
+
+    let height = content_height.saturating_add(4);
+    let width = content_width.saturating_add(4);
+    let area = frame.area();
+    let rect = Rect {
+        x: area.x + (area.width.saturating_sub(width) / 2),
+        y: area.y + (area.height.saturating_sub(height) / 2),
+        width,
+        height,
+    };
+
+    frame.render_widget(Clear, rect);
+    frame.render_widget(Paragraph::new(lines).block(block), rect);
+}
+
 fn create_welcome_screen(app: &App) -> Paragraph<'static> {
     let logo = vec![
         Line::from(""),
diff --git a/tui/src/ui_inline.rs b/tui/src/ui_inline.rs
index 5a6efca..10d023d 100644
--- a/tui/src/ui_inline.rs
+++ b/tui/src/ui_inline.rs
@@ -33,6 +33,11 @@ pub fn inline_viewport_height(mode: InputMode) -> u16 {
 pub struct InlineOutput {
     next_display_index: usize,
     has_output: bool,
+    last_tool_output_len: usize,
+    last_tool_status_signature: Option<String>,
+    last_pending_tool_signature: Option<String>,
+    last_approval_signature: Option<String>,
+    last_recovery_active: bool,
 }
 
 impl InlineOutput {
@@ -40,6 +45,11 @@ impl InlineOutput {
         Self {
             next_display_index: 0,
             has_output: false,
+            last_tool_output_len: 0,
+            last_tool_status_signature: None,
+            last_pending_tool_signature: None,
+            last_approval_signature: None,
+            last_recovery_active: false,
         }
     }
 
@@ -48,23 +58,69 @@ impl InlineOutput {
         B: Backend,
     {
         let items = app.display_items();
-        if self.next_display_index >= items.len() {
-            return Ok(());
-        }
-
         let mut lines: Vec<Line> = Vec::new();
         let mut msg_count = if self.has_output { 1 } else { 0 };
 
-        for item in &items[self.next_display_index..] {
-            let msg = match item {
-                DisplayItem::History(id) => app.history().get_entry(*id).message(),
-                DisplayItem::Local(msg) => msg,
-            };
+        if self.next_display_index < items.len() {
+            for item in &items[self.next_display_index..] {
+                let msg = match item {
+                    DisplayItem::History(id) => app.history().get_entry(*id).message(),
+                    DisplayItem::Local(msg) => msg,
+                };
+
+                append_message_lines(&mut lines, msg, &mut msg_count);
+            }
 
-            append_message_lines(&mut lines, msg, &mut msg_count);
+            self.next_display_index = items.len();
         }
 
-        self.next_display_index = items.len();
+        let tool_signature = tool_status_signature(app);
+        if tool_signature != self.last_tool_status_signature {
+            if tool_signature.is_some() {
+                append_tool_status_lines(&mut lines, app);
+            }
+            self.last_tool_status_signature = tool_signature;
+        }
+
+        let pending_signature = pending_tool_signature(app);
+        if pending_signature != self.last_pending_tool_signature {
+            if pending_signature.is_some() {
+                append_pending_tool_lines(&mut lines, app);
+            }
+            self.last_pending_tool_signature = pending_signature;
+        }
+
+        if let Some(output_lines) = app.tool_loop_output_lines() {
+            if output_lines.len() > self.last_tool_output_len {
+                if !lines.is_empty() {
+                    lines.push(Line::from(""));
+                }
+                if self.last_tool_output_len == 0 {
+                    lines.push(Line::from("Tool output:"));
+                }
+                for line in &output_lines[self.last_tool_output_len..] {
+                    lines.push(Line::from(format!("  {line}")));
+                }
+                self.last_tool_output_len = output_lines.len();
+            }
+        } else {
+            self.last_tool_output_len = 0;
+        }
+
+        let approval_signature = approval_signature(app);
+        if approval_signature != self.last_approval_signature {
+            if approval_signature.is_some() {
+                append_approval_lines(&mut lines, app);
+            }
+            self.last_approval_signature = approval_signature;
+        }
+
+        let recovery_active = app.tool_recovery_calls().is_some();
+        if recovery_active && !self.last_recovery_active {
+            append_recovery_prompt(&mut lines, app);
+        }
+        self.last_recovery_active = recovery_active;
+
         if lines.is_empty() {
             return Ok(());
         }
@@ -221,6 +277,186 @@ fn append_message_lines(lines: &mut Vec<Line>, msg: &Message, msg_count: &mut us
     }
 }
 
+fn tool_status_signature(app: &App) -> Option<String> {
+    let calls = app.tool_loop_calls()?;
+    let mut results_map: std::collections::HashMap<&str, &forge_types::ToolResult> =
+        std::collections::HashMap::new();
+    if let Some(results) = app.tool_loop_results() {
+        for result in results {
+            results_map.insert(result.tool_call_id.as_str(), result);
+        }
+    }
+    let execute_ids: std::collections::HashSet<&str> = app
+        .tool_loop_execute_calls()
+        .map(|exec_calls| exec_calls.iter().map(|c| c.id.as_str()).collect())
+        .unwrap_or_default();
+    let current_id = app.tool_loop_current_call_id();
+    let approval_pending = app.tool_approval_requests().is_some();
+
+    let mut parts = Vec::with_capacity(calls.len());
+    for call in calls {
+        let status = if let Some(result) = results_map.get(call.id.as_str()) {
+            if !execute_ids.contains(call.id.as_str()) {
+                "denied"
+            } else if result.is_error {
+                "error"
+            } else {
+                "ok"
+            }
+        } else if current_id == Some(call.id.as_str()) {
+            "running"
+        } else if approval_pending && !execute_ids.contains(call.id.as_str()) {
+            "approval"
+        } else {
+            "pending"
+        };
+        parts.push(format!("{}:{status}", call.id));
+    }
+
+    Some(parts.join("|"))
+}
+
+fn pending_tool_signature(app: &App) -> Option<String> {
+    let calls = app.pending_tool_calls()?;
+    let mut parts = Vec::with_capacity(calls.len());
+    for call in calls {
+        parts.push(call.id.clone());
+    }
+    Some(parts.join("|"))
+}
+
+fn append_tool_status_lines(lines: &mut Vec<Line>, app: &App) {
+    let Some(calls) = app.tool_loop_calls() else {
+        return;
+    };
+    let mut results_map: std::collections::HashMap<&str, &forge_types::ToolResult> =
+        std::collections::HashMap::new();
+    if let Some(results) = app.tool_loop_results() {
+        for result in results {
+            results_map.insert(result.tool_call_id.as_str(), result);
+        }
+    }
+    let execute_ids: std::collections::HashSet<&str> = app
+        .tool_loop_execute_calls()
+        .map(|exec_calls| exec_calls.iter().map(|c| c.id.as_str()).collect())
+        .unwrap_or_default();
+    let current_id = app.tool_loop_current_call_id();
+    let approval_pending = app.tool_approval_requests().is_some();
+
+    if !lines.is_empty() {
+        lines.push(Line::from(""));
+    }
+    lines.push(Line::from("Tool status:"));
+
+    for call in calls {
+        let mut reason: Option<String> = None;
+        let icon = if let Some(result) = results_map.get(call.id.as_str()) {
+            if !execute_ids.contains(call.id.as_str()) {
+                reason = result
+                    .content
+                    .lines()
+                    .next()
+                    .map(|line| truncate_with_ellipsis(line, 80));
+                ""
+            } else if result.is_error {
+                reason = result
+                    .content
+                    .lines()
+                    .next()
+                    .map(|line| truncate_with_ellipsis(line, 80));
+                ""
+            } else {
+                ""
+            }
+        } else if current_id == Some(call.id.as_str()) {
+            ""
+        } else if approval_pending && !execute_ids.contains(call.id.as_str()) {
+            ""
+        } else {
+            ""
+        };
+
+        lines.push(Line::from(format!(
+            "  {icon} {} ({})",
+            call.name, call.id
+        )));
+        if let Some(reason) = reason {
+            lines.push(Line::from(format!("     {reason}")));
+        }
+    }
+}
+
+fn append_pending_tool_lines(lines: &mut Vec<Line>, app: &App) {
+    let Some(calls) = app.pending_tool_calls() else {
+        return;
+    };
+    if !lines.is_empty() {
+        lines.push(Line::from(""));
+    }
+    lines.push(Line::from("Awaiting tool results:"));
+    for call in calls {
+        lines.push(Line::from(format!("   {} ({})", call.name, call.id)));
+    }
+    lines.push(Line::from(
+        "Use /tool <id> <result> or /tool error <id> <message>",
+    ));
+}
+
+fn approval_signature(app: &App) -> Option<String> {
+    let requests = app.tool_approval_requests()?;
+    let selected = app.tool_approval_selected().unwrap_or(&[]);
+    let cursor = app.tool_approval_cursor().unwrap_or(0);
+    let mut sig = format!("{}|{}|", requests.len(), cursor);
+    for flag in selected {
+        sig.push(if *flag { '1' } else { '0' });
+    }
+    Some(sig)
+}
+
+fn append_approval_lines(lines: &mut Vec<Line>, app: &App) {
+    let Some(requests) = app.tool_approval_requests() else {
+        return;
+    };
+    let selected = app.tool_approval_selected().unwrap_or(&[]);
+    let cursor = app.tool_approval_cursor().unwrap_or(0);
+
+    if !lines.is_empty() {
+        lines.push(Line::from(""));
+    }
+    lines.push(Line::from("Tool approval required:"));
+
+    for (i, req) in requests.iter().enumerate() {
+        let is_selected = selected.get(i).copied().unwrap_or(false);
+        let pointer = if i == cursor { ">" } else { " " };
+        let checkbox = if is_selected { "[x]" } else { "[ ]" };
+        let risk = format!("{:?}", req.risk_level).to_uppercase();
+        lines.push(Line::from(format!(
+            " {pointer} {checkbox} {} ({risk})",
+            req.tool_name
+        )));
+        if !req.summary.trim().is_empty() {
+            let summary = truncate_with_ellipsis(&req.summary, 80);
+            lines.push(Line::from(format!("     {summary}")));
+        }
+    }
+
+    lines.push(Line::from(
+        "Keys: A approve all, D deny all, Space toggle, Enter confirm",
+    ));
+}
+
+fn append_recovery_prompt(lines: &mut Vec<Line>, app: &App) {
+    if app.tool_recovery_calls().is_none() {
+        return;
+    }
+    if !lines.is_empty() {
+        lines.push(Line::from(""));
+    }
+    lines.push(Line::from(
+        "Tool recovery detected. Press r to resume or d to discard.",
+    ));
+}
+
 fn wrapped_line_count(lines: &[Line], width: u16) -> u16 {
     let width = width.max(1) as usize;
     let mut total: u16 = 0;
@@ -237,3 +473,14 @@ fn wrapped_line_count(lines: &[Line], width: u16) -> u16 {
 
     total
 }
+
+fn truncate_with_ellipsis(raw: &str, max: usize) -> String {
+    let max = max.max(3);
+    let trimmed = raw.trim();
+    if trimmed.chars().count() <= max {
+        trimmed.to_string()
+    } else {
+        let head: String = trimmed.chars().take(max - 3).collect();
+        format!("{head}...")
+    }
+}
